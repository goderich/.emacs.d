* Table of Contents :TOC:
- [[#introduction][Introduction]]
  - [[#history][History]]
  - [[#resources][Resources]]
- [[#basic-settings][Basic settings]]
  - [[#early-loading][Early loading]]
  - [[#package-management][Package management]]
  - [[#in-built-packages][In-built packages]]
  - [[#vars][Vars]]
  - [[#theming][Theming]]
  - [[#fonts][Fonts]]
  - [[#dashboard][Dashboard]]
  - [[#modeline][Modeline]]
- [[#boon][Boon]]
  - [[#boon-command-state][Boon command state]]
  - [[#boon-insert-state][Boon insert state]]
  - [[#boon-special-state][Boon special state]]
- [[#minibuffer-keybindings][Minibuffer keybindings]]
- [[#transient-commands][Transient commands]]
  - [[#goto-transient][Goto transient]]
  - [[#narrowing-transient][Narrowing transient]]
  - [[#window-resizing-transient][Window resizing transient]]
  - [[#file-transient][File transient]]
  - [[#buffer-transient][Buffer transient]]
  - [[#helpful-transient][Helpful transient]]
  - [[#olivetti-transient][Olivetti transient]]
  - [[#org-navigation-transient][Org navigation transient]]
- [[#narrowing-and-completion][Narrowing and completion]]
  - [[#narrowing][Narrowing]]
  - [[#completion-corfu][Completion (Corfu)]]
- [[#org-mode][Org-mode]]
  - [[#org-settings][Org settings]]
  - [[#org-src][Org-src]]
  - [[#snippet-expansion-in-org][Snippet expansion in org]]
  - [[#org-agenda][Org agenda]]
  - [[#org-bling][Org bling]]
  - [[#pandoc-integration][Pandoc integration]]
  - [[#links][Links]]
  - [[#yt-dlp][Yt-dlp]]
  - [[#cross-referencing][Cross-referencing]]
  - [[#org-books][Org-books]]
  - [[#org-cite-disabled][Org cite (disabled)]]
  - [[#org-functions][Org functions]]
  - [[#toc-org][Toc-org]]
- [[#typst][Typst]]
- [[#bibliography-and-citations][Bibliography and citations]]
  - [[#ebib][Ebib]]
- [[#programming-languages][Programming languages]]
  - [[#lisps][Lisps]]
  - [[#emacs-lisp][Emacs Lisp]]
  - [[#clojure][Clojure]]
  - [[#hare][Hare]]
- [[#markup-languages][Markup languages]]
  - [[#yaml][YAML]]
- [[#utils][Utils]]
  - [[#magit][Magit]]
  - [[#tempel-snippets][Tempel snippets]]
  - [[#crux][Crux]]
  - [[#avy][Avy]]
  - [[#link-hinting][Link hinting]]
  - [[#dumb-jump][Dumb jump]]
  - [[#anzu][Anzu]]
  - [[#hl-todo][hl-todo]]
  - [[#olivetti][Olivetti]]
  - [[#ws-butler][ws-butler]]
  - [[#help][Help]]
  - [[#tldr][Tldr]]
  - [[#undo][Undo]]
  - [[#evil-numbers-disabled][Evil-numbers (disabled)]]
- [[#finalize][Finalize]]

* Introduction

Welcome to my literate Emacs configuration file! I suggest you read this section first before you go on. Note that a few of the links in this file are org-mode links. If you are reading this file online and stumble across a seemingly dead link, it might simply be an org link.

My config is:
- [[https://harryrschwartz.com/2016/02/15/switching-to-a-literate-emacs-configuration][literate]],
- centered on [[https://github.com/jwiegley/use-package][use-package]] with defers,
- based around modal editing with [[https://github.com/jyp/boon][boon]],
- [[https://github.com/magit/transient][transient]]-heavy,
- full of my personal functions and quirks,
- still very much in flux.

Let's break some of the above down a little.

=use-package= is favoured by many Emacs gurus as a configuration technique /par excellence/ (along with literal configs of course). It helps keep related code in one place, instead of all around your config. And since it's included in newer versions of Emacs, using it is a no-brainer.

Crucially, =use-package= also supports lazy loading (i.e. delayed evaluation), which speeds up Emacs start-up time tremendously. The term used in =use-package= for this is 'defer'. Deferring packages is not particularly difficult, but it does require some thinking ahead and maybe tinkering. Of course, optimization is a never-ending game, but I try to keep it reasonable. As of this writing, Emacs starts in 2.6 seconds on my Surface Go 2 tablet (and a lot faster on my laptop and desktop), so I'm happy with where it is right now.

One more thing I'm doing with my literate config is splitting the source blocks with [[https://orgmode.org/manual/Noweb-Reference-Syntax.html][noweb]]. It goes like this: all the configuration and customization associated with a single package goes into one =use-package= block. That's simple and it makes sense. However, sometimes there is too much configuration, and the blocks get too long. I could add comments directly inside the source code (and I do that in a few places), but that seems to run counter to the core tenets of literate programming. Noweb allows me to separate blocks in the literate file to structure my text around them as I please, but still string them together when [[https://orgmode.org/manual/Extracting-Source-Code.html][tangling]] the resulting Elisp source file.

I am currently using the =boon= package for modal editing. However, although I started with the recommended Colemak keybindings, I modified them quite a bit (especially the movement keys). I try to keep my bindings ergonomic first and mnemonic second: the most common commands should be easy to type, and the less common ones easy to remember. What's ergonomic for me may not be ergonomic for you; adjust to your own setup.

For reasons of both ergonomics and mnemonics, I tend to eschew commands that require modifiers (Ctrl and Alt, or =C= and =M= in Emacs parlance), and instead opt for key combinations. That's the whole premise of a modal editing system like the one I'm using, of course. But I take this further by using (and sometimes abusing) transient commands to build my own mini-menus for all kinds of tasks from window management to export via pandoc.

I use quite a lot of my own functions in this config. As seems to be a convention with many users, I add a =+= to the beginning of my own functions to serve as a kind of namespace.

Although this began as a one-file literate config, I don't think including whole modules in it is a good idea. I have written a number of almost-packages for my personal use (maybe some of them will be published in future), and I keep them in their own files.

This config is still very much a work in progress, but it has reached a state where I can publish it for others to see.

** History

This section merely explains my history with Emacs, and may give a glimpse into my reasoning with some of the choices I have made. Feel free to skip it.

Before using Emacs, I cut my teeth on [[https://en.wikipedia.org/wiki/Vim_(text_editor)][vim]]. I kept hearing about Emacs of course, with its amazing features like [[https://orgmode.org/][org-mode]] and [[https://www.gnu.org/software/auctex/][auctex]] and [[https://magit.vc/][magit]], and that it wasn't just an editor, etc etc. But it was all so intimidating! I had no idea where to start. I tried a couple of times but got nowhere, and it seemed way too complicated and arcane.

My gateway to Emacs began with various [[https://github.com/emacs-evil/evil][evil]]-based "distributions" (really just ready-made configurations with a bunch of stuff already configured, mostly for programming). The first I found was [[https://github.com/syl20bnr/spacemacs][Spacemacs]], probably around the year 2015 or thereabouts, which I actually didn't even realize was just Emacs from its [[https://www.spacemacs.org/][website]]. (It says Emacs front and center now, but I seem to recall that wasn't the case ten years ago). Spacemacs was amazing! Suddenly I could use my vim knowledge for editing, and everything made sense! It had "layers" that you could enable and activate all the functionality you needed! You didn't even need to write much Elisp, just comment/uncomment stuff based on the layers you required. And it was slick, too. That futuristic pimp-purple theme made Emacs sexy again.

[[./img/vim2spacemacs.jpg]]

But Spacemacs was slow. It was huge, and its layers were a detriment to the editing experience. They even had a Spacemacs lite version, with a minimal amount of layers activated, so it wouldn't feel so sluggish. Another of Spacemacs' woes was its opacity, which in a way was its /raison d'Ãªtre/: the Spacemacs config was (and still is) almost fully detached from Emacs internals. In a way, that's the whole point: separating the users from the 40-year history of Emacs idiosyncracies, and just letting them get on with their work. However, when things broke, and break they did, fixing them by yourself was nigh impossible. At about this time, talk of a newer, sexier Emacs distribution reached my ears---Doom Emacs.

As far as I have been able to determine, [[https://github.com/doomemacs/doomemacs/][Doom Emacs]] began as hlissner's personal config based on the good parts of Spacemacs, and also centered on [[https://github.com/emacs-evil/evil][evil]], but as a thinner layer on top of Emacs itself. Doom was for *advanced* users. It unabashedly required you to read and write Elisp, follow the Doom discord channel, and keep up to date with Doom's development. It occasionally broke in unexpected ways, and required you to change things in your config, or sometimes just reinstall Doom completely. It was. So. Fukken. Rad.

[[./img/spacemacs2doom.jpg]]

Doom had "modules", kind of like Spacemacs layers, but with an added layer of customizability. You could add extra flags to your module to activate certain features (LSP or org-roam, for example), but that required you to actually try and figure out what those flags were doing, and exposed you to the underlying packages. Which is really all those modules did: they added an extra package and some keybindings to go with it.

Doom also had lots of churn in its early days. Packages were constantly added to and discarded from the distribution, which had the (perhaps unintended) effect of exposing the users to a whole lot of Emacs packages. Unlike Spacemacs, which hid the complexity from the user, with Doom you were forced to choose: helm, ivy, or vertico? company or corfu? lsp-mode or eglot?

All in all, I learned a whole lot about Emacs through Doom. In fact, I learned so much that I started to strain against the limits it imposed on me. The Doom layer, thinner than Spacemacs though it may have been, was still a barrier between me and the soft underbelly of Emacs. Customizing certain settings or keybindings looked very different from how others were doing it. Doom grew in popularity, and became more stable. At the same time, I grew restless, and started chafing at the bit a little, daydreaming about having a literal config of my own one day, but not daring to take that first step.

And then one fateful day, with only my Surface Go tablet at my disposal, I failed to update Doom. I tried reinstalling, and failed again, multiple times. The Doom install process fetches a whole lot of packages from source repositories, which led [[https://codeberg.org/][Codeberg]] to block my IP in case I was trawling their repos to train a new LLM.

And that was it. With no other option for using Emacs during a whole long weekend, I bit the bullet, I took the plunge. I knew precisely the packages I needed first and foremost. I had my Doom configuration right at my disposal, so I could copy and paste from it to my heart's content. What I did not have was that thin layer of protection between me and the pure unadulterated essense of Emacs. I had no access to Doom's convenience macros, so I had to learn to configure =use-package= and =evil= the way they were meant to be configured. I had to look for packages that provided the functionality I had taken for granted with Doom. I found alternative packages that I hadn't heard of before. I learned about functionality that Doom provided by itself and not through packages, some of it quite impressive. Bit by bit, I got to a config that was reasonably close to what I had had within Doom.

But that was not the end. Having finally weaned myself off Emacs distributions, I found myself staring in the face of yet another barrier, one that I had never thought I could forsake: [[https://github.com/emacs-evil/evil][evil]] itself. I had not dared to imagine using something else, but all that configuration [[./img/inception.jpg][planted the seeds of an idea]] in me. What if vim was not editing perfection? What if, instead of donning the scuba-suit of evil to venture out into the oceans of Elisp, I could take off the respirator and swim freely? What if I could shave off a whole 0.5s of Emacs init time?

Evil is a behemoth. It is a complete editor inside an editor. Just like how Emacs distributions hide the complexity of Emacs behind a sleek (yet necessarily limited) API, evil hides the editing functionality of Emacs by replacing *everything* with vim-like alternatives. I was using =:s= and =:norm=, vim macros, [[https://github.com/emacs-evil/evil-surround][evil-surround]], [[https://github.com/hlissner/evil-snipe][evil-snipe]], [[https://github.com/bling/evil-visualstar][evil-visualstar]], and [[https://github.com/edkolev/evil-lion][evil-lion]]. I was a vim maestro, flying through both code and prose at the speed of thought. How could I give up ten years of muscle memory for [[http://xahlee.info/emacs/emacs/emacs_hand_pain_celebrity.html][RSI]]?

I couldn't, of course. Not to move to the default keybindings. Why would I ever do that? There is more choice than just evil and the default keybindings, and I could pick and choose my settings as I wanted. I was annoyed by the assumption in many online discussions that using the default keybindings is the only proper way to Emacs. The whole point of Emacs, as I see it, is infinite customizability. Why should I ever let anyone tell me how I should be using *my Emacs*?

It was not hard to find other modal editing schemes for Emacs. In fact, Emacs has plenty of those. The difference is, people arriving to Emacs from vim tend to miss the comfort of that editing model, and evil exists to fill that niche. Other modal editing packages mostly exist for people coming from the default Emacs keybindings, when they decide they want to keep the use of their hands a little longer. Evil stands apart from the pack in that it is, essentially, vim. It implements pretty much all of vim's functionality in Emacs; anything different is considered a bug. Other packages, by choice and by necessity, play nice with Emacs internals. This makes them a lot more lightweight, at the cost of having to know more about the default Emacs editing experience.

In for a penny, in for a pound, I decided. I had had my eyes on =meow= for some time. It's a lightweight package that respects Emacs conventions, yet at the same time provides a full-fledged modal editing experience. Its editing mentality is not that of vim, but rather of [[https://kakoune.org/][kakoune]]: the normal and visual modes are combined, so that you select the text first before performing an action on it. I used meow for a few weeks, but during that period I found myself trying to modify its default settings and overwrite its keybindings more and more. I couldn't understand the proper usage of [[https://github.com/meow-edit/meow/blob/master/TUTORIAL.org#beacon][beacon state]] (or maybe it was a bit buggy, I couldn't tell). The constant visual selections actually annoyed me quite a bit to my surprise: I thought I'd be able to ignore them as the other meow users apparently do, but they really got on my nerves.

Which led me to [[https://github.com/jyp/boon][boon]]. Boon uses a more vim-like editing model (so no constant selections), but is even closer to Emacs defaults than meow. It doesn't appear to have much momentum right now---no users shilling for it, not much new development going on (ironically, I found out about boon from the meow readme). But that's because it's pretty much done. It's a very simple package, much less code than even meow, but it packs a ton of functionality. Everything I missed from evil is included, or can be trivially added. It lacks a great onboarding experience though: just a simple text tutorial, no flashy GIFs or videos, no huge wiki full of examples and customization options. Instead, you're kind of forced to read the code, which is wonderfully written by the way, but still an offputting experience for many, I imagine.

So in short, I went through the following stages:
1. vim
2. Spacemacs
3. Doom Emacs
4. evil (custom config)
5. (very briefly) meow
6. boon

This is where I am right now. Ten years of vim/evil, most of them spent using Doom. Suddenly, I'm in territory that's at once familiar and not. I've learned a lot about Emacs using Doom, and I've learned a lot more about Emacs after leaving Doom for my own config. I'm really grateful for Spacemacs, Doom, and evil, because without these projects I likely would not have started using Emacs. Now though, I'm ready for something new.

** Resources

Here are some of the resources I have consulted while writing my own config:
- [[https://github.com/bbatsov/emacs.d/blob/master/init.el][bbatsov's minimalist config]]
- [[https://github.com/hrs/dotfiles/blob/main/emacs/.config/emacs/configuration.org][Great evil-based config]] with a bunch of functional lang settings.
- [[https://github.com/zzamboni/dot-emacs/blob/master/init.org][Zzamboni's evil-based config]] prior to his migration to Doom. Lots of org gems there.
- [[https://zzamboni.org/post/my-doom-emacs-configuration-with-commentary/][Zzamboni's Doom config]]
- [[https://github.com/rougier/dotemacs/blob/master/dotemacs.org][Nicholas Rougier's literate config]]
- [[https://github.com/yantar92/emacs-config/blob/master/config.org][Ihor Radchenko's config]]
- See [[https://github.com/jschaf/dotfiles/blob/master/emacs/core/abn-core-emacs-settings.el][this config]] (including other files) for some obscure settings and startup hacks.
- [[https://sophiebos.io/posts/prettifying-emacs-org-mode/][org prettifying]]
- See [[https://www.reddit.com/r/emacs/comments/9zad13/managing_personal_packages_with_usepackage/][here]] for instructions on how to load local files with =use-package= (so that they can be deferred, of course).
- [[https://github.com/positron-solutions/transient-showcase][transient showcase]]
- Some interesting stuff here: https://github.com/daviwil/emacs-from-scratch

* Basic settings
** Early loading

Some of these settings were taken from the [[https://github.com/hrs/sensible-defaults.el][sensible-defaults]] package.

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
(use-package emacs
  :config
  ;; reduce the frequency of garbage collection by making it happen on
  ;; each 50MB of allocated data (the default is on every 0.76MB)
  (setq gc-cons-threshold (* 50 1000 1000))
  ;; warn when opening files bigger than 50MB
  (setq large-file-warning-threshold (* 50 1000 1000))
  ;; do not create backups
  (setq make-backup-files nil)
  ;; use regular spacing with sentences.
  ;; this is important because it directly impacts sentence motions.
  (setq sentence-end-double-space nil)
  ;; do not pollute this file with custom variables
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
  ;; disable unnecessary warnings
  (setq warning-minimum-level :emergency)
  ;; don't beep or flash, display a message instead
  (setq ring-bell-function (lambda () (message "Oops!")))
  ;; do not make me type out 'yes' in full every time
  (fset 'yes-or-no-p 'y-or-n-p)
  ;; do not use tabs for indentation
  (setq-default indent-tabs-mode nil)
  ;; scrolling settings
  (setq scroll-conservatively 0
        scroll-preserve-screen-position 1))
#+end_src

** Package management

I turn on the profiler, so that I can see which packages
take the longest amount of time to load
(with the =use-package-report= command)
and see if their loading can be deferred.

#+begin_src emacs-lisp
(setq use-package-compute-statistics t)
#+end_src
See also =use-package-defaults= for other settings.

Because I am using Elpaca, this is no longer needed:
#+begin_src elisp :tangle no
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+end_src

Load =f= early to make sure it's available to other packages (required with Elpaca's async).
#+begin_src emacs-lisp
(use-package f
  :ensure (:wait t))
#+end_src

** In-built packages

Packages that form part of Emacs live here.

Some in-built packages are very useful, but not needed at startup. They may also lack handy trigger functions to bind them to. I defer the loading of these packages with idle timers as suggested [[https://blog.d46.us/advanced-emacs-startup/][here]].

*** Save place mode

Save place mode, as may be guessed from its name, saves the cursor position in files you visit. It's nice to open a file in Emacs and immediately see where you left off last time.

I prefer not to defer save-place-mode. Waiting a couple of seconds after startup to ensure it loads seems counterproductive to me, if it adds a few centiseconds to startup time at best. When trying it with defers, I found that I was often too quick to open a file, and save-place-mode hadn't started yet.

#+begin_src emacs-lisp
(use-package saveplace
  :init
  (setq save-place-forget-unreadable-files nil
        save-place-file (file-name-concat user-emacs-directory "tmp/places"))
  (save-place-mode 1))
#+end_src

*** Savehist mode

Savehist mode might be confused with save-place mode, but they do very different things. Savehist mode keeps track of *minibuffer* history, so that (for example) recently used =M-x= commands are shown on top.

#+begin_src emacs-lisp
(use-package savehist
  :init
  (setq savehist-file (file-name-concat user-emacs-directory "tmp/history"))
  (savehist-mode 1))
#+end_src

*** Tramp

#+begin_src emacs-lisp
(use-package tramp
  :defer 2
  :config
  (setq tramp-persistency-file-name
        (file-name-concat user-emacs-directory "tmp/tramp")))
#+end_src

*** Recentf

The 'f' in recentf stands for 'file'. I tend to open lots of different files from lots of different directories, and most of them are org-mode files rather than programming projects. Most of the time whenever I need to open a file, the first thing I do is try =recentf= (with [[id:53556f3d-c05c-4d6f-a9ae-3a59785b03e3][incremental narrowing and completion]]). Usually I only need to type a few disconnected syllables to filter out the file I need.

#+begin_src emacs-lisp
(use-package recentf
  :init
  (setq recentf-max-saved-items 1000
        recentf-max-menu-items 1000
        recentf-save-file (file-name-concat user-emacs-directory "tmp/recentf"))
  (recentf-mode 1))
#+end_src

*** Bookmarks

#+begin_src emacs-lisp
(use-package bookmark
  :config
  (setq bookmark-default-file (file-name-concat user-emacs-directory "tmp/bookmarks")))
#+end_src

** Vars

I use the same Emacs config on three machines at the moment. Most things do not need to change, but a few file locations differ from system to system. I set these here.

#+begin_src emacs-lisp
(pcase (system-name)
  ;; Laptop
  ("iwaka-thinkpad"
   (setq +org-directory "~/org"
         +default-bibliography "~/files/academic/bib/bibliography.bib"
         +ebib-file-search-dir "~/files/syncthing/papers/ebib"
         +ebib-import-directory "~/files/syncthing/papers/papers/articles"
         +fontsize 200))

  ;; Office PC
  ("goderich-ncue"
   (setq +org-directory "~/org"
         +default-bibliography "~/files/academic/bib/bibliography.bib"
         +ebib-file-search-dir "~/files/papers/ebib"
         +ebib-import-directory "~/files/papers/papers/articles"
         +fontsize 180))

  ;; Tablet
  ("goderich-surface"
   (setq +org-directory "~/org"
         +default-bibliography "~/academic/bib/bibliography.bib"
         +ebib-file-search-dir "~/papers/ebib"
         +ebib-import-directory "~/papers/papers/articles"
         +fontsize 180)))
#+end_src

** Theming

As has been a longstanding tradition of Emacs tutorials since time immemorial, the first thing users are recommended to put into their config is the code to turn off all menus. Since I came to Emacs from vim, that has never been an issue with me. I never would have used them anyway.

Unlike vimmers (and a lot of Emacs users who had been clamoring for the functionality), I prefer *not* to display line numbers in the fringe. I can still go to specific lines by number, and I still see the current line number in my mode line in case I ever need it (which is never). When editing existing text, I use semantic operations like paragraphs, sentences, or parenthetic blocks. I haven't regretted turning line numbers off, and I don't miss them at all.

#+begin_src elisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(display-line-numbers-mode -1)
(tooltip-mode -1)

;; Soft wrap long lines
(global-visual-line-mode 1)

;; Maintain a small margin when scrolling
(setq scroll-margin 2)
#+end_src

Dark themes are all the rage with Linux hackers, but I usually work during the day, when a light theme makes text more readable. With Doom, I used =doom-solarized-light= most of the time, and its palette is gorgeous. I considered using the [[https://github.com/doomemacs/themes][doom themes]] package, but it's a little too large for my taste. Bozhidar Batsov's [[https://github.com/bbatsov/solarized-emacs][solarized themes]] package, while no bantamweight itself, provides a reasonable alternative.

Having said that, I found myself missing a few of the colours in Doom's version of solarized light, so I set them here. For some other settings I prefer bbatsov's way, or even my own tweaks.

#+begin_src emacs-lisp
(use-package solarized-theme
  :ensure (:wait t)
  :init
  (setq solarized-scale-org-headlines nil)
  (load-theme 'solarized-light t)

  :config
  (face-spec-set 'default
                 '((t :background "#fdf6e3")))
  ;; org headlines
  (face-spec-set 'org-done
                 '((t :foreground "gray"
                      :weight bold)))
  (face-spec-set 'org-headline-done
                 '((t :foreground "gray")))
  (face-spec-set 'org-todo
                 '((t :foreground "#859900")))
  (face-spec-set 'font-lock-builtin-face
                 '((t :foreground "#d33682"
                      :weight normal)))
  (face-spec-set 'org-level-1 '((t :foreground "#268bd2")))
  (face-spec-set 'org-level-2 '((t :foreground "#d33682")))
  (face-spec-set 'org-level-3 '((t :foreground "#6c71c4")))
  (face-spec-set 'org-level-4 '((t :foreground "#5ca8dd")))
  (face-spec-set 'org-level-5 '((t :foreground "#de68a1")))
  (face-spec-set 'org-level-6 '((t :foreground "#92c4e8")))
  (face-spec-set 'org-level-7 '((t :foreground "#e99ac0")))
  (face-spec-set 'org-level-8 '((t :foreground "#d3e7f6")))
  (face-spec-set 'org-table   '((t :foreground "#6c71c4")))
  (face-spec-set 'org-cite    '((t :foreground "#b58900")))
  ;; org src blocks
  (face-spec-set 'org-block
                 '((t :background "#faf1d9"
                      :extend t)))
  (face-spec-set 'org-meta-line
                 '((t :background "#faf1d9"
                      :slant normal
                      :extend t)))
  ;; org cite
  (face-spec-set 'org-cite
                 '((t :foreground unspecified
                      :inherit link)))
  (face-spec-set 'org-macro
                 `((t :inherit fixed-pitch
                      :height ,+fontsize)))
  ;; org checkbox
  (face-spec-set 'org-checkbox
                 '((t :box unspecified)))
  ;; org agenda
  (face-spec-set 'org-agenda-date
                 '((t :foreground unspecified
                      :weight bold)))
  (face-spec-set 'org-scheduled-previously
                 '((t :foreground unspecified)))
  (face-spec-set 'org-agenda-done
                 '((t :slant normal)))
  (face-spec-set 'link
                 '((t :foreground "#268bd2"
                      :weight bold
                      :underline t)))
  (face-spec-set 'org-agenda-date-weekend
                 '((t :foreground unspecified
                      :underline unspecified)))
  ;; info
  (face-spec-set 'Info-quoted
                 '((t :inherit font-lock-keyword-face)))
  (face-spec-set 'Info-code-block
                 '((t :inherit default
                      :inherit org-block)))

  (defvar +info-code-regexp
    (rx (seq "\n\n"
             (group (>= 4 " ") (or "(" "-" ";" "|") (+? anychar) "\n")
             "\n")))

  (defun +info-add-fn-font-lock ()
    (interactive)
    (font-lock-add-keywords
     nil
     `(;; (rx (seq line-start " -- " (group (+ (or alpha space)) ":") (group (+ not-newline))))
       ("^ -- \\(\\(?:[[:alpha:]]\\|[[:space:]]\\)+:\\)\\(.+\\)"
        (1 'default t)
        (2 'Info-quoted))
       (,+info-code-regexp
        (1 'Info-code-block t)))))

  (add-hook 'Info-mode-hook #'+info-add-fn-font-lock))
#+end_src

** Fonts

Font configuration in Emacs is a little complicated, and tied to theming as well. I try to keep it relatively simple, but I also like my Emacs to look nice.

Since I spend so much time in org-mode, and a lot of it writing prose, it makes sense for me to configure variable width fonts in addition to monospace ones for programming. I use [[https://gitlab.com/jabranham/mixed-pitch][mixed-pitch]] mode to have both types of fonts in a single buffer. Some of the ideas for font configuration came from [[https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/#h:c7528f3d-9fc8-49e5-9468-6868fb5c07b5][Prot's tutorial]], although I looked at various other configs as well. That =mixed-pitch-set-height= setting is super important: without it, you can't adjust the relative height of monospace and variable width fonts in mixed-pitch buffers.

#+begin_src emacs-lisp
(use-package mixed-pitch
  :ensure t
  :hook ((text-mode . mixed-pitch-mode)
         (Info-mode . mixed-pitch-mode))
  :config
  (setq mixed-pitch-set-height t))
#+end_src

Next are the fonts themselves. [[https://github.com/be5invis/Iosevka][Iosevka]] gets mentioned a lot as a popular monospace font, but I don't like it much (too thin). The monospace fonts I do like are (see also [[https://coding-fonts.pages.dev/fonts/input/?language=js][here]]):
- Cascadia Code (round and funky, a bit on the thick side)
- Fantasque Sans Mono (like Cascadia, but thinner and a more handwritten style)
- Input (a bit like Cascadia, but thinner and more square)
- Source Code Pro (nice and round, if a little boring)
- Fira Code (similar to Source Code Pro, could try when I want something more mainstream)
- [[https://pcaro.es/hermit/][Hermit]] (a little of an old-school 8-bit quality to it, but modernized)
- [[https://www.dafont.com/lotion.font][Lotion]] (funky and slightly cartoonish)

With variable width fonts, it's not always just a matter of liking a typeface, but also it being compatible with the things I type. E.g. I like [[https://edwardtufte.github.io/et-book/][ET Book]] quite a lot, but unfortunately it has minimal support for non-ASCII characters, which is less than ideal, because I type those a bunch. A few other variable width fonts I like are (also see [[https://wiki.archlinux.org/title/Fonts][here]]):
- Crimson Pro
- Gentium family (has all of the IPA, but the line spacing is too big in Emacs)
- Libertinus

#+begin_src emacs-lisp
(let ((monospace-font "Cascadia Code")
      (variable-font "Crimson Pro"))
  (set-face-attribute 'default nil
                      :family monospace-font
                      :height +fontsize)
  (set-face-attribute 'fixed-pitch nil
                      :family monospace-font
                      :height 1.0)
  (set-face-attribute 'variable-pitch nil
                      :family variable-font
                      :height 1.3))
(set-fontset-font t nil (font-spec :height 1.2 :name "Gentium Plus"))
#+end_src

For CJK fonts specifically, check [[https://www.shimmy1996.com/en/posts/2018-06-24-fun-with-fonts-in-emacs/][this]], or [[https://www.reddit.com/r/emacs/comments/8tz1r0/how_to_set_font_according_to_languages_that_i/e1bjce6/][this snippet]].
[[https://github.com/be5invis/Sarasa-Gothic][Sarasa]] is a CJK font affiliated with Iosevka.
Also [[https://coldnew.github.io/d5011be2/][this article]] deals with CJK alignment in org tables. However, I already have valign-mode, so that might be moot.

** Dashboard

The default Emacs startup screen isn't particularly useful. It's rendered even less so by the fact that Boon does not turn on there, since it isn't an editing mode. Of course, there's an Emacs package for just that.

#+begin_src emacs-lisp
(use-package dashboard
  :ensure t
  :bind
  (:map dashboard-mode-map
        ("u" . 'dashboard-previous-line)
        ("e" . 'dashboard-next-line)
        ("o" . '+open-org-dir)
        ("c" . '+open-config)
        ("a" . 'org-agenda-list))
  :config
  (dashboard-setup-startup-hook)
  (setq dashboard-startup-banner (file-name-concat user-emacs-directory "img/emacs-e.svg"))
  (setq dashboard-center-content t)
  (setq dashboard-items '((recents . 5)))
  (setq dashboard-recentf-show-base 'align)
  (setq dashboard-recentf-item-format "%s %.45s"))
#+end_src

I prefer to just have recently opened files there for now. Because some of my file paths are too deeply nested, I prefer to show the base name first, followed by 45 chars of the full path. This way I don't get wonky formatting due to overflowing lines.

** Modeline

 Currently using [[https://gitlab.com/jessieh/mood-line][mood-line]] (see [[https://www.reddit.com/r/emacs/comments/c5mel4/what_mode_line_do_you_use_and_why/][here]] for more great packages.)

#+begin_src emacs-lisp
(use-package mood-line
  :ensure t
  :config
  ;; can't use unicode glyphs with my current font
  (setq mood-line-glyph-alist mood-line-glyphs-fira-code)
  (mood-line-mode)

  (setq mood-line-format
        (mood-line-defformat
         :left
         (((+boon-state-string) . " ")
          ((or (mood-line-segment-buffer-status) " ") . " ")
          ((mood-line-segment-buffer-name) . " ")
          ((mood-line-segment-anzu) . " ")
          ((mood-line-segment-cursor-position) . " ")
          ((+count-selected-lines) . " ")
          ((mood-line-segment-scroll) . " "))
         :right
         (((mood-line-segment-vc) . "  ")
          ((mood-line-segment-major-mode) . "  ")
          ((mood-line-segment-misc-info) . "  ")
          ((mood-line-segment-checker) . "  ")
          ((mood-line-segment-process) . "  "))))

  (defun +count-selected-lines ()
    (when (region-active-p)
      (let ((numlines
             (1+
              (- (line-number-at-pos (region-end))
                 (line-number-at-pos (region-beginning))))))
        (format #("-%d-" 0 4 (face mood-line-status-error))
                numlines))))

  (defun +boon-state-string ()
    "Return a string describing the current state."
    (cond
     (boon-command-state "<C>")
     (boon-insert-state  (propertize "<I>" 'face '(:foreground "indian red")))
     (boon-special-state (propertize "<S>" 'face '(:foreground "dodger blue")))
     (t "???"))))
#+end_src

* Boon

[[https://github.com/jyp/boon][Boon]] is a fantastic modal editing package for Emacs. It's tiny, but packs a ton of functionality.

I like boon's idea of ergonomics before mnemonics---basically, for the most common commands, it doesn't matter what's on the keycap, what matters is where it is on the keyboard. I feel this deeply, having used Dvorak for a number of years before switching to Colemak.

While I'm still getting used to boon, here are reminders for things that I used with evil but no longer have access to, and what I should replace them with.
- Look into [[https://www.emacswiki.org/emacs/KeyboardMacros][Emacs macros]] to replace vim =q=
- Look into [[info:emacs#Replace][replacement commands]] instead of vim =:=
- [[info:emacs#Mark Ring][Marks]] (pop/unpop) and [[info:emacs#Position Registers][registers]] for movements similar to =gi=
- Smartparens instead of evil-surround

Specific changes to keybindings are explained further below.

#+begin_src emacs-lisp
(use-package boon
  :ensure t
  :init
  (require 'boon-colemak)
  (boon-mode)
  :bind
  (:map boon-moves-map
        ("e" . #'next-line)
        ("E" . #'forward-paragraph)
        ("l" . #'boon-smarter-backward)
        ("L" . #'backward-sentence)
        ("m" . #'crux-move-beginning-of-line)
        ("M" . #'beginning-of-visual-line)
        ("n" . #'backward-char)
        ("N" . #'boon-smarter-upward)
        ("o" . #'end-of-line)
        ("O" . #'end-of-visual-line)
        ("y" . #'boon-smarter-forward)
        ("Y" . #'forward-sentence)
        ("(" . #'+boon-find-char-backward)
        (")" . #'+boon-find-char-forward)
        ("^" . #'beginning-of-line)
   :map boon-command-map
        ("d" . #'boon-set-insert-like-state)
        ("D" . #'boon-open-next-line-and-insert)
        ("C-d" . #'boon-open-line-and-insert)
        ;; ("f") forward search transient
        ("g" . #'+goto-transient)
        ("h" . #'avy-goto-word-1)
        ("H" . #'avy-goto-char-timer)
        ("j" . #'crux-top-join-line)
        ("J" . #'join-line)
        ("p" . #'boon-splice)
        ("s" . #'boon-treasure-region)
        ("v" . #'boon-replace-by-character)
        ;; ("w") backward search transient
        (";" . nil)
        ("/" . #'consult-line)
        ("-" . #'undo-fu-only-undo)
        ("_" . #'undo-fu-only-redo)
        ("<return>" . nil) ; fall through
   :map boon-insert-map
        ("<escape>" . #'+boon-command-state-maybe)
        ("C-t" . #'ignore)
        ("C-n" . #'ignore)
        ("C-e" . #'ignore)
        ("C-w" . #'backward-kill-word)
   :map boon-special-map
        ("<escape>" . #'ignore)
   :map boon-x-map
        ("a" . #'org-agenda-list)
        ("f" . #'+file-transient)
        ("h" . #'+helpful-transient)
        ("k" . #'kill-current-buffer)
        ("l" . #'link-hint-open-link)
        ("m" . #'magit)
        ("n" . #'+narrow-dwim)
        ("p" . #'pandoc-transient)
        ("s" . #'save-buffer)
        ("y" . #'+yt-dlp-link)
        (";" . #'comment-line)
        ("." . #'find-file)
        ("," . #'consult-buffer))
  :config
  (remove-hook 'minibuffer-setup-hook #'boon-minibuf-hook)
  (remove-hook 'window-selection-change-functions #'boon-reset-state-for-switchw)

  (setq boon-default-cursor-type 'box)
  (blink-cursor-mode -1)

  (defun +boon-find-char-backward (char)
    "Find the previous occurrence of CHAR, not including the char at point."
    (interactive "cType the character to find")
    (backward-char 1)
    (let ((case-fold-search nil))
      (search-backward (make-string 1 char))))

  (defun +boon-find-char-forward (char)
    "Find the next occurrence of CHAR, not including the char at point."
    (interactive "cType the character to find")
    (forward-char 1)
    (let ((case-fold-search nil))
      (search-forward (make-string 1 char)))
    (backward-char 1))

  (defun +boon-command-state-maybe ()
    (interactive)
    (cond
     ((and corfu-mode completion-in-region-mode) (corfu-quit))
     ((bound-and-true-p tempel--active) (tempel-done))
     (t (boon-set-command-state))))

  (dolist (mode '(ebib-index-mode ebib-entry-mode Info-mode))
    (add-to-list 'boon-special-mode-list mode)))
#+end_src

I do not have Tab bindings collected in any single specific place, but this bears stating somewhere. Here is as good a place as any. I have the following functionality on my Tab key:
- expand a snippet if one is available, but *only* in insert state,
- act as org-cycle in org mode, in both normal and insert states,
- act as indent key in programming modes in both normal and insert states.

** Boon command state

Boon's command mode is actually composed of two keymaps: =boon-moves-map= and =boon-command-map= (plus a few special keys that act like transients). A division of labour between the two hands is baked into boon's design: the right hand keys mainly concern movements, while the left hand keys call various commands. (Recall that I am using the Colemak layout.)

Instead of trying to keep my fingers on the home row as much as possible, I use both the top row and the home row for the most common movements. I have the following modifications:
- I prefer having a WASD-like pyramid for up, left, down, and right, respectively, but it's on my right hand instead (UNEI on Colemak).
- I put the =boon-smarter-backward= and =boon-smarter-forward= commands next to the "up" key on the top row (=l= and =y=). In prose, these function like word movements. In code, they move by sexps. So far I'm happy with how they work. I use these more than line movements, so I like them to be more reachable.
- Because the above keys are undefined in uppercase, I bind =L= and =Y= to sentence movements, which in prose are very useful.
- The line movements go to the left of "left" and to the right of "right". On Colemak DH Matrix, that's =m= and =o=. I also bind visual line movements on =M= and =O=, mostly for prose.
- If I'm on a heavily indented line and want to move to the point to the first char, boon doesn't seem to have a convenient function out of the box for this eventuality. Usually that's where I want to go though. So my =m= key is actually bound to =crux-move-beginning-of-line=. If I need to go to the first column, I just press it again. In case I ever need to move directly to the first column (say, when recording a macro), I bound it to =^=: this time a mnemonic of sorts, for the regex symbol.
- Because Colemak DH Matrix mod swaps the "M" and "H" keys, I can still keep avy searches on "H", which is right below my "N" (= left) key. These are set in =boon-command-map=.
- I like the idea of using =(= and =)= for single character searches. With my [[https://docs.qmk.fm/features/space_cadet][Space Cadet Shift]], they are very conveniently positioned. My only gripe with boon's functions is that if you search for X (for any given value of X) and your point is already on X, boon will just say, "Hey, look, there's one right where I'm standing!" and not move the point. Thanks boon, but I was looking for the *next* occurrence. Also, I want these searches to always be case sensitive. I modified these functions accordingly.

Next is my =boon-command-map=:
- Because I'm using the Colemak DH mod instead of regular Colemak, my "D" key is where "V" is in [[https://github.com/jyp/boon/blob/master/colemak.pdf][the original layout]], and my "V" is in a very awkward position. Not ideal for a very common operation. I swap the two keys.
- Avy commands on "H" work great, I'm just not yet 100% sure which ones. Still experimenting.
- Love the =goto-map= on =g=, but I map it to [[id:81219cda-4249-480d-959f-2d44edf1a589][something a little more flexible]] ([[#goto-transient][browser link]]). The trouble with using a map is that it's a lot more work to adjust it to specific modes. It can still be done, but using a transient makes it a lot easier to adjust to various modes.
- The original layout uses =j= for =xref-find-definitions= and =J= for =xref-find-references=. Which okay, but I include them in my =+goto-transient=, so I can use the "J" key for something else. I put line joining functions on it, because that's what it does in vim/evil, and I actually use those quite a lot! Lowercase =j= joins the following line to the end of the current one like in vim, and uppercase =J= joins the current line to the end of the preceding one.
- The =occur= binding on =p= doesn't make much sense to me, and I have other functions for searching, such as =consult-line=. On the other hand, copying on a shifted key is not ideal. Put copying on =s= instead (mnemonic: save), and moved pasting to =p= (mnemonic: duh!).
- I use [[id:53828884-e258-4f2b-b8e0-46c5cf9926ea][undo-fu]] for linear undo, and bind both undo and redo here.
- The original layout uses =/= for =qsearch-at-point=, but that's already bound in =boon-forward-search-map=, so instead I bind it to my preferred line search using [[https://github.com/minad/consult][consult]].
- I bind Enter to =nil= (instead of the default =undefined=) so that it can fall through to other modes' bindings. E.g., I bind Enter in org-mode, so it needs to be =nil= in boon in order for my org binding to work.

** Boon insert state

I only change a couple of things in insert mode:
- When I'm in insert mode and a [[id:2ca8bb84-790f-4e68-8d3d-4893ef154e43][completion]] overlay or a template input is active, I want ESC to quit completion or templating *while keeping me in insert mode*. In my evil config, I used a wrapper function, which I replicated with boon.
- I prefer to have =C-w= as a kill word binding. By default it runs =kill-region=, which can delete swathes of text.

** Boon special state

Special map is essentially when boon isn't active. Modes like magit, org agenda, or dired use this state by default, and I add a few more here. However, I *do not* want boon to switch to command mode on Escape, because I press it habitually.

* Minibuffer keybindings

Keybindings in the minibuffer have to be set differently.
Boon is not active in the minibuffer, and the bindings
have to be set up using a hook each time.

I went through this trouble to replicate Doom's behaviour
when pressing backspace in the minibuffer.
It works as normal when typing the name of a file,
but if you keep deleting, the parent directories will be deleted
with a single press of backspace.
This is pretty convenient when jumping upwards many levels.

Right now my implementation is relatively naive,
but it does the job well enough.

#+begin_src emacs-lisp
(defun +delete-char-or-directory ()
  (interactive)
  (cond
   ((string= (minibuffer-contents) "/")
    (delete-backward-char 1))
   ((string= (minibuffer-contents) "~/")
    (delete-minibuffer-contents)
    (insert (expand-file-name "~/")))
   ((eq (char-before) ?/)
    (let ((pt (point))
          (slash-pos (search-backward "/" nil t 2)))
      (if slash-pos
          (progn
            (delete-region (1+ slash-pos) pt)
            (move-end-of-line nil))
        (delete-backward-char 1))))
   (t (delete-backward-char 1))))

(defun +minibuffer-setup ()
  (keymap-set minibuffer-local-map "<backspace>" #'+delete-char-or-directory)
  (keymap-set minibuffer-local-map "C-w" #'backward-kill-word)
  (keymap-set minibuffer-local-map "C-<return>" #'vertico-exit-input)
  (keymap-set minibuffer-local-map "<escape>" #'keyboard-escape-quit)
  (setq-local cursor-type 'box))

(add-hook 'minibuffer-setup-hook #'+minibuffer-setup)
#+end_src

* Transient commands
:PROPERTIES:
:ID:       1d67b9e6-b143-425a-8dec-d124f95eedc4
:END:

Transients are an amazing feature of Emacs, and really handy for people who like to over-personalize their configs. They don't immediately run a command, but instead pop up a menu where you can choose further actions, or enter a transitory state so that you can mash one key to, e.g. increase the font size or text width. I prefer using transients to mapping every function individually, because transients are a lot easier to remap, and their functionality is strictly more powerful. Since Emacs 28, the transient package has been included in Emacs itself.

#+begin_src emacs-lisp
(use-package transient
  :ensure (:wait t))
#+end_src

Right now, all my transient menus live here. Since many of my packages are deferred, it's simpler to define the transients outside their =use-package= calls. The packages then get loaded when I call their respective transients.

** Goto transient
:PROPERTIES:
:ID:       81219cda-4249-480d-959f-2d44edf1a589
:END:

Transient for various movement commands, from jumping to a line visible on the screen, all the way to searches within the buffer and even outside. I bind it to the =g= key in boon.

This transient's behaviour changes depending on the mode it's in, with special functions for org and programming modes.

#+begin_src emacs-lisp
(transient-define-prefix +goto-transient ()
  ["Go to..."
   [("g" "line" avy-goto-line)]
   [:if-derived org-mode
    ("h" "find heading" +consult-goto-org-heading)
    ("u" "prev heading" +org-up-heading)]
   [:if-derived prog-mode
    ("d" "definition" xref-find-definitions)
    ("r" "references" xref-find-references)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Narrowing transient

Narrowing here is in the Emacs sense of only keeping part of the buffer visible. If I have a selection, the =+narrow-dwim= function narrows to it straight away, otherwise the transient is called. Widening is also available in the transient.

#+begin_src emacs-lisp
(defun +narrow-dwim ()
  (interactive)
  (if (and (region-active-p) (not (buffer-narrowed-p)))
      (narrow-to-region (region-beginning) (region-end))
    (+narrowing-transient)))

(transient-define-prefix +narrowing-transient ()
  ["Narrow to..."
   [""
    ("p" "page" narrow-to-page)
    ("d" "defun" narrow-to-defun)]
   ["Org"
    :if-derived org-mode
    ("t" "subtree" org-narrow-to-subtree)
    ("e" "element" org-narrow-to-element)
    ("b" "block" org-narrow-to-block)]
   [""
    ("w" "widen" widen)]
   [""
    ("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Window resizing transient

#+begin_src emacs-lisp
(transient-define-prefix +window-transient ()
  ["Resizing windows"
   ["Transient"
    ("b" "bigger" enlarge-window :transient t)
    ("s" "smaller" shrink-window :transient t)
    ("=" "balance" balance-windows :transient t)]
   ["Non-transient"
    ("d" "delete" delete-window)
    ("w" "other" other-window)
    ("m" "maximize" delete-other-windows)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** File transient

#+begin_src emacs-lisp
(transient-define-prefix +file-transient ()
  ["File commands"
   ["With this file..."
    ("s" "save" save-buffer)
    ("D" "delete" crux-delete-file-and-buffer)
    ("R" "rename" crux-rename-file-and-buffer)
    ("u" "sudo edit" crux-sudo-edit)]
   ["Open..."
    ("r" "recent file" recentf)
    ("o" "org directory" +open-org-dir)
    ("c" "config.org" +open-config)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])

(defun +open-config ()
  (interactive)
  (find-file "~/.emacs.d/config.org"))

(defun +open-org-dir ()
  (interactive)
  (ido-find-file-in-dir "~/org/"))
#+end_src

** Buffer transient

#+begin_src emacs-lisp
(transient-define-prefix +buffer-transient ()
  ["Buffer commands"
   [("b" "open" consult-buffer)
    ("s" "save" save-buffer)
    ("u" "sudo edit" crux-sudo-edit)]
   [("d" "quit" kill-current-buffer)
    ("q" "quit" kill-current-buffer)]
   [("<escape>" "quit" transient-quit-all)]])
#+end_src

** Helpful transient

#+begin_src emacs-lisp
(transient-define-prefix +helpful-transient ()
  ["Emacs help"
   ["Helpful mode"
    ("f" "functions and macros" helpful-callable)
    ("v" "variables" helpful-variable)
    ("k" "key" helpful-key)
    ("c" "interactive functions" helpful-command)
    ("p" "thing at point" helpful-at-point)]
   ["In-built help"
    ("m" "describe mode" describe-mode)
    ("F" "describe face" describe-face)
    ("i" "info" info)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Olivetti transient

I use olivetti with org a lot, and when I do, I prefer to keep my text relatively narrow. That does not play well with =org-indent-mode=, so I keep the two separate with this transient that takes care of disabling and enabling =org-indent-mode= when called.

#+begin_src emacs-lisp
(defun +turn-off-olivetti-mode ()
  (interactive)
  (olivetti-mode -1)
  (when (derived-mode-p 'org-mode)
    (org-indent-mode +1)))

(transient-define-prefix +olivetti-transient ()
  ["Change text column width..."
   [("w" "wider" olivetti-expand :transient t)
    ("n" "narrower" olivetti-shrink :transient t)]
   [("f" "turn off olivetti" +turn-off-olivetti-mode)
    ("q" "quit" transient-quit-all)]]
  (interactive)
  (olivetti-mode +1)
  (when (derived-mode-p 'org-mode)
    (org-indent-mode -1))
  (transient-setup '+olivetti-transient))
#+end_src

** Org navigation transient

Instead of pressing key combinations or chords repeatedly to navigate, we can define a transient state and use simple keys while in it. I got the idea from [[https://github.com/Somelauw/evil-org-mode/blob/master/doc/example_config.el][this evil-org example]] that uses hydra, but I'm using transient because I'm more used to it, and because it's now built into Emacs (as of 28).

#+begin_src emacs-lisp :tangle no :noweb-ref org-navigation-transient
(defun +scroll-line-to-top ()
  ;; Taken from `evil-scroll-line-to-top'
  (interactive)
  (recenter (1- (max 1 scroll-margin))))

(defmacro with-org-show (&rest body)
  `(progn
     ,@body
     (+scroll-line-to-top)
     (org-fold-show-entry)
     (org-fold-show-children)))

;; This is not in the transient, move out
(defun +org-up-heading ()
  "Go up to the nearest heading, or to a higher level heading.
If not on a heading, finds the next heading backwards.
If already on a heading, goes higher up in the tree. This
makes sense to me to combine into a single keybinding."
  (interactive)
  (if (org-at-heading-p)
      (with-org-show
       (org-previous-visible-heading 1))
    (org-back-to-heading)))

(defun +org-up-level-and-show ()
  (interactive)
  (cond
   ((not (org-at-heading-p)) (org-back-to-heading))
   ((= 1 (org-current-level)) (ignore))
   (t (org-up-element))))

(defun +org-down-and-show ()
  (interactive)
  (when (org-at-heading-p)
    (with-org-show
     (org-next-visible-heading 1))))

(defun +org-up-same-level ()
  (interactive)
  (with-org-show
   (org-fold-hide-subtree)
   (org-backward-heading-same-level 1 t)))

(defun +org-down-same-level ()
  (interactive)
  (with-org-show
   (org-fold-hide-subtree)
   (org-forward-heading-same-level 1 t)))

;; add link-hint on u?
(transient-define-prefix +org-movement-transient ()
  ["Moving around in org"
   [("n" "up level" +org-up-level-and-show :transient t)
    ("u" "up (same level)" +org-up-heading :transient t)
    ("e" "down (same level)" +org-down-same-level :transient t)
    ("i" "down level" +org-down-and-show :transient t)]
   [("<tab>" "cycle" org-cycle :transient t)
    ("<backtab>" "cycle all" org-shifttab :transient t)
    ("<SPC>" "scroll down" scroll-up :transient t)]
   [("q" "quit" transient-quit-all)]])
#+end_src

* Narrowing and completion
** Narrowing
:PROPERTIES:
:ID:       53556f3d-c05c-4d6f-a9ae-3a59785b03e3
:END:

Here I mean incremental narrowing of searches in the minibuffer, and not the kind where Emacs [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Narrowing.html][hides part of the buffer temporarily]].

TODO: There is a lot of functionality here, I should explore it.
https://github.com/minad/consult
#+begin_src emacs-lisp
(use-package consult
  :ensure (:wait t))

(use-package vertico
  :ensure t
  ;; :custom
  ;; (vertico-scroll-margin 0) ;; Different scroll margin
  ;; (vertico-count 20) ;; Show more candidates
  ;; (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
  ;; (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
  :init (vertico-mode))

(use-package orderless
  :ensure t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles partial-completion)))))

;; Documentation in M-x and minibuffers
(use-package marginalia
  :ensure t
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  ;; :bind (:map minibuffer-local-map
  ;;        ("M-A" . marginalia-cycle))

  :init (marginalia-mode))

;; Do not delay which-key (delay has to be above zero)
(use-package which-key
  :ensure t
  :init (which-key-mode)
  :config
  (setq which-key-idle-delay 1)
  (setq which-key-idle-secondary-delay 0.05))
#+end_src

There is also https://github.com/oantolin/embark/,
but I haven't learned how to use it properly.

** Completion (Corfu)
:PROPERTIES:
:ID:       2ca8bb84-790f-4e68-8d3d-4893ef154e43
:END:

Using [[https://github.com/minad/corfu][Corfu]].

I do NOT normally want completion on in org, because that's distracting. I do want completion when programming, and I want it to open up automatically.

I'm using SPC as separator: pressing space does not exit completion, but instead begins a second chunk. This makes corfu work a lot like consult et al, where a search string can be entered using space-separated pieces.

#+begin_src emacs-lisp
(use-package corfu
  :ensure t
  :hook ((prog-mode . corfu-mode))
  :custom
  (corfu-auto t)
  (corfu-quit-no-match t)
  :bind (:map corfu-map
         ("TAB" . corfu-expand)
         ("SPC" . corfu-insert-separator)))
#+end_src

* Org-mode

(NB. Sacha Chua also has an [[https://sachachua.com/blog/2024/01/using-consult-and-org-ql-to-search-my-org-mode-agenda-files-and-sort-the-results-to-prioritize-heading-matches/][interesting use]] of org-ql.)

Note that since I am using a literate config
and loading it with org-babel from my =init.el=,
I cannot defer loading org-mode at startup.
It's not a huge penalty though,
and I feel the convenience outweighs it.

#+begin_src emacs-lisp :noweb yes
(use-package org
  :init <<org-init>>
  :hook <<org-hooks>>
  :bind
  (:map org-mode-map
         ;; insert mode bindings
        ([remap boon-open-line-and-insert] . #'+org-open-above)
        ([remap boon-open-next-line-and-insert] . #'+org-open-below)
        ("<return>" . +org-return)
        ("C-<return>" . +org-insert-item)
        ("C-c c" . ebib-insert-citation)
        ("C-c l" . #'+link-transient)
        ("C-c r" . +ref-transient)
        ;; org movement
        ("M-n" . org-metaleft)
        ("M-e" . org-metadown)
        ("M-u" . org-metaup)
        ("M-i" . org-metaright)
        ("M-N" . org-shiftmetaleft)
        ("M-E" . org-shiftmetadown)
        ("M-U" . org-shiftmetaup)
        ("M-I" . org-shiftmetaright)
        ;; god mode bindings
        ("C-c C-l" . #'+link-transient)
        ("C-c C-p" . #'org-set-property)
        ("C-c C-S-q" . +org-remove-tags)
   :map org-src-mode-map
        ("C-c C-c" . #'org-edit-src-exit))
  :config
  <<org-settings>>
  <<org-src-settings>>
  <<org-functions>>
  <<org-agenda>>
  <<org-navigation-transient>>
  <<org-modules>>)
#+end_src

** Org settings

I like having indentation in my org files (but not when using olivetti). Right now I turn it on during startup.
#+begin_src emacs-lisp :tangle no :noweb-ref org-init
(setq org-startup-indented t)
#+end_src

By default, org right-adjusts tags to column 80. I'm used to them following the title, just in a less conspicuous face.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-tags-column 0)
#+end_src

One of the many things I liked about Doom was the TODO settings. Fast TODO selection was on by default, which I think is a great idea if you are using more keywords than just TODO and DONE.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-use-fast-todo-selection t)
#+end_src

A little breathing space between org headings is alright. One problem with keeping them too tight is that it can sometimes confuse Emacs faces (i.e. if there is a =*= on a line directly preceding a heading, everything after the asterisk with be boldfaced).
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-blank-before-new-entry
      '((heading . t)
        (plain-list-item . nil)))
#+end_src

However, when my headings are collapsed into a list, I don't want to see gaps.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-cycle-separator-lines 0)
#+end_src

By default, I want org to show me the ancestry of a node when I'm dropping to it from somewhere else.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(map-put! org-fold-show-context-detail 'default 'tree)
#+end_src

Using the newer org-fold API does not work with consult. It should have been [[https://github.com/oantolin/consult/commit/68c1c07a9bdea0b806b2762c5b17296de7b2eeb8][fixed in 2022]], but the problem persists on my machines. This is a workaround.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-fold-core-style 'overlays)
#+end_src

Here I set the org file associations, i.e. how org opens file links. I don't like reading PDFs inside Emacs. Dedicated readers are a lot faster and have better commands (although I do use Emacs to comment PDFs). With zathura, and probably other PDF readers too, it's possible to open a file on a particular page. Emacs will do this when the file link ends in, e.g. ".pdf::123", as defined in the regex below.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-file-apps
      `((auto-mode . emacs)
        (,(rx ".pdf::" (group (one-or-more digit)) string-end) . "zathura %s -P %1")
        (,(rx ".pdf" string-end) . "zathura %s")
        (directory . emacs)))
#+end_src

The URL opener has to be set separately (although it works everywhere, not just in org). There are a few in-built options, such as Firefox, but if you're using something less popular, like I am, you can still set it here.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "qutebrowser")
#+end_src

Show tooltips. I am using this for displaying org link paths when the pointer is on a link. This may not be the best use of this functionality, and I do have an alternative implementation.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq help-at-pt-display-when-idle t
      help-at-pt-timer-delay 0.1)
(help-at-pt-set-timer)
#+end_src

I use several additional TODO keywords of my own choosing. I got the idea from Doom, but changed the keywords themselves.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-todo-keywords
      '((sequence "TODO(t)" "|" "DONE(d)")
        (sequence "NEXT(n)" "WAITING(w)" "LATER(l)" "LOOP(p)" "|" "CANCELLED(c)")))
#+end_src

I saw the LOOP keyword somewhere in a blog post, I think, and though it was a great name for a constantly repeating task, which is how I'm using it here.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-todo-repeat-to-state "LOOP")
#+end_src

Another idea inspired by Doom's config (and my Doom config): new faces for custom TODO keywords. I don't need every face to have its own colour though, just something that tells me at a glance if I should be paying attention. (The =org-done= face is changed in my Theming settings to a grey colour.)
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(defface +org-todo-important
  '((t :inherit org-todo
       :foreground "#dc322f"))
  "For very important todo items.")

;; Colour taken from hl-todo.
(defface +org-todo-unimportant
  '((t :inherit org-todo
       :foreground "#d0bf8f"))
  "For less urgent todo items.")

(setq org-todo-keyword-faces
      '(("LATER"     +org-todo-unimportant)
        ("NEXT"      +org-todo-important)
        ("WAITING"   +org-todo-unimportant)
        ("LOOP"      +org-todo-unimportant)
        ("CANCELLED" org-done)))
#+end_src

I use the org archiving functionality often when I think there is the slightest possibility I will need the information later (if not, I just delete it). However, I don't need separate archives for each file, as is the default. I set it to a file with a relative path, but that's okay, because I only ever archive entries from my org-dir.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-archive-location ".archive.org::")
#+end_src

I rarely have to enter dates or times that have already passed, since my primary use of the date functionality is scheduling. This setting lets me input future dates and times with fewer keystrokes.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-read-date-prefer-future 'time)
#+end_src

This bit of witchcraft, [[https://github.com/doomemacs/doomemacs/blob/ba1dca322f9a07bc2b7bec6a98f2c3c55c0bbd77/modules/lang/org/config.el#L503-L517][extracted from Doom]] and simplified, colours a file link with a different colour (from the current theme's warning face) if Emacs can't find the file it refers to. Very simple idea, but brilliant in its simplicity, and wonderfully executed.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(org-link-set-parameters
 "file" :face (lambda (path)
                (if (file-exists-p path)
                    'org-link
                  '(warning org-link))))
#+end_src

** Org-src

I don't want to see any extra indentation in my source blocks, nor be asked questions about the safety of my own code.

#+begin_src emacs-lisp :tangle no :noweb-ref org-src-settings
(setq org-edit-src-content-indentation 0)
(setq org-confirm-babel-evaluate nil)
#+end_src

** Snippet expansion in org

Binding to =org-cycle= (usually TAB) or =org-ctrl-c-ctrl-c= does not follow the usual procedure. Because these keys are context-dependent to begin with, it's generally not a good idea to rebind them completely, since you might screw up additional contexts you didn't even realize were there before rebinding. Instead, additional functionality is added via hooks which are run before the main body of the function. If any of the functions returns a non-nil value, then the main body isn't run. It's the next best thing to a =cond= in the function itself.

Trying to bind tempel's expansion to TAB was a tad involved. The expansion function returns a non-nil value even when it fails, so I ended up writing a small wrapper function that returns =nil= on failure. This way the hook can successfully fall through.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +tempel-expand-maybe ()
  "Try to expand a snippet with tempel.
If expansion fails, return nil.
This function is specifically for use with org-cycle."
  (ignore-errors ; <- returns nil instead of error
    (when boon-insert-state
      (tempel-expand t))))
#+end_src

I then add the function to the hook run before =org-cycle=.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-cycle-tab-first . +tempel-expand-maybe)
#+end_src

** Org agenda

#+begin_src emacs-lisp
(use-package org-agenda
  :after org
  :bind
  (:map org-agenda-mode-map
   ("b" . #'org-agenda-earlier)
   ("f" . #'org-agenda-later)
   ("(" . #'org-agenda-earlier)
   (")" . #'org-agenda-later)
   ("u" . #'org-agenda-previous-line)
   ("e" . #'org-agenda-next-line)
   ("n" . #'left-char)
   ("i" . #'right-char)
   ("l" . #'link-hint-open-link)
   ("v" . nil)
   ("vw" . #'org-agenda-week-view)
   ("vm" . #'org-agenda-month-view)
   ;; bit different behaviour from link-hint
   ("<return>" . #'org-agenda-goto)))
#+end_src

*** Org agenda settings

I prefer the agenda to always open in fullscreen mode.
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda
(setq org-agenda-window-setup 'only-window)
#+end_src

I like to see the agenda for the current calendar week, but with the point on today's date (it also has a different face in my theme).

Weeks start on Mondays. Fite me.
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda
(setq org-agenda-span 'week
      org-agenda-start-on-weekday 1
      org-agenda-start-day ".")
#+end_src

When I jump to an org headline from agenda, I want to see its full ancestry and the entry text itself.
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda
(map-put! org-fold-show-context-detail 'agenda 'tree)
#+end_src

I use my whole org directory as my agenda list. If something gets an active timestamp, I want to see it in my agenda (and there is always =org-time-stamp-inactive=).
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda
(setq org-agenda-files (list org-directory))
#+end_src

** Org bling

Org-mode is amazing, but doesn't look it out of the box. Some light eye candy makes it an even bigger pleasure to use.

*** Org-modern

When using Doom, I bounced off one of its org beautification settings, which slowed down my Emacs quite noticeably. Right now I am using [[https://github.com/minad/org-modern][org-modern]] on a Surface Go 2, and it isn't slow at all.

I don't use all of the defaults though. I prefer my own faces for todos, and I'm not yet sure what to do with the tables.

With org-lists, I use "-" everywhere, because it can be typed without holding down the Shift key. The default replacement for "-" is a longer dash, but I like nice fat dots instead.

#+begin_src emacs-lisp
(use-package org-modern
  :ensure t
  :hook org-mode
  :config
  (setq org-modern-todo nil
        org-modern-table nil)
  (map-put! org-modern-list ?- "â¢"))
#+end_src

*** Table alignment with valign

Valign works much better with tables containing CJK and symbols than other similar packages. However, I've had it be a little slow, so I'm not turning it on by default, at least not yet.

#+begin_src emacs-lisp
(use-package valign
  :ensure t
  :commands (valign-mode))
#+end_src

*** Font lock for text in org checked items

Yet another fantastic idea from Doom: a special face for list items with a checked checkbox, as in this example:

- [ ] unchecked
- [X] checked

Which in my Emacs looks like this:

[[./img/checkbox.png]]

Headings with DONE have a special face that's in-built and can be customized, but the same does not exist for checked list items. Doom had its own workaround, which I was unable to find after a couple days' searching, but I did find [[https://fuco1.github.io/2017-05-25-Fontify-done-checkbox-items-in-org-mode.html][this blog post]], which referenced hlissner's config from 2017 (aka proto-Doom). Based on the code therein and on the [[info:elisp#Search-based Fontification][info node]], I wrote my own version. I use a simpler regex than what I've seen online, because I don't use =[X/Y]= in checkboxes.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-add-checked-font-lock ()
  (font-lock-add-keywords
   nil
   ;; (rx (seq line-start (* space) "- [X] " (+ not-newline)))
   `(("^[[:space:]]*- \\[X] .+" (0 'org-headline-done prepend)))
   'append))
#+end_src

Using a hook appears to be more reliable than just a bare =font-lock-add-keywords= setting, though. I'm not sure why, since other people's configs use it without a hook. Some part of my config must be interfering with it.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-mode . +org-add-checked-font-lock)
#+end_src

*** Org-appear

Hiding emphasis markers in org-mode makes it look quite nice, however it also makes editing more difficult. The [[https://github.com/awth13/org-appear][org-appear]] package shows hidden emphasis markers when the cursor is on an emphasized word, solving that problem.

#+begin_src emacs-lisp
(use-package org-appear
  :ensure t
  :commands (org-appear-mode))
#+end_src

I hook the package to open together with org.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-mode . org-appear-mode)
#+end_src

Now the emphasis markers may safely be hidden.

#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-hide-emphasis-markers t)
#+end_src

** Pandoc integration

My personal interface to pandoc from Emacs is written in a [[./pandoc.el][separate file]] as a module. There is a single entry point: a transient function (aptly named =pandoc-transient=), which allows the user to interactively construct a pandoc call, and then executes it.

I might make it into its own package later, but there is currently no shortage of pandoc APIs for Emacs, and my version is very much tailored to my personal needs and those alone.

Here we load the file.
#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "pandoc.el"))
#+end_src

The only keybinding required is for the transient entry point, which I set together with my other org bindings.

** Links

This is another personal package of mine, whose purpose is to insert all kinds of links in org:
- to org headings in the current file,
- to files on the system,
- links from the system clipboard.

#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "links.el"))
#+end_src

As with other commands, I like having it all in one big transient menu.

#+begin_src emacs-lisp
(transient-define-prefix +link-transient ()
  ["Org links"
   ["insert link..."
    ("l" "do-what-i-mean" +org-link-dwim)
    ("c" "from clipboard" +org-insert-link-from-clipboard)
    ("f" "to file" +org-insert-file-path)
    ("F" "to file (absolute)" +org-insert-absolute-file-path)
    ("i" "to image" +org-insert-image-path)]
   ["link to org heading..."
    ("h" "with heading text" +org-insert-link)
    ("u" "with a unique ID" +org-insert-link-with-id)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Yt-dlp

Not just an org module, but I'm putting it here for now.

#+begin_src emacs-lisp
(load-file (concat user-emacs-directory "yt-dlp.el"))
#+end_src

** Cross-referencing

This is a package to simplify inserting cross-references in org for later compilation with pandoc, and is in a way a sister package to my =pandoc.el=.

#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "refs.el"))
#+end_src

Again, a transient. Since I'm using transients instead of regular evil keybindings, I could make capitalization an infix instead of having separate bindings. Although it's not like I'm running out of keys. Something to ponder.

#+begin_src emacs-lisp
(transient-define-prefix +ref-transient ()
  ["Pandoc cross-references in Org"
   ["insert reference..."
    ("h" "to heading" +ref-insert-ref-heading)
    ("t" "to table" +ref-insert-ref-table)
    ("f" "to figure" +ref-insert-ref-figure)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Org-books

The =ht= package is a dependency of =org-books=.
#+begin_src emacs-lisp
(use-package ht
  :ensure t)
#+end_src

#+begin_src emacs-lisp
(use-package org-books
  :ensure (:host github :repo "goderich/org-books" :files (:defaults "*.el"))
  :init
  (setq org-books-file (f-join org-directory "books.org"))

  ;; Derive a separate mode for org-books-specific keybinds
  (define-derived-mode org-books-mode org-mode "Org books mode"
    "Major mode for managing prose using org.")

  ;; Autostart this mode when opening the org-books file
  (add-to-list 'auto-mode-alist `(,org-books-file . org-books-mode))

  (defun +org-books-setup ()
    (make-local-variable 'org-cycle-hook)
    (remove-hook 'org-cycle-hook #'org-cycle-hide-drawers 'local))

  (add-hook 'org-books-mode-hook #'+org-books-setup)
  ;; (add-hook 'org-books-after-insert-hook #'gd/org-books-tag-short)

  :bind (:map org-books-mode-map
              ("C-c C-j" . #'org-books-jump-to-reading)
              ("C-c C-f" . #'org-books-rate-book)
              ("C-c C-r" . #'org-books-start-reading)
              ("C-c C-d" . #'org-books-dnf)
              ("C-c C-u" . #'org-books-add-url)
              ("C-c C-l" . #'org-books-cliplink))

  :config
  ;; Add new books at the bottom of the chosen subtree
  (setq org-books-add-to-top nil)
  ;; Allow adding books under level 3 headings
  (setq org-books-file-depth 3))
#+end_src

** Org cite (disabled)

It's pretty awesome that org-mode now has in-built citation capabilities. I write my papers in org-mode, and having a stable citation API gives me confidence that my config won't need constant package and workflow changes (even though I started writing academic papers in org-mode even before org-cite).

#+begin_src emacs-lisp :tangle no
(use-package org-cite
  :after org)
#+end_src

However, the org-cite API itself is quite opaque. It appears to rely heavily on objects from Emacs' EIEIO library, which I'm not familiar with. I did manage to write a citation processor to open my citations in ebib on the corresponding paper, but the process was unnecessarily complicated and not very well documented. In the end I opted for my own handwritten code (see the [[id:60496f16-000c-4e9f-8522-848f300523a9][org-return]] and [[id:067dfe76-a65f-44b6-ab9d-a72b875071d2][link hinting]] sections) because that's easier to understand, maintain, and improve.

As such, the code below is *disabled*, but preserved for posterity.

#+begin_src emacs-lisp :tangle no
(defun +ebib-open-on-citation (citation _)
  (let ((key (map-elt (cadr citation) :key)))
    (ebib)
    (ebib-db-set-current-entry-key key ebib--cur-db)
    (ebib--update-buffers 'no-refresh)))

(org-cite-register-processor '+org-cite-follow-processor
  ;; Note that the citation is passed as an object, not a string.
  ;; The follow function must take two arguments.
  ;; See `org-cite-register-processor' documentation for details.
  :follow #'+ebib-open-on-citation)

(setq org-cite-global-bibliography (list +default-bibliography))
(setq org-cite-follow-processor '+org-cite-follow-processor)
#+end_src

** Org functions

Searching by heading is my primary means of navigating org files. Consult does this admirably. Problem is, when I'm jumping to an org heading, chances are I want to see what's inside it. I don't want to mash Tab repeatedly every time I jump to a a heading.

Unfortunately, =consult-org-heading= doesn't have a hook. Maybe I should ask the dev nicely?
#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +consult-goto-org-heading ()
    "Find an org heading in the current buffer, and open it.
`consult-org-heading' doesn't do this automatically for some reason."
    (interactive)
    (consult-org-heading)
    (org-fold-show-context)
    (org-fold-show-entry)
    (org-fold-show-children))
#+end_src

Adding tags is very easy is org, but removing them is not. I don't normally have a bunch of tags on every heading in org---usually just one. I like being able to remove all tags with a quick keystroke. For finer edits, I can always resort to more manual methods.
#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-remove-tags ()
  "Remove all tags from current heading."
  (interactive)
  (org-set-tags nil))
#+end_src

*** My version of org-return
:PROPERTIES:
:ID:       60496f16-000c-4e9f-8522-848f300523a9
:END:

I believe org-mode first started the fashion of contextually dependent actions in Emacs (aka "dwim"). Then Doom took it and expanded it further. The idea is great, and here I put my own spin on it. This function is bound to =<return>=, of course.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-return ()
  "Perform an action dependent on context.
If on a...
- list item with checkbox: toggle checkbox.
- table: move to next row, possibly creating one (jump out of table with =C-RET=).
- image or image link: toggle displaying the image.
- citation: open in ebib.
- URL: open it.
- org link: follow it.
- source block: edit it.
"
  (interactive)
  (cond
   ;; table, including in insert state
   ((org-at-table-p) (org-table-next-row))
   ;; insert state everywhere else
   (boon-insert-state (newline-and-indent))
   ;; list with checkbox
   ((org-at-item-checkbox-p) (org-toggle-checkbox))
   ;; image
   ((when-cond ((bounds (org-in-regexp +org-image-regexp)))
      (+org-toggle-image (car bounds) (cdr bounds))))
   ;; citation
   ((when-cond ((bounds (org-in-regexp +org-cite-regexp)))
      (+org-follow-cite (car bounds) (cdr bounds))))
   ;; a regular URL string with no description
   ((when-cond ((bounds (org-in-regexp +url-regexp))
                (url (buffer-substring-no-properties (car bounds) (cdr bounds))))
      (browse-url url)))
   ;; an org link of any kind, including URLs with descriptions
   ((org-in-regexp org-link-bracket-re) (link-hint-open-link-at-point))
   ;; org-src block
   ((org-in-src-block-p) (org-edit-src-code))))

(defmacro when-cond (spec &rest body)
  "Like `when-let', but returns true on successful binding.
For use inside `cond'."
  (declare (indent 1) (debug if-let))
  `(if-let ,spec ,(macroexp-progn (append body (list t)))))

(defun +org-follow-cite (beg end)
  (let* ((keys (->> (buffer-substring-no-properties beg end)
                    (s-match-strings-all +org-cite-key-regexp)
                    (-map #'-second-item))))
    (pcase (length keys)
      (0 (user-error "No keys found!"))
      (1 (+ebib-open-on-key (car keys)))
      (_ (let ((key (completing-read "Choose key to open: " keys)))
           (+ebib-open-on-key key))))))

(defvar +org-cite-regexp
  (rx (seq "[cite"
           (opt ?/ (one-or-more (any alnum ?/ ?_ ?-)))
           ":" (zero-or-more (not (any ?\[ ?\]))) "]")))

(defvar +org-cite-key-regexp
  (rx (seq "@" (group (one-or-more (or alnum ?- ?_))))))

(defun +ebib-open-on-key (key)
  (ebib)
  (ebib-db-set-current-entry-key key ebib--cur-db)
  (ebib--update-buffers 'no-refresh))

(defun +org-toggle-image (beg end)
  (org-toggle-inline-images nil beg end))

(defvar +org-image-regexp
  (rx (seq "[[./" (+? anything) "." (or "png" "jpg" "jpeg" "svg") "]]")))

(with-eval-after-load 'thingatpt
  (defvar +url-regexp
    (concat "\\<"
            (regexp-opt '("http://" "https://" "doi:") t)
            thing-at-point-url-path-regexp)
    "Basically a simplified version of `goto-address-url-regxp'"))
#+end_src

*** Org item insertion

'Item' can mean a bullet point in a list, or a heading. This is a contextually determined function that I prefer to bind to =C-<return>=.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-list-insert-and-indent (&optional checkbox?)
  "Insert a new row in a list.
Respects current indentation and checkbox.
Helper function for `+org-insert-item'."
  (let ((indentation (current-indentation)))
    (end-of-line)
    (org-insert-item checkbox?)
    (indent-line-to indentation)
    (end-of-line)
    (boon-set-insert-state)))

(defun +org-insert-item ()
  "Insert an item determined from context.
When point is on a...
- list item with a checkbox: insert a new list item with a checkbox,
- list item without a checkbox: insert a new list item without a checkbox,
- table: break the table after that row,
- elsewhere: insert a heading.

I use it to break tables because I have other functions that
take care of inserting new rows (both on Return and on my
line insertion functions), so instead I need some way of
jumping out or splitting a table.
"
  (interactive)
  (cond
   ;; list item with checkbox
   ((org-at-item-checkbox-p) (+org-list-insert-and-indent 'checkbox))
   ;; list item without checkbox
   ((org-at-item-p) (+org-list-insert-and-indent))
   ;; table
   ((org-at-table-p)
    (end-of-line)
    (newline))
   ;; elsewhere
   (t (org-insert-heading-respect-content))))
#+end_src

*** Org table row insertion

An idea I stole from [[https://github.com/Somelauw/evil-org-mode/blob/b1f309726b1326e1a103742524ec331789f2bf94/evil-org.el#L86-L91][evil-org]] that goes something like this: instead of regular newline insertion above/below the current line, insert a new table row if the point is inside a table. Since in regular text this enters insert state, I do the same in tables.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-table-insert-row (&optional below?)
  "Create a new table row and enter insert state in it in the same column."
  (let ((col (org-table-current-column)))
    (org-table-insert-row below?)
    (org-table-goto-column col)
    (boon-set-insert-state)))

(defun +org-open-below ()
  (interactive)
  (if (org-at-table-p)
      (+org-table-insert-row 'below)
    (boon-open-next-line-and-insert)))

(defun +org-open-above ()
  (interactive)
  (if (org-at-table-p)
      (+org-table-insert-row)
    (boon-open-line-and-insert)))
#+end_src

*** Org-refile

When refiling subtrees, I rarely move them outside the current file. Having incremental completion for the target makes refiling functions much more useful, and it's easy to achive with a simple function wrapping consult.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-refile-to-this-file ()
  (interactive)
  (let* ((loc-pair (save-excursion
                     (consult-org-heading)
                     (cons (org-get-heading) (point))))
         (heading (car loc-pair))
         (location (cdr loc-pair)))
    (org-refile nil
                (current-buffer)
                (list heading (buffer-file-name) nil location))))
#+end_src

*** Link path tooltip

Usually, we hide link URLs and display just the description. Doom Emacs shows a link URL tooltip in the echo area, similar to how eldoc shows the documentation for the function at point. That's pretty neat functionality, but it was surprisingly difficult to search for online. I found no discussions or questions about this sort of feature.

This is a relatively simple implementation. The function itself checks if the point is in a link regex, and if it is, displays the first group (the URL) as a message. I then hook it up to =post-command-hook= *locally*, so that it only works in org-mode.

I currently have it *turned off* because I'm using =help-at-pt-set-timer= (NB: check source of the fn, see also [[info:elisp#Idle Timers][info node]]). However, my approach is more flexible, and I might want to come back to it.

#+begin_src emacs-lisp :tangle no
(defun +org-link-tooltip ()
  "Display the URL of the link at point in the echo area."
  (interactive) ; for testing purposes only
  (when (org-in-regexp org-link-bracket-re)
    (message "Link: %s" (match-string 1))))

(add-hook 'org-mode-hook
          (lambda ()
            (add-hook 'post-command-hook #'+org-link-tooltip 0 'local)))
#+end_src

** Toc-org

The sole purpose of this package is to make it easier to read this config online by generating a browser-friendly table of contents. You're welcome.

#+begin_src emacs-lisp
(use-package toc-org
  :ensure t
  :after org
  :hook (org-mode . toc-org-mode))
#+end_src

* Typst

#+begin_src emacs-lisp
(use-package typst-ts-mode
  :ensure (:type git :host sourcehut :repo "meow_king/typst-ts-mode" :files (:defaults "*.el"))
  :mode "\\.typ\\'")
#+end_src

* Bibliography and citations

** Ebib

[[https://github.com/joostkremers/ebib][Ebib]] is a bibliography/reference manager written in Elisp, so that it runs inside Emacs. For normal people that in itself is a losing proposition, but since we use Emacs, it's worth looking into. I'm not of the opinion that anything and everything should be run inside Emacs, but Ebib is great! It provides all the functionality I need while staying out of my way. It integrates excellently with Emacs, provides referencing capability, and gives me full control of all of its aspects.

Sure, it doesn't have the bells and whistles of [[https://www.zotero.org/][other bibliography managers]], but I don't need those. I need to be able to cite papers while writing, and to quickly open PDFs whenever I feel like it. Ebib does that, and more.

#+begin_src emacs-lisp :noweb yes
(use-package ebib
  :ensure t
  :commands (ebib ebib-insert-citation)
  :bind
  <<ebib-keybindings>>
  :config
  <<ebib-functions>>
  <<ebib-settings>>)
#+end_src

*** Settings

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-settings
(setq ebib-preload-bib-files (list +default-bibliography))
;; (setq ebib-notes-directory +ebib-notes)
(setq ebib-file-search-dirs (list +ebib-file-search-dir))
(setq ebib-import-directory +ebib-import-directory)
(setq ebib-file-associations '(("pdf" . "zathura") ("ps" . "gv")))
(setq ebib-bibtex-dialect 'biblatex)
(setq ebib-citation-insert-multiple t)
(setq ebib-index-columns '(("Author/Editor" 20 t)
                           ("Year" 6 t)
                           ("Title" 40 t)))
(map-put! ebib-reference-templates
          "Article"
          "{Author}. {Date|Year}. {\"Title\".} {Journaltitle|Journal} {Volume}{(Issue)}{:Pages}.{ Doi.}")
(map-put! ebib-reference-templates
          "Book"
          "{Author|Editor}. {Date|Year}. {\"Title\".} {Address: }{Publisher.}")
(setq ebib-notes-name-transform-function #'identity)
(setq ebib-name-transform-function #'+ebib-generate-filename)

;; Set auto-generated citation key options
(setq bibtex-autokey-year-length 4
      bibtex-autokey-titleword-length 0
      bibtex-autokey-name-separator "-"
      bibtex-autokey-year-title-separator ""
      bibtex-autokey-edit-before-use t)
(setq ebib-uniquify-keys t)

(map-put! ebib-citation-commands
          'org-mode
          '((("text" "[cite/t: %(@%K%< %A%>%; )]")
             ("paren" "[cite: %(@%K%< %A%>%; )]")
             ("bare" "@%K")
             ("no-name" "[cite/na: %(@%K%< %A%>%; )]"))))
(map-put! ebib-citation-commands
          'markdown-mode
          '((("text" "@%K%< [%A]%>")
             ("paren" "[%(@%K%<, %A%>%; )]")
             ("year" "[-@%K%< %A%>]"))))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-settings
(defun turn-off-visual-line-mode ()
  (visual-line-mode -1))

(defun turn-on-truncate-lines ()
  (toggle-truncate-lines 1))

(add-hook 'ebib-index-mode-hook #'turn-on-truncate-lines)
(add-hook 'ebib-index-mode-hook #'turn-off-visual-line-mode)
#+end_src

*** Functions

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-functions
(defun +ebib-get-author-names (key)
  (let ((names
         (->>
          (ebib-get-field-value "author" key ebib--cur-db "default" 'unbraced)
          (s-split " and ")
          (--map (car (s-split "," it))))))
    (if (< 2 (length names))
        (concat (car names) " et al")
      (s-join " and " names))))

(defun +ebib-get-year (key)
  (let ((date
         (or
          (ebib-get-field-value "date" key ebib--cur-db 'noerror 'unbraced)
          (ebib-get-field-value "year" key ebib--cur-db 'noerror 'unbraced))))
    (->> date
         (s-split "-")
         (-first-item))))

(defun +ebib-get-title (key)
  (let ((title
         (->> (ebib-get-field-value "title" key ebib--cur-db "default" 'unbraced)
              (s-split ":")
              (car)
              (replace-regexp-in-string "[{}]" "")
              (s-trim))))
    (s-truncate 100 title "")))

(defun +ebib-generate-filename (key)
  (let ((names (+ebib-get-author-names key))
        (year (+ebib-get-year key))
        (title (+ebib-get-title key)))
    (->> (list names year title)
         (-non-nil)
         (s-join " ")
         (replace-regexp-in-string "/" "")
         (replace-regexp-in-string "," "")
         (replace-regexp-in-string " " "_"))))

(defun +ebib-edit-as-string ()
  "Edit the current field as a string.
This is a function for `ebib-entry-mode'. Since `ebib-edit-field'
has to take a numeric prefix /= 1 in order to begin string
editing, it seems easier to abstract this into a function and
give it its own name and keybinding."
  (interactive)
  (ebib-edit-field 2))

(defun +ebib-import-file-from-index ()
  "Import a file and add to the entry at point.
Used from the ebib index."
  (interactive)
  (ebib-edit-entry)
  (ebib-import-file nil)
  (ebib-quit-entry-buffer))
#+end_src

*** Keybindings

Largely mode and  input method agnostic keybindings for ebib.

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-keybindings
(:map ebib-index-mode-map
      ("q" . ebib-quit)
      ("u" . 'ebib-prev-entry)
      ("e" . 'ebib-next-entry)
      ("s" . ebib-save-current-database)
      ("S" . ebib-save-all-databases)
      ;; Unset N while I'm figuring out what to do with notes.
      ("N" . nil)
      ("/" . ebib-jump-to-entry)
      ("<tab>" . ebib-edit-entry)
      ("f" . 'ebib-view-file)
      ("O" . ebib-open-bibtex-file)
      ("o" . nil)
      ("of" . +ebib-import-file-from-index)
 :map ebib-entry-mode-map
      ("q" . ebib-quit)
      ("u" . 'ebib-prev-field)
      ("e" . 'ebib-next-field)
      ("z" . ebib-leave-ebib-windows)
      ("E" . +ebib-edit-as-string)
      ("s" . ebib-save-current-database)
      ("S" . ebib-save-all-databases)
      ("D" . ebib-delete-current-field-contents)
      ("<tab>" . ebib-quit-entry-buffer)
      ("O" . ebib-open-bibtex-file)
      ("o" . nil)
      ("of" . ebib-import-file))
#+end_src

* Programming languages

** Lisps
Smartparens is THE package for lisp code editing.
#+begin_src emacs-lisp :noweb yes
(use-package smartparens
  :ensure t
  :hook (prog-mode)
  :config
  ;; load default config
  (require 'smartparens-config)
  :bind
  (:map smartparens-mode-map
        ("C-(" . sp-backward-slurp-sexp)
        ("C-)" . sp-forward-slurp-sexp)
        ("C-," . sp-backward-barf-sexp)
        ("C-." . sp-forward-barf-sexp)))
#+end_src

#+begin_src emacs-lisp
(use-package eros
  :ensure t
  :hook emacs-lisp-mode)
#+end_src

Examples can be found in the [[https://github.com/Fuco1/smartparens/wiki][wiki]] and in [[https://ebzzry.com/en/emacs-pairs/][this article]].

** Emacs Lisp

#+begin_src emacs-lisp
(use-package elisp-mode
  :bind
  (:map emacs-lisp-mode-map
        ("C-c C-e" . +elisp-eval-transient)))
#+end_src

#+begin_src emacs-lisp
(use-package eldoc
  :config
  (setq eldoc-idle-delay 0))
#+end_src

#+begin_src emacs-lisp
(use-package elisp-demos
  :ensure t
  :after helpful
  :config
  (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

#+begin_src emacs-lisp
(transient-define-prefix +elisp-eval-transient ()
  ["Eval..."
   ("e" "last sexp" eros-eval-last-sexp)
   ("d" "defun" eros-eval-defun)
   ("r" "and replace" crux-eval-and-replace)
   ("b" "buffer" eval-buffer)]
  [("<escape>" "quit" transient-quit-all)])
#+end_src

** Clojure

See also the following:
- [[https://github.com/clojure-emacs/clojure-mode/][clojure-mode]]
- [[https://github.com/clojure-emacs/cider][cider]]
- [[https://github.com/clojure-emacs/clj-refactor.el][clj-refactor]]
- [[https://docs.doomemacs.org/latest/modules/lang/clojure/][clojure doom module]]

#+begin_src emacs-lisp
(use-package clojure-mode
  :ensure t
  :defer t
  :bind (:map clojure-mode-map
          ("C-c '" . 'cider-jack-in)))
#+end_src

#+begin_src emacs-lisp
(use-package cider
  :ensure t
  :commands (cider-jack-in cider-jack-in-clj cider-jack-in-cljs
             cider-connect-clj cider-connect-cljs)
  :config
  (setq cider-allow-jack-in-without-project t
        cider-jack-in-default 'babashka
        cider-repl-pop-to-buffer-on-connect nil))
#+end_src

** Hare

#+begin_src emacs-lisp
(use-package hare-mode
  :ensure (:host sourcehut :repo "bbuccianti/hare-mode")
  :mode "\\.ha\\'")
#+end_src

* Markup languages

** YAML

#+begin_src emacs-lisp
(use-package yaml-ts-mode
  :mode ("\\.yml\\'" "\\.yaml\\'"))
#+end_src

* Utils
** Magit

Consider also [[https://github.com/alphapapa/magit-todos][magit-todos]].

#+begin_src emacs-lisp
(use-package magit
  :ensure t
  :commands (magit)
  :bind (:map magit-mode-map
         ("p" . magit-push)
         ("f" . magit-pull))
  :config
  (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
  (setq git-commit-summary-max-length 50)
  (add-hook 'git-commit-setup-hook #'boon-set-insert-state 90))
#+end_src

*** Git diff highlighting

Changed the settings using [[https://www.reddit.com/r/emacs/comments/582yms/question_changing_the_colour_of_diffhl_indicators/][this discussion]] as a reference.
I stole the insert and delete shades from Doom, because they look really good.

#+begin_src emacs-lisp
(use-package diff-hl
  :ensure t
  :defer 2
  :config
  (custom-set-faces
   '(diff-hl-change ((t (:background "orange2" :foreground "orange2")))) ; #cb4b16
   '(diff-hl-insert ((t (:background "#859900" :foreground "#859900"))))
   '(diff-hl-delete ((t (:background "#dc322f" :foreground "#dc322f")))))
  (diff-hl-flydiff-mode)
  (global-diff-hl-mode))
#+end_src

** Tempel snippets
:PROPERTIES:
:ID:       0118536f-8f2f-4e6d-ab30-66bd3101401d
:END:
Trying https://github.com/minad/tempel.

Once I'm inside a snippet, I want to be able to use Tab to jump to next placeholder (or move the point after the snippet if there are no more placeholders). However, very rarely, I have had need to expand another snippet whilst expanding a snippet. In this very uncommon case, I can use Shift+Tab to expand.

#+begin_src elisp :noweb yes
(use-package tempel
  :ensure t
  :commands (tempel-expand)
  :bind (:map tempel-map
          ("TAB" . tempel-next)
          ("<backtab>" . tempel-expand)
          ("<escape>" . tempel-done)))
#+end_src

** Crux

#+begin_src emacs-lisp
(use-package crux
  :ensure t
  :commands (crux-delete-file-and-buffer
             crux-rename-file-and-buffer
             crux-sudo-edit
             crux-move-beginning-of-line
             crux-top-join-line
             crux-eval-and-replace)
  :bind ("C-k" . #'crux-smart-kill-line))
#+end_src

** Avy

Avy is an amazing package for all kinds of on-screen navigation. I use it to jump around and to open links and citations with link-hint. The one thing I modify in my avy config is the =avy-keys= variable: I map it to the Colemak home row keys. However, it is not advisable to enumerate the home row left to right, since avy takes the keys in order. I go by finger ordering: index, middle, index curved downwards, ring; alternating right and left hands.

#+begin_src emacs-lisp
(use-package avy
  :ensure t
  :config
  ;; use Colemak (DH) home row hints
  (setq avy-keys '(?n ?t ?e ?s ?h ?d ?i ?r)))
#+end_src

** Link hinting
:PROPERTIES:
:ID:       067dfe76-a65f-44b6-ab9d-a72b875071d2
:END:

#+begin_src elisp :noweb yes
(use-package link-hint
  :ensure t
  :commands (link-hint-open-link link-hint-open-link-at-point)
  :config
  <<link-hint-org-cite>>)
#+end_src

Here I add a new link type for org citations. (Some of the relevant code, e.g. =+org-follow-cite=, is defined elsewhere in the config.) The =:next= and =:at-point-p= keywords are required by link-hint, and =:open= is the functionality that I want. This lets me call link-hint the way I normally do, and through it open citations with my custom function.

#+begin_src emacs-lisp :tangle no :noweb-ref link-hint-org-cite
(link-hint-define-type 'org-cite
  :next #'link-hint--next-org-cite
  :at-point-p #'+org-at-cite-p
  :open #'+org-follow-cite)

(push 'link-hint-org-cite link-hint-types)

(defun +org-at-cite-p ()
  "If the point is on an org citation, return its bounds.
The bounds are returned as a list, to be passed to `+org-follow-cite'."
  (flatten-tree (org-in-regexp +org-cite-regexp)))

(defun link-hint--find-org-cite (start-bound end-bound)
  "Find the first file link.
Only search the range between just after START-BOUND and END-BOUND."
  (save-excursion
    (let (org-cite-pos)
      (goto-char start-bound)
      (link-hint--find-regexp +org-cite-regexp
                              (point) end-bound))))

(defun link-hint--next-org-cite (bound)
  "Find the next org citation.
Only search the range between just after the point and BOUND."
  (link-hint--find-org-cite (point) bound))
#+end_src

** Dumb jump

#+begin_src emacs-lisp
(use-package dumb-jump
  :ensure t
  :init
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
  :bind
  (:map goto-map
        ("d" . #'xref-find-definitions)))
#+end_src

** Anzu

[[https://github.com/emacsorphanage/anzu][Anzu]] is a small but pretty important package
that shows the number of search matches in the modeline.
It stays completely out of the way
until you search for occurrences of something,
and then it's indispensable.

#+begin_src emacs-lisp
(use-package anzu
  :ensure t
  :init (global-anzu-mode 1))
#+end_src

** hl-todo

#+begin_src emacs-lisp
(use-package hl-todo
  :ensure t
  :defer 2
  :config (global-hl-todo-mode 1)
  (transient-define-prefix +hl-todo-transient ()
    ["Browsing todo keywords..."
     ("n" "next" hl-todo-next :transient t)
     ("p" "previous" hl-todo-previous :transient t)
     ("q" "quit" transient-quit-all)]))
#+end_src

** Olivetti

Olivetti is a great mode for prose writing and reading. All it does is increase the width of the margins to make the text width more comfortable. Another great mode with similar functionality is [[https://github.com/joostkremers/writeroom-mode][writeroom-mode]], but the latter also modifies the modeline.

#+begin_src emacs-lisp
(use-package olivetti
  :ensure t
  :commands (olivetti-mode)
  :hook ((Info-mode . +olivetti-info-setup))
  :config
  (setq-default olivetti-body-width 48))

(defun +olivetti-info-setup ()
  (olivetti-mode)
  (olivetti-set-width 50))
#+end_src

** ws-butler
One more package I learned of from Doom's config.

#+begin_src emacs-lisp
(use-package ws-butler
  :ensure t
  :init (ws-butler-global-mode 1))
#+end_src

** Help

https://github.com/Wilfred/helpful

#+begin_src emacs-lisp
(use-package helpful
  :ensure t
  :commands (+helpful-transient))
#+end_src

** Tldr

[[https://tldr.sh/][Tldr pages]] are a fantastic resource, and Emacs is a great environment to read them. The only problem is that tldr.el's default colour scheme is a war crime, so I disabled all colouring.

#+begin_src emacs-lisp
(use-package tldr
  :ensure t
  :custom-face
  (tldr-title
   ((t :foreground unspecified)))
  (tldr-introduction
   ((t :foreground unspecified
       :italic unspecified)))
  (tldr-description
   ((t :foreground unspecified)))
  (tldr-command-itself
   ((t :foreground unspecified
       :background unspecified)))
  (tldr-command-argument
   ((t :foreground unspecified
       :background unspecified)))
  (tldr-code-block
   ((t :foreground unspecified
       :background unspecified))))
#+end_src

** TODO Undo
:PROPERTIES:
:ID:       53828884-e258-4f2b-b8e0-46c5cf9926ea
:END:
See also Hints and undo-fu-session [[https://codeberg.org/ideasman42/emacs-undo-fu][here]].
Can also try [[https://github.com/casouri/vundo][vundo]], although my undo needs aren't that sophisticated.

#+begin_src emacs-lisp
(use-package undo-fu
  :ensure t)
#+end_src

** Evil-numbers (disabled)

Another small package, this time to manipulate numbers.
I occasionally find myself needing to add/subtract a sum
from numbers on a bunch of lines, so this is handy for those situations.
NOTE: Appears to require evil

#+begin_src emacs-lisp :tangle no
(use-package evil-numbers
  :commands (evil-numbers/inc-at-pt
             evil-numbers/dec-at-pt
             evil-numbers/inc-at-pt-incremental
             evil-numbers/dec-at-pt-incremental))
#+end_src

* Finalize

Trick from [[https://blog.d46.us/advanced-emacs-startup/][here]]:
I increase the garbage collection threshold
during startup to speed up Emacs' load time,
but then decrease it once my config loads
so that GC pauses aren't so noticeable
when I'm actually using Emacs.

#+begin_src emacs-lisp
(setq gc-cons-threshold (* 2 1000 1000))
#+end_src

* More packages :noexport:

Here are some packages I should consider trying out:
- https://github.com/alphapapa/org-super-agenda
- https://github.com/jamescherti/inhibit-mouse.el <- completely disable the mouse
- https://github.com/emacsorphanage/macrostep
- https://github.com/wwwjfy/emacs-fish
- https://github.com/yoshiki/yaml-mode
- https://github.com/jdtsmith/ultra-scroll for ridiculously smooth scrolling
- https://github.com/emacsorphanage/quickrun
- https://github.com/radian-software/apheleia/
- https://github.com/jorgenschaefer/emacs-buttercup
- https://github.com/hlissner/emacs-solaire-mode (necessary? I don't use splits that much)
- https://github.com/manateelazycat/lsp-bridge <- eglot alternative, advertised as blazingly fast
- https://github.com/flycheck/flycheck
- https://github.com/minad/jinx for spelling
- Think about giving Dired another go
  - Check the [[https://github.com/Fuco1/dired-hacks][dired hacks]] repo for more dired related packages.
- Should also look into terminal emulation in Emacs perhaps. Then again, perhaps not.
- Org-mode:
  - https://github.com/rougier/agenda <- python script, but might be useful?
- https://github.com/Wilfred/deadgrep
- https://github.com/vedang/pdf-tools
- Mail? Consider.
- https://github.com/progfolio/elpaca consider
- Packages for writing prose in [[https://github.com/jacmoe/.doom.d][this config]]

For more packages see here:
https://github.com/emacs-tw/awesome-emacs
