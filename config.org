* NEXT Outgoing TODOs

This is actually going quite nicely, but I still need the following:
- Proper org config (nearing completion)
  - Contextual behaviour (dwim for RET)
  - org agenda settings
- Fonts (+variable width for org+, CJK font config)
- Crux (for various utility functions)
- Modeline (how important is this actually?)

Academic:
- Add ebib, copy config
- Probably need to copy vars.el as well

Other TODOs:
- org-refile (configure refiling to current file)
- org-books (maybe migrate to codeberg and rename?)

Programming langs and other modes (check my doom/init.el):
- Elisp
- Clojure
- Zig
- Odin
- YAML
- JSON
- HTML
- ???

** Packages
These are some of the packages I should consider:
- https://github.com/bbatsov/crux <- lots of useful utility functions
- https://github.com/tarsius/hl-todo
  Keybindings from Doom:
| [[kbd:][]t]]      | go to next TODO item             |
| [[kbd:][[t]]      | go to previous TODO item         |
| [[kbd:][SPC p t]] | show all TODO items in a project |
- https://github.com/emacsorphanage/anzu <- show number of search items in modeline
- https://github.com/emacs-dashboard/emacs-dashboard
- https://github.com/hlissner/emacs-solaire-mode
- https://github.com/edkolev/evil-lion <- not necessary all the time, but nice when needed
- Maybe https://github.com/redguardtoo/evil-nerd-commenter if what I'm using now is insufficient
- https://github.com/xiongtx/eros <- overlays for showing evaluated results
- https://github.com/jacktasia/dumb-jump for jumping to definition
- What's the Doom package that shows usage examples in the help menu?
- https://github.com/kuanyui/tldr.el
- https://github.com/manateelazycat/lsp-bridge <- eglot alternative, advertised as blazingly fast
- https://github.com/flycheck/flycheck
- https://github.com/minad/jinx for spelling
- Think about giving Dired another go
- Org-mode:
  - https://github.com/minad/org-modern <- will it slow? (maybe not, try)
  - https://github.com/sabof/org-bullets <- if above is slow, can use this instead
  - https://github.com/rougier/agenda <- python script, but might be useful?
- Theming:
  - https://github.com/rougier/nano-emacs and related packages
  - https://github.com/doomemacs/themes
  - https://github.com/bbatsov/zenburn-emacs
  - https://github.com/oneKelvinSmith/monokai-emacs
  - https://github.com/kunalb/poet
  - https://github.com/rougier/nano-theme
- https://github.com/emacsorphanage/git-gutter
- https://github.com/Wilfred/deadgrep
- https://github.com/vedang/pdf-tools
- Mail? Consider.
- https://github.com/progfolio/elpaca consider
- Modelines:
  - https://github.com/seagle0128/doom-modeline
  - https://github.com/Malabarba/smart-mode-line

* Resources

I can read other people's configs, not limited to literate ones.
- [[https://github.com/bbatsov/emacs.d/blob/master/init.el][bbatsov's minimalist config]]
- [[https://github.com/hrs/dotfiles/blob/main/emacs/.config/emacs/configuration.org][Great evil-based config]]
- [[https://github.com/zzamboni/dot-emacs/blob/master/init.org][Zzamboni's evil-based config]] prior to his migration to Doom. Lots of org gems there.
- [[https://github.com/rougier/dotemacs/blob/master/dotemacs.org][Nicholas Rougier's literate config]]

Might be some interesting stuff here:
https://github.com/daviwil/emacs-from-scratch

For packages see here:
https://github.com/emacs-tw/awesome-emacs

* Basic settings
** Early loading
Maybe some of this should be in =early-init.el=?
See also https://github.com/hrs/sensible-defaults.el

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
(use-package emacs
  :custom
  ;; reduce the frequency of garbage collection by making it happen on
  ;; each 20MB of allocated data (the default is on every 0.76MB)
  (gc-cons-threshold 20000000)
  ;; warn when opening files bigger than 100MB
  (large-file-warning-threshold 100000000)
  ;; do not create backups
  (make-backup-files nil)
  ;; use regular spacing with sentences.
  ;; this is important because it directly impacts sentence motions in evil.
  (sentence-end-double-space nil)
  ;; do not pollute this file with custom variables
  (custom-file "~/.emacs.d/custom.el")
  :config
  (load custom-file)
  ;; do not use tabs for indentation
  (indent-tabs-mode -1))
#+end_src

** Package management
Instead of putting =:ensure t= everywhere, I can just set it here once.
(This is not recommended by some.)

#+begin_src elisp
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+end_src

See also =use-package-defaults= for other settings.

#+begin_src elisp
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+end_src

** Theming

#+begin_src elisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(display-line-numbers-mode -1)

;; Soft wrap long lines
(global-visual-line-mode 1)

;; Maintain a small margin when scrolling
(setq scroll-margin 2)

(use-package solarized-theme
  :config
  (load-theme 'solarized-light t))
#+end_src

** Fonts
Some ideas for font configuration in [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][this blog post]] and [[https://stackoverflow.com/questions/28428382/how-to-manage-fonts-in-emacs][this SO answer]].
#+begin_src emacs-lisp
(use-package mixed-pitch
  :hook (text-mode . mixed-pitch-mode))

(set-frame-font "Source Code Pro-20")
#+end_src
For CJK fonts specifically, check [[https://www.shimmy1996.com/en/posts/2018-06-24-fun-with-fonts-in-emacs/][this]], or [[https://www.reddit.com/r/emacs/comments/8tz1r0/how_to_set_font_according_to_languages_that_i/e1bjce6/][this snippet]].
Also [[https://coldnew.github.io/d5011be2/][this article]] deals with CJK alignment in org tables.

* TODO Utility functions
Should move these under appropriate headings.

#+begin_src emacs-lisp
(defun +consult-goto-org-heading ()
    "Find an org heading in the current buffer, and open it.
`consult-org-heading' doesn't do this automatically for some reason."
    (interactive)
    (consult-org-heading)
    (org-fold-show-context)
    (org-fold-show-entry)
    (org-fold-show-children))

(defun +open-config ()
  (interactive)
  (find-file "~/.emacs.d/config.org"))

(defun +open-org-dir ()
  (interactive)
  (ido-find-file-in-dir "~/org/"))
#+end_src

* Evil

Check out this great macro for evil keybindings with use-package:
https://www.mattduck.com/2023-08-28-extending-use-package-bind

#+begin_src elisp :noweb yes
(use-package evil
  :init
  (evil-mode 1)
  ;; Sane undo
  (evil-set-undo-system 'undo-fu)

  :bind <<evil-escape>>
  :custom
  (evil-esc-delay 0)
  ;; Substitute with :s globally by default
  (evil-ex-substitute-global t)
  ;; Make evil commands operate on logical, not visual lines
  (evil-respect-visual-line-mode nil)

  :config
  <<evil-cursor>>
  <<evil-keybindings>>

  ;; Elisp mode
  (evil-define-key 'normal emacs-lisp-mode-map
    (kbd "<localleader>ee") #'eval-last-sexp))
#+end_src

Maybe use https://github.com/emacs-evil/evil-collection ?
Modules can be loaded incrementally.

For org-mode specifically, https://github.com/Somelauw/evil-org-mode
has some great ideas, which I could take wholesale as a package,
or steal selectively. See the "[[https://github.com/Somelauw/evil-org-mode/blob/master/doc/example_config.el][elaborate setup]]" example.

Better S motions:
https://github.com/hlissner/evil-snipe

#+begin_src emacs-lisp :tangle no :noweb-ref evil-cursor
(setq evil-emacs-state-cursor  '("red" box))
(setq evil-normal-state-cursor '("gray" box))
(setq evil-visual-state-cursor '("gray" box))
(setq evil-insert-state-cursor '("gray" bar))
(setq evil-motion-state-cursor '("gray" box))
(blink-cursor-mode -1)
#+end_src

#+begin_src emacs-lisp
(use-package evil-surround
  :ensure t
  :config (global-evil-surround-mode 1))
#+end_src

** Keybindings

Make ESC quit everything.
I tried setting this up in the minibuffer to no avail,
and with other keybinding methods and functions,
but it turned out that a simple line with a =use-package= keyword
was all that was needed.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-escape
("<escape>" . keyboard-escape-quit)
#+end_src

Not only that, but when I'm in insert mode and a [[id:2ca8bb84-790f-4e68-8d3d-4893ef154e43][completion]] overlay is active,
or if I'm currently in the middle of inserting a [[id:0118536f-8f2f-4e6d-ab30-66bd3101401d][snippet]],
I want ESC to quit completion or templating *while keeping me in insert mode*.
There does not appear to be a simple way of doing with with settings or hooks,
and evil is greedily capturing keypresses,
so remapping ESC in =corfu-mode= and =tempel-mode= did not work.
During times like these, my solution is a simple wrapper function
that I then bind ESC to globally in insert mode.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(defun +evil-normal-state-maybe ()
  (interactive)
  (cond
   ((and corfu-mode completion-in-region-mode) (corfu-quit))
   (tempel--active (tempel-done))
   (t (evil-normal-state))))

(evil-define-key 'insert 'global (kbd "<escape>") #'+evil-normal-state-maybe)
#+end_src

I first encountered the idea of using SPC as the global leader in Spacemacs, and I think it's great.
I use the comma for localleader binds, because in Dvorak it's very conveniently positioned,
and not a great loss in normal mode.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-set-leader 'normal (kbd "SPC"))
(evil-set-leader 'normal (kbd ",") 'localleader)
#+end_src

I run commands by name quite a lot, and so to me it makes sense
to bind the command menu to an easily reachable key,
preferably with no modifiers.
Doom has it on =SPC := if I recall correctly.
I think vim's =;= command is not worth an unmodified key,
especially since it is made redundant with [[https://github.com/hlissner/evil-snipe][evil-snipe]].

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key '(normal visual) 'global ";" #'execute-extended-command)
#+end_src

I write a lot of prose, and so encounter wrapped lines quite often.
For me, =j= and =k= moving by visual line just makes sense.
=gj= and =gk= bindings are there mostly for macros,
as I don't use them interactively.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key '(normal visual) 'global
  "k"  #'evil-previous-visual-line
  "j"  #'evil-next-visual-line
  "gj" #'evil-next-line
  "gk" #'evil-previous-line)
#+end_src

Spacemacs also introduced me to mnemonic keybindings.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key 'normal 'global
  ;; Files
  (kbd "<leader>.") #'find-file
  (kbd "<leader>fr") #'recentf
  (kbd "<leader>fo") #'+open-org-dir
  (kbd "<leader>fs") #'save-buffer
  (kbd "<leader>fc") #'+open-config
  ;; Buffers
  (kbd "<leader>,") #'consult-buffer
  (kbd "<leader>bq") #'kill-this-buffer
  ;; Windows
  (kbd "<leader>w") #'+window-transient
  ;; Line comments
  (kbd "gc") #'comment-line)
#+end_src

** TODO Undo
See also Hints and undo-fu-session [[https://codeberg.org/ideasman42/emacs-undo-fu][here]].

#+begin_src emacs-lisp
(use-package undo-fu)
#+end_src

** Minibuffer keybindings

Keybindings in the minibuffer have to be set differently.
I am not using evil in the minibuffer, and the bindings
have to be set up using a hook each time.

I went through this trouble to replicate Doom's behaviour
when pressing backspace in the minibuffer.
It works as normal when typing the name of a file,
but if you keep deleting, the parent directories will be deleted
with a single press of backspace.
This is pretty convenient when jumping upwards many levels.

Right now my implementation is very naive,
as it doesn't know if I'm in a file path or some other completion.
In other places, it will delete the whole line if you press backspace on a slash,
although I do not foresee many such situations in my Emacs usage.

#+begin_src emacs-lisp
(defun +delete-char-or-directory ()
  (interactive)
  (if (eq (char-before) ?/)
      (backward-kill-sexp)
    (delete-backward-char 1)))

(defun +minibuffer-setup ()
  (define-key minibuffer-local-map (kbd "<backspace>") #'+delete-char-or-directory)
  (define-key minibuffer-local-map (kbd "C-w") #'backward-kill-word))

(add-hook 'minibuffer-setup-hook #'+minibuffer-setup)
#+end_src

** Window resizing transient

#+begin_src emacs-lisp
(transient-define-prefix +window-transient ()
  ["Resizing windows"
   ["Transient"
    ("b" "bigger" enlarge-window :transient t)
    ("s" "smaller" shrink-window :transient t)
    ("=" "balance" balance-windows :transient t)]
   ["Non-transient"
    ("d" "delete" delete-window)
    ("w" "other" other-window)
    ("m" "maximize" delete-other-windows)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

* Help

https://github.com/Wilfred/helpful

#+begin_src emacs-lisp
(use-package helpful
  :config
  (evil-global-set-key 'normal (kbd "<leader>h") #'+helpful-transient)
  (evil-define-key 'normal helpful-mode-map "q" #'kill-buffer-and-window))
#+end_src

#+begin_src emacs-lisp
(transient-define-prefix +helpful-transient ()
  ["Emacs help"
   ["Helpful mode"
    ("f" "functions and macros" helpful-callable)
    ("v" "variables" helpful-variable)
    ("k" "key" helpful-key)
    ("c" "interactive functions" helpful-command)
    ("p" "thing at point" helpful-at-point)]
   ["In-built help"
    ("m" "describe mode" describe-mode)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

* Narrowing and completion
** Narrowing

TODO: There is a lot of functionality here, I should explore it.
https://github.com/minad/consult
#+begin_src emacs-lisp
(use-package consult)

(use-package vertico
  ;; :custom
  ;; (vertico-scroll-margin 0) ;; Different scroll margin
  ;; (vertico-count 20) ;; Show more candidates
  ;; (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
  ;; (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
  :init (vertico-mode))

;; Persist history over Emacs restarts.
(use-package savehist
  :init (savehist-mode))

(use-package orderless
  :custom
  (completion-styles '(orderless basic))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles partial-completion)))))

;; Documentation in M-x and minibuffers
(use-package marginalia
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  ;; :bind (:map minibuffer-local-map
  ;;        ("M-A" . marginalia-cycle))

  :init (marginalia-mode))

;; Do not delay which-key (delay has to be above zero)
(use-package which-key
  :init (which-key-mode)
  :config
  (setq which-key-idle-delay 1)
  (setq which-key-idle-secondary-delay 0.05))
#+end_src

There is also https://github.com/oantolin/embark/,
but I haven't learned how to use it properly.

** Completion
:PROPERTIES:
:ID:       2ca8bb84-790f-4e68-8d3d-4893ef154e43
:END:

Using [[https://github.com/minad/corfu][Corfu]].

I do NOT normally want completion on in org, because that's distracting.
I do want completion when programming, and I want it to open up automatically.

Trying out SPC as separator:
pressing space does not exit completion, but instead begins a second chunk.
This makes corfu work a lot like consult et al,
where a search string can be entered using space-separated pieces.

#+begin_src emacs-lisp
(use-package corfu
  :hook ((prog-mode . corfu-mode))
  :custom
  (corfu-auto t)
  (corfu-quit-no-match t)
  :bind (:map corfu-map
	      ("TAB" . corfu-expand)
	      ("SPC" . corfu-insert-separator)))
#+end_src

* Org-mode

Check out https://github.com/minad/org-modern

#+begin_src emacs-lisp :noweb yes
(use-package org
  :after evil
  :init <<org-init>>
  :hook <<org-hooks>>
  :config
  <<org-settings>>
  <<org-src-settings>>
  <<org-keybindings>>
  <<org-modules>>)
#+end_src

** Org settings

Enable indentation in org-mode.
#+begin_src emacs-lisp :tangle no :noweb-ref org-init
(setq org-startup-indented t)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-tags-column 0)
#+end_src

One of the many things I liked about Doom was the TODO settings.
Fast TODO selection was on by default, which I think is a great idea
if you are using more keywords than just TODO and DONE.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-use-fast-todo-selection t)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
;; (setq org-tag-faces (:foreground "blue" :weight normal))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
;; Set org file associations
(setq org-file-apps
      `((auto-mode . emacs)
	(,(rx ".pdf::" (group (one-or-more digit)) string-end) . "zathura %s -P %1")
	(,(rx ".pdf" string-end) . "zathura %s")
	(directory . emacs)))

;; browser needs to be set with a separate function
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "qutebrowser")

;; Don't use blank lines between text and the following heading
(setq org-blank-before-new-entry
      '((heading . t) (plain-list-item . nil)))

;; Don't show empty lines between collapsed headings
(setq org-cycle-separator-lines 0)

;; Org todo keywords and colours
(setq org-todo-keywords
      '((sequence "TODO(t)" "|" "DONE(d)")
	(sequence "NEXT(n)" "WAITING(w)" "LATER(l)" "LOOP(p)" "|" "CANCELLED(c)")))

;; Use LOOP keyword for repeating tasks
;; (after marking them as done)
(setq org-todo-repeat-to-state "LOOP")

;; Archive everything from org files in one directory
;; into a single hidden file.
(setq org-archive-location ".archive.org::")

;; My custom faces for todo items. I'm reusing most from Doom.
(with-no-warnings
  (custom-declare-face '+org-todo-important '((t (:inherit (bold default)))) ""))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-src-settings
(setq org-edit-src-content-indentation 0)
#+end_src


** Org keybindings

Note that some keybindings are set in their respective modes.
They still appear together in the final tangled file.

#+begin_src emacs-lisp :tangle no :noweb-ref org-keybindings
(evil-define-key '(normal visual) org-mode-map
  (kbd "<tab>") #'org-cycle
  (kbd "<localleader>,") #'org-ctrl-c-ctrl-c
  (kbd "<localleader>s") #'org-edit-src-code
  (kbd "<localleader>t") #'org-todo
  (kbd "<localleader>S") #'org-sparse-tree
  (kbd "<localleader>q") #'org-set-tags-command
  (kbd "<localleader>Q") #'+org-remove-tags
  (kbd "<localleader>.") #'+consult-goto-org-heading
  (kbd "gh") #'outline-previous-visible-heading)
#+end_src

Some keybindings, namely ones using a modifier key,
should be accessible in both normal and insert modes.
#+begin_src emacs-lisp :tangle no :noweb-ref org-keybindings
(evil-define-key '(normal insert) org-mode-map
  (kbd "M-h") #'org-metaleft
  (kbd "M-j") #'org-metadown
  (kbd "M-k") #'org-metaup
  (kbd "M-l") #'org-metaright
  (kbd "M-H") #'org-shiftmetaleft
  (kbd "M-J") #'org-shiftmetadown
  (kbd "M-K") #'org-shiftmetaup
  (kbd "M-L") #'org-shiftmetaright
  (kbd "C-<return>") #'+org-insert-item)
#+end_src

From evil-org, use evil bindings in source and table editing modes:
#+begin_src emacs-lisp :tangle no :noweb-ref org-keybindings
(with-eval-after-load 'org-src
  (define-key org-src-mode-map [remap evil-save-and-close]          'org-edit-src-exit)
  (define-key org-src-mode-map [remap evil-save-modified-and-close] 'org-edit-src-exit)
  (define-key org-src-mode-map [remap evil-quit]                    'org-edit-src-abort))
#+end_src

Binding to =org-cycle= (usually TAB)
or =org-ctrl-c-ctrl-c= (mine is =,,= instead)
does not follow the usual procedure.
Because these keys are context-dependent to begin with,
it's generally not a good idea to rebind them completely,
since you might screw up additional contexts
you didn't even realize were there before rebinding.
Instead, additional functionality is added via hooks
which are run before the main body of the function.
If any of the functions returns a non-nil value,
the main body is run instead.
It's the next best thing to a =cond= in the function itself.

Trying to bind tempel's expansion to TAB was a tad involved.
The expansion function returns a non-nil value even when it fails,
and the =tempel-expand= function by itself does not expand
when run programmatically.
I ended up writing a small wrapper function that returns nil
if an expansion fails, so that the hook can successfully fall through.
(See [[Org functions][Org functions]].)
Here I just add the function to the hook run before =org-cycle=.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-cycle-tab-first . +tempel-expand-interactively)
#+end_src

** Org functions

#+begin_src emacs-lisp
(defun +org-remove-tags ()
  "Remove all tags from current heading."
  (interactive)
  (org-set-tags nil))

(defun *org-list-insert-and-indent (&optional checkbox?)
  "Insert a new row in a list.
Respects current indentation and checkbox."
  (let ((indentation (current-indentation)))
    (org-end-of-item)
    (org-insert-item checkbox?)
    (indent-line-to indentation)
    (end-of-line)
    (evil-insert-state)))

(defun +org-insert-item ()
  "Insert an item determined from context."
  (interactive)
  (cond
   ;; list with checkboxes
   ((org-at-item-checkbox-p) (*org-list-insert-and-indent 'checkbox))
   ;; list without checkboxes
   ((org-at-item-p) (*org-list-insert-and-indent))
   ;; if in a table, break the table at that row
   ;; (since RET jumps to next row, adding one if needed)
   ((org-at-table-p)
    (progn
      (end-of-line)
      (newline)))
   ;; fall back to heading insertion
   (t (org-insert-heading-respect-content))))

(defun +tempel-expand-interactively ()
  "Try to expand a snippet with tempel.
If expansion fails, return nil.
This function is specifically for use with org-cycle."
  (ignore-errors
      (tempel--interactive #'tempel-expand)))
#+end_src

** TODO Org-refile

Found this bit, but it's not working quite the way I'd like it to
(namely, it does not seem to go through consult; maybe that's in consult settings?)
#+begin_src emacs-lisp :tangle no :noweb-ref org-refile
(defun +org-refile-to-current-file ()
  "Refile current heading to elsewhere in the current buffer."
  (interactive)
  (let ((org-refile-targets '((nil :maxlevel . 10)))
        (org-refile-use-outline-path t))
    (call-interactively #'org-refile)))
#+end_src

** Transient navigation

Instead of pressing key combinations or chords repeatedly to navigate,
we can define a transient state and use simple keys while in it.
I got the idea from [[https://github.com/Somelauw/evil-org-mode/blob/master/doc/example_config.el][this evil-org example]] that used hydra,
but I'm using transient because I'm more used to it,
and because it's now built into Emacs (as of 28).

#+begin_src emacs-lisp
(transient-define-prefix +org-movement-transient ()
  ["Moving around in org"
   [("k" "up" org-previous-visible-heading :transient t)
    ("j" "down" org-next-visible-heading :transient t)]
   [("<tab>" "cycle" org-cycle :transient t)
    ("<backtab>" "cycle all" org-shifttab :transient t)]
   [("q" "quit" transient-quit-all)]])
#+end_src

** Pandoc integration

My personal interface to pandoc from Emacs
is written in a [[~/.emacs.d/pandoc.el][separate file]] as a module.
There is a single entry point: a transient function
(aptly named =pandoc-transient=),
which allows the user to interactively
construct a pandoc call, and then executes it.

I might make it into its own package later,
but there is currently no shortage of pandoc APIs for Emacs,
and my version is very much tailored to my personal needs
and those alone.

Here we load the file.
#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "pandoc.el"))
#+end_src

The only keybinding required is for the transient entry point.
#+begin_src emacs-lisp :tangle no :noweb-ref org-keybindings
(evil-define-key 'normal org-mode-map
  (kbd "<localleader>p") #'pandoc-transient)
#+end_src

** Links

#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "links.el"))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-keybindings
(evil-define-key '(normal insert) org-mode-map
  (kbd "C-l") #'+org-link-dwim)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-keybindings
(evil-define-key 'normal org-mode-map
  (kbd "<localleader>l") #'+link-transient)
#+end_src

#+begin_src emacs-lisp
(transient-define-prefix +link-transient ()
  ["Org links"
   ["insert link..."
    ("l" "do-what-i-mean" +org-link-dwim)
    ("c" "from clipboard" +org-insert-link-from-clipboard)
    ("f" "to file" +org-insert-file-path)]
   ["link to org heading..."
    ("h" "with heading text" +org-insert-link)
    ("u" "with a unique ID" +org-insert-link-with-id)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Cross-referencing

#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "refs.el"))
#+end_src

I should think about an insert mode keybinding, too.

#+begin_src emacs-lisp :tangle no :noweb-ref org-keybindings
(evil-define-key 'normal org-mode-map
  (kbd "<localleader>r") #'+ref-transient)
#+end_src

Again, a transient.
Since I'm using transients instead of regular evil keybindings,
I could make capitalization an infix instead of having separate bindings.
Although it's not like I'm running out of keys. Something to ponder.

#+begin_src emacs-lisp
(transient-define-prefix +ref-transient ()
  ["Pandoc cross-references in Org"
   ["insert reference..."
    ("h" "to heading" +ref-insert-ref-heading)
    ("t" "to table" +ref-insert-ref-table)
    ("f" "to figure" +ref-insert-ref-figure)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

* Link hinting

#+begin_src elisp
(use-package link-hint
  :config
  (evil-define-key 'normal 'global
    (kbd "<leader>u") #'link-hint-open-link))
#+end_src

* Magit

#+begin_src emacs-lisp
(use-package magit
  :custom
  (magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
  :config
  (evil-define-key '(normal visual) 'global
   (kbd "<leader>gg") #'magit))
#+end_src

** Git diff highlighting

Changed the settings using [[https://www.reddit.com/r/emacs/comments/582yms/question_changing_the_colour_of_diffhl_indicators/][this discussion]] as a reference.
#+begin_src emacs-lisp
(use-package diff-hl
  :init
  (custom-set-faces
   '(diff-hl-change ((t (:background "orange2" :foreground "orange2"))))
   '(diff-hl-insert ((t (:background "green4" :foreground "green4"))))
   '(diff-hl-delete ((t (:background "red2" :foreground "red2")))))
  (diff-hl-flydiff-mode)
  (global-diff-hl-mode))
#+end_src

* Snippets
:PROPERTIES:
:ID:       0118536f-8f2f-4e6d-ab30-66bd3101401d
:END:
Trying https://github.com/minad/tempel.

#+begin_src elisp :noweb yes
(use-package tempel
  :config <<tempel-keybindings>>)
#+end_src

Once I'm inside a snippet, chances are I no longer need to expand more snippets.
Instead, I want to be able to use TAB to jump to next placeholder,
or move the point after the snippet.

#+begin_src emacs-lisp :tangle no :noweb-ref tempel-keybindings
(define-key tempel-map (kbd "TAB") #'tempel-next)
#+end_src

* Programming

** Lisp
Smartparens is THE package for lisp code editing.
#+begin_src emacs-lisp :noweb yes
(use-package smartparens
  :hook (prog-mode)
  :config
  ;; load default config
  (require 'smartparens-config)
  <<smartparens-keybindings>>)
#+end_src

Examples can be found in the [[https://github.com/Fuco1/smartparens/wiki][wiki]] and in [[https://ebzzry.com/en/emacs-pairs/][this article]].

#+begin_src emacs-lisp :tangle no :noweb-ref smartparens-keybindings
(evil-define-key '(normal visual) emacs-lisp-mode-map
  "(" #'sp-backward-up-sexp
  ")" #'sp-up-sexp)

(evil-define-key 'normal emacs-lisp-mode-map
  (kbd "<localleader>(") #'sp-backward-slurp-sexp
  (kbd "<localleader>)") #'sp-forward-slurp-sexp
  (kbd "<localleader><") #'sp-backward-barf-sexp
  (kbd "<localleader>>") #'sp-forward-barf-sexp
  (kbd "<localleader>w") #'sp-wrap-round)

(evil-define-key 'visual emacs-lisp-mode-map
  "(" #'sp-wrap-round
  ")" #'sp-wrap-round
  "[" #'sp-wrap-square
  "]" #'sp-wrap-square)
#+end_src

* Utils
** Whitespace cleanup
One more package I learned of from Doom's config.

#+begin_src emacs-lisp
(use-package ws-butler
  :init (ws-butler-global-mode 1))
#+end_src
