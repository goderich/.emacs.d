* NEXT Outgoing TODOs

This is actually going quite nicely, but I still need the following:
- Fonts (+variable width for org+, CJK font config)

Other TODOs:
- org-books (maybe migrate to codeberg and rename?)
- [[https://blog.d46.us/advanced-emacs-startup/][how to speed up Emacs startup time]] (already began)

Programming langs and other modes (check my doom/init.el):
- unify smartparens keybindings for lisps
- Elisp
  - macroexpand
- Clojure
- Zig
- Odin
- LSP/treesitter
- YAML
- JSON
- HTML

** Packages
These are some of the packages I should consider:
- Startup screen
  - https://github.com/emacs-dashboard/emacs-dashboard
  - https://github.com/ichernyshovvv/enlight
  - I could also go straight into org-agenda on startup
- https://github.com/alphapapa/org-super-agenda
- https://github.com/jacktasia/dumb-jump for jumping to definition
- https://github.com/jamescherti/inhibit-mouse.el <- completely disable the mouse
- What's the Doom package that shows usage examples in the help menu?
- https://github.com/hlissner/emacs-solaire-mode (necessary? I don't use splits that much)
- https://github.com/edkolev/evil-lion <- not necessary all the time, but nice when needed
- Maybe https://github.com/redguardtoo/evil-nerd-commenter if what I'm using now is insufficient
- https://github.com/kuanyui/tldr.el
- https://github.com/manateelazycat/lsp-bridge <- eglot alternative, advertised as blazingly fast
- https://github.com/flycheck/flycheck
- https://github.com/minad/jinx for spelling
- Think about giving Dired another go
  - Check the [[https://github.com/Fuco1/dired-hacks][dired hacks]] repo for more dired related packages.
- Should also look into terminal emulation in Emacs perhaps. Then again, perhaps not.
- Org-mode:
  - https://github.com/rougier/agenda <- python script, but might be useful?
- Theming:
  - https://github.com/doomemacs/themes
  - https://github.com/rougier/nano-emacs and related packages
  - https://github.com/bbatsov/zenburn-emacs
  - https://github.com/oneKelvinSmith/monokai-emacs
  - https://github.com/kunalb/poet
  - https://github.com/rougier/nano-theme
- https://github.com/Wilfred/deadgrep
- https://github.com/vedang/pdf-tools
- Mail? Consider.
- https://github.com/progfolio/elpaca consider

A few useful packages are mentioned [[https://blog.d46.us/advanced-emacs-startup/][here]] as well.

For more packages see here:
https://github.com/emacs-tw/awesome-emacs

** Resources

I can read other people's configs, not limited to literate ones.
- [[https://github.com/bbatsov/emacs.d/blob/master/init.el][bbatsov's minimalist config]]
- [[https://github.com/hrs/dotfiles/blob/main/emacs/.config/emacs/configuration.org][Great evil-based config]]
- [[https://github.com/zzamboni/dot-emacs/blob/master/init.org][Zzamboni's evil-based config]] prior to his migration to Doom. Lots of org gems there.
- [[https://zzamboni.org/post/my-doom-emacs-configuration-with-commentary/][Zzamboni's Doom config]]
- [[https://github.com/rougier/dotemacs/blob/master/dotemacs.org][Nicholas Rougier's literate config]]
- See [[https://github.com/jschaf/dotfiles/blob/master/emacs/core/abn-core-emacs-settings.el][this config]] (including other files) for some obscure settings and startup hacks.

See [[https://www.reddit.com/r/emacs/comments/9zad13/managing_personal_packages_with_usepackage/][here]] for instructions on how to load local files with =use-package=
(so that they can be deferred, of course)

[[https://github.com/positron-solutions/transient-showcase][transient showcase]]

Some interesting stuff here:
https://github.com/daviwil/emacs-from-scratch

* Basic settings
** NEXT Early loading
Maybe some of this should be in =early-init.el=?
See also https://github.com/hrs/sensible-defaults.el

TODO: see if temp backups can be created somewhere else, e.g. /tmp
(have a look at sensible defaults)

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
(use-package emacs
  :custom
  ;; reduce the frequency of garbage collection by making it happen on
  ;; each 50MB of allocated data (the default is on every 0.76MB)
  (gc-cons-threshold (* 50 1000 1000))
  ;; warn when opening files bigger than 50MB
  (large-file-warning-threshold (* 50 1000 1000))
  ;; do not create backups
  (make-backup-files nil)
  ;; use regular spacing with sentences.
  ;; this is important because it directly impacts sentence motions in evil.
  (sentence-end-double-space nil)
  ;; do not pollute this file with custom variables
  (custom-file "~/.emacs.d/custom.el")
  :config
  (load custom-file)
  ;; do not use tabs for indentation
  (setq-default indent-tabs-mode nil)
  ;; scrolling settings
  (setq scroll-conservatively 200
        scroll-preserve-screen-position 1))
#+end_src

** Package management
Instead of putting =:ensure t= everywhere, I can just set it here once.
(This is not recommended by some.)

#+begin_src elisp
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+end_src

I also turn on the profiler, so that I can see which packages
take the longest amount of time to load
(with the =use-package-report= command)
and see if their loading can be deferred.

#+begin_src emacs-lisp
(setq use-package-compute-statistics t)
#+end_src

See also =use-package-defaults= for other settings.

#+begin_src elisp
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+end_src

** Theming

#+begin_src elisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(display-line-numbers-mode -1)
(tooltip-mode -1)

;; Soft wrap long lines
(global-visual-line-mode 1)

;; Maintain a small margin when scrolling
(setq scroll-margin 2)
#+end_src

I think I'll stick with the solarized-theme package,
but I would like to change a few things.
Look into faces and theming.

#+begin_src emacs-lisp
(use-package solarized-theme
  :config
  (load-theme 'solarized-light t))
#+end_src

** Fonts
Simple font config from [[https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/#h:c7528f3d-9fc8-49e5-9468-6868fb5c07b5][Prot's tutorial]].
Some ideas for font configuration in [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][this blog post]] and [[https://stackoverflow.com/questions/28428382/how-to-manage-fonts-in-emacs][this SO answer]].
[[https://github.com/be5invis/Iosevka][Iosevka]] gets mentioned a lot as a monospace font.
#+begin_src emacs-lisp
(use-package mixed-pitch
  :hook (text-mode . mixed-pitch-mode))

(set-frame-font "Source Code Pro-20")
#+end_src
For CJK fonts specifically, check [[https://www.shimmy1996.com/en/posts/2018-06-24-fun-with-fonts-in-emacs/][this]], or [[https://www.reddit.com/r/emacs/comments/8tz1r0/how_to_set_font_according_to_languages_that_i/e1bjce6/][this snippet]].
Also [[https://coldnew.github.io/d5011be2/][this article]] deals with CJK alignment in org tables.

** Vars

#+begin_src emacs-lisp
(pcase (system-name)
  ;; Laptop
  ("iwaka-thinkpad"
   (setq my/org-directory "~/org"
         my/default-bibliography "~/files/academic/bib/bibliography.bib"
         my/ebib-file-search-dir "~/files/syncthing/papers/ebib"
         my/ebib-import-directory "~/files/syncthing/papers/papers/articles "))

  ;; Office PC
  ("goderich-ncue"
   (setq my/org-directory "~/org"
         my/default-bibliography "~/files/academic/bib/bibliography.bib"
         my/ebib-file-search-dir "~/files/papers/ebib"
         my/ebib-import-directory "~/files/papers/papers/articles"))

  ;; Tablet
  ("goderich-surface"
   (setq my/org-directory "~/org"
         my/default-bibliography "~/academic/bib/bibliography.bib"
         my/ebib-file-search-dir "~/papers/ebib"
         my/ebib-import-directory "~/papers/papers/articles")))
#+end_src

** TODO Utility functions
Should move these under appropriate headings.

#+begin_src emacs-lisp
(defun +consult-goto-org-heading ()
    "Find an org heading in the current buffer, and open it.
`consult-org-heading' doesn't do this automatically for some reason."
    (interactive)
    (consult-org-heading)
    (org-fold-show-context)
    (org-fold-show-entry)
    (org-fold-show-children))

(defun +open-config ()
  (interactive)
  (find-file "~/.emacs.d/config.org"))

(defun +open-org-dir ()
  (interactive)
  (ido-find-file-in-dir "~/org/"))

(defun turn-off-visual-line-mode ()
  (visual-line-mode -1))

(defun turn-on-truncate-lines ()
  (toggle-truncate-lines 1))
#+end_src

* Evil

Check out this great macro for evil keybindings with use-package:
https://www.mattduck.com/2023-08-28-extending-use-package-bind

#+begin_src elisp :noweb yes
(use-package evil
  :init
  ;; for use with evil-collection
  (setq evil-want-keybinding nil)
  (evil-mode 1)
  ;; Sane undo
  (evil-set-undo-system 'undo-fu)

  :bind <<evil-escape>>
  :custom
  (evil-esc-delay 0)
  ;; Substitute with :s globally by default
  (evil-ex-substitute-global t)
  ;; Make evil commands operate on logical, not visual lines
  (evil-respect-visual-line-mode nil)
  ;; Have Y behave like D and C
  (evil-want-Y-yank-to-eol t)
  ;; * and # search for the whole symbol
  (evil-symbol-word-search t)

  :config
  <<evil-cursor>>
  <<evil-keybindings>>
  <<evil-transients>>

  ;; Elisp mode
  (evil-define-key 'normal emacs-lisp-mode-map
    (kbd "<localleader>ee") #'eval-last-sexp))
#+end_src

Maybe use https://github.com/emacs-evil/evil-collection ?
Modules can be loaded incrementally.

For org-mode specifically, https://github.com/Somelauw/evil-org-mode
has some great ideas, which I could take wholesale as a package,
or steal selectively. See the "[[https://github.com/Somelauw/evil-org-mode/blob/master/doc/example_config.el][elaborate setup]]" example.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-cursor
(setq evil-emacs-state-cursor  '("red" box))
(setq evil-normal-state-cursor '("gray" box))
(setq evil-visual-state-cursor '("gray" box))
(setq evil-insert-state-cursor '("gray" bar))
(setq evil-motion-state-cursor '("gray" box))
(blink-cursor-mode -1)
#+end_src

#+begin_src emacs-lisp
(use-package evil-surround
  :ensure t
  :config (global-evil-surround-mode 1))
#+end_src

** Global keybindings
:PROPERTIES:
:ID:       483821dc-9279-4372-93b3-a7f4fa65202e
:END:

*** Escape everything

Make ESC quit everything.
I tried setting this up in the minibuffer to no avail,
and with other keybinding methods and functions,
but it turned out that a simple line with a =use-package= keyword
was all that was needed.
See also [[https://github.com/doomemacs/doomemacs/blob/9c8cfaadde1ccc96a780d713d2a096f0440b9483/lisp/doom-keybinds.el#L81][Doom's ESC function]].

#+begin_src emacs-lisp :tangle no :noweb-ref evil-escape
("<escape>" . keyboard-escape-quit)
#+end_src

Not only that, but when I'm in insert mode and a [[id:2ca8bb84-790f-4e68-8d3d-4893ef154e43][completion]] overlay is active,
or if I'm currently in the middle of inserting a [[id:0118536f-8f2f-4e6d-ab30-66bd3101401d][snippet]],
I want ESC to quit completion or templating *while keeping me in insert mode*.
There does not appear to be a simple way of doing with with settings or hooks,
and evil is greedily capturing keypresses,
so remapping ESC in =corfu-mode= and =tempel-mode= did not work.
During times like these, my solution is a simple wrapper function
that I then bind ESC to globally in insert mode.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(defun +evil-normal-state-maybe ()
  (interactive)
  (cond
   ((and corfu-mode completion-in-region-mode) (corfu-quit))
   (tempel--active (tempel-done))
   (t (evil-normal-state))))

(evil-define-key 'insert 'global (kbd "<escape>") #'+evil-normal-state-maybe)
#+end_src

*** Leader keys

I first encountered the idea of using SPC as the global leader in Spacemacs, and I think it's great.
I use the comma for localleader binds, because in Dvorak it's very conveniently positioned,
and not a great loss in normal mode.
(The lack of =,= in normal mode is remedied by [[id:8c7a6f08-49e4-47c8-acbb-45de731cdb1f][evil-snipe]].)

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-set-leader 'normal (kbd "SPC"))
(evil-set-leader 'normal (kbd ",") 'localleader)
#+end_src

*** M-x (execute-extended-command)

I run commands by name quite a lot, and so to me it makes sense
to bind the command menu to an easily reachable key,
preferably with no modifiers.
Doom has it on =SPC := if I recall correctly.
I think vim's =;= command is not worth an unmodified key,
especially since it is made redundant with [[https://github.com/hlissner/evil-snipe][evil-snipe]].

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key '(normal visual motion) 'global ";" #'execute-extended-command)
#+end_src

*** Line movements (j and k)

I write a lot of prose, and so encounter wrapped lines quite often.
For me, =j= and =k= moving by visual line just makes sense.
=gj= and =gk= bindings are there mostly for macros,
as I don't use them interactively.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key '(normal visual) 'global
  "k"  #'evil-previous-visual-line
  "j"  #'evil-next-visual-line
  "gj" #'evil-next-line
  "gk" #'evil-previous-line)
#+end_src

*** Move to beginning of line (H and ^)

Swapping =H= and =^= is an old vimmer trick.
Since moving to the beginning of the line is arguably a more common action,
it makes sense to place it on the more reachable =H=.
I also augment it with a crux function that jumps to the first non-whitespace char,
and to the first column if pressed again.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key '(normal visual) 'global
  "H"  #'crux-move-beginning-of-line
  "^"  #'evil-window-top)
#+end_src

*** Search at point (* and #)

I use the [[https://github.com/bling/evil-visualstar][evil-visualstar]] package to augment =*= and =#= in visual mode.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key 'visual 'global
  "*" #'evil-visualstar/begin-search-forward
  "#" #'evil-visualstar/begin-search-backward)
#+end_src

*** Incrementing numbers

Incrementing numbers with the [[https://github.com/cofi/evil-numbers][evil-numbers]] package.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key '(normal visual) 'global
  "g="  #'evil-numbers/inc-at-pt
  "g-"  #'evil-numbers/dec-at-pt
  "g+"  #'evil-numbers/inc-at-pt-incremental)
#+end_src

*** Other keybindings

Spacemacs also introduced me to mnemonic keybindings.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key 'normal 'global
  (kbd "<leader>/") #'consult-line
  ;; Files
  (kbd "<leader>.") #'find-file
  (kbd "<leader>f") #'+file-transient
  ;; Buffers
  (kbd "<leader>,") #'consult-buffer
  (kbd "<leader>bq") #'kill-this-buffer
  ;; Windows
  (kbd "<leader>w") #'+window-transient
  ;; Help
  (kbd "<leader>h") #'+helpful-transient
  ;; org
  (kbd "<leader>a") #'org-agenda-list
  ;; links
  (kbd "<leader>u") #'link-hint-open-link
  ;; todo items
  (kbd "]t") #'hl-todo-next
  (kbd "[t") #'hl-todo-previous
  ;; there is also the hl-todo-occur command
  ;; Line comments
  (kbd "gc") #'comment-line
  ;; ebib
  (kbd "<leader>e") #'ebib)
#+end_src

*** Home row mod workaround

I hit =C-a= on my keyboard when typing "ea"
(because of Dvorak + [[https://precondition.github.io/home-row-mods][home row modifiers]]).
In evil insert mode, it pastes the last insertion my default.
In regular Emacs keybindings, it goes to the beginning of the line.
Neither is worth keeping if it leads to borking up my typing.
The two need to be disabled separately.
#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key 'insert 'global (kbd "C-a") nil)
(keymap-global-unset "C-a")
#+end_src

** Packages
*** Evil collection

I'm on the fence about pulling all of [[https://github.com/emacs-evil/evil-collection][evil-collection]] for just a few modes,
so I'm trying it out for now. Can always copy/rewrite myself later.
Consider also modes: [[https://github.com/emacs-evil/evil-collection/blob/master/modes/macrostep/evil-collection-macrostep.el][macrostep]], [[https://github.com/emacs-evil/evil-collection/tree/master/modes/smerge-mode][smerge]], calendar (?), calc
Note that evil-collection does not include bindings for org-agenda

#+begin_src emacs-lisp
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init '(ebib magit info)))
#+end_src

*** TODO Undo
See also Hints and undo-fu-session [[https://codeberg.org/ideasman42/emacs-undo-fu][here]].
Can also try [[https://github.com/casouri/vundo][vundo]], although my undo needs aren't that sophisticated.

#+begin_src emacs-lisp
(use-package undo-fu)
#+end_src

*** Evil-snipe
:PROPERTIES:
:ID:       8c7a6f08-49e4-47c8-acbb-45de731cdb1f
:END:

Sniping is an incredibly efficient way to move around nearby text.

#+begin_src emacs-lisp :noweb yes
(use-package evil-snipe
  :after evil
  :init
  (evil-snipe-mode 1)
  (evil-snipe-override-mode 1)
  :config
  <<evil-snipe-settings>>)
#+end_src

I like to have evil-snipe capture f/F/t/T for its own use,
so I turn on =evil-snipe-override-mode=.
This way, I can use these keys to jump to the next occurrence
of the searched character.
However, I do *not* want evil-snipe to steal my =,= and =;= keys,
even in a transient mode after a snipe.
They are my =localleader= and execute command keys, respectively,
and I want them to be available at all times.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-snipe-settings
(keymap-set evil-snipe-parent-transient-map "," nil)
(keymap-set evil-snipe-parent-transient-map ";" nil)
#+end_src

By default, snipe searches only on the current line.
I think it's a waste of potential,
since it can replace some =/= searches on adjacent lines as well.
I make the repeat scope broader, in case I want to search backwards as well.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-snipe-settings
(setq evil-snipe-scope 'visible)
(setq evil-snipe-repeat-scope 'whole-visible)
#+end_src

There are also some places where evil-snipe doesn't make sense,
but its high priority means it would capture keys even if I map them elsewhere.
In these modes, I turn it off.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-snipe-settings
(dolist (it '(ebib-index-mode ebib-entry-mode))
  (push it evil-snipe-disabled-modes))
#+end_src

*** Evil-visualstar

This tiny package allows =*= and =#= to be usable in visual mode.
Instead of evil's default behaviour, which is to search for the word at point,
whatever that may be, these commands search for the selection.
The package also takes care of search history.
I do not use the package's own setup,
and instead rely on use-package's autoload functionality.
The keybindings are get in [[id:483821dc-9279-4372-93b3-a7f4fa65202e][the global keybinds section]].

#+begin_src emacs-lisp
(use-package evil-visualstar
  :commands (evil-visualstar/begin-search-forward
             evil-visualstar/begin-search-forward))
#+end_src

*** Evil-numbers

Another small package, this time to manipulate numbers.
I occasionally find myself needing to add/subtract a sum
from numbers on a bunch of lines, so this is handy for those situations.

#+begin_src emacs-lisp
(use-package evil-numbers
  :commands (evil-numbers/inc-at-pt
             evil-numbers/dec-at-pt
             evil-numbers/inc-at-pt-incremental
             evil-numbers/dec-at-pt-incremental))
#+end_src

** Minibuffer keybindings

Keybindings in the minibuffer have to be set differently.
I am not using evil in the minibuffer, and the bindings
have to be set up using a hook each time.

I went through this trouble to replicate Doom's behaviour
when pressing backspace in the minibuffer.
It works as normal when typing the name of a file,
but if you keep deleting, the parent directories will be deleted
with a single press of backspace.
This is pretty convenient when jumping upwards many levels.

Right now my implementation is still relatively naive,
and I'm still in the process of refining it.

#+begin_src emacs-lisp
(defun +delete-char-or-directory ()
  (interactive)
  (cond
   ((string= (minibuffer-contents) "/")
    (delete-backward-char 1))
   ((string= (minibuffer-contents) "~/")
    (delete-minibuffer-contents)
    (insert (expand-file-name "~/")))
   ((eq (char-before) ?/)
    (let ((pt (point))
          (slash-pos (search-backward "/" nil t 2)))
      (if slash-pos
          (progn
            (delete-region (1+ slash-pos) pt)
            (move-end-of-line nil))
        (delete-backward-char 1))))
   (t (delete-backward-char 1))))

(defun +minibuffer-setup ()
  (keymap-set minibuffer-local-map "<backspace>" #'+delete-char-or-directory)
  (keymap-set minibuffer-local-map "C-w" #'backward-kill-word)
  (keymap-set minibuffer-local-map "C-<return>" #'vertico-exit-input))

(add-hook 'minibuffer-setup-hook #'+minibuffer-setup)
#+end_src

** Transient commands
*** Window resizing transient

#+begin_src emacs-lisp :tangle no :noweb-ref evil-transients
(transient-define-prefix +window-transient ()
  ["Resizing windows"
   ["Transient"
    ("b" "bigger" enlarge-window :transient t)
    ("s" "smaller" shrink-window :transient t)
    ("=" "balance" balance-windows :transient t)]
   ["Non-transient"
    ("d" "delete" delete-window)
    ("w" "other" other-window)
    ("m" "maximize" delete-other-windows)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

*** File transient

#+begin_src emacs-lisp :tangle no :noweb-ref evil-transients
(transient-define-prefix +file-transient ()
  ["File commands"
   ["With this file..."
    ("s" "save" save-buffer)
    ("D" "delete" crux-delete-file-and-buffer)
    ("u" "sudo edit" crux-sudo-edit)]
   ["Open..."
    ("r" "recent file" recentf)
    ("o" "org directory" +open-org-dir)
    ("c" "config.org" +open-config)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

* Narrowing and completion
** Narrowing

TODO: There is a lot of functionality here, I should explore it.
https://github.com/minad/consult
#+begin_src emacs-lisp
(use-package consult)

(use-package vertico
  ;; :custom
  ;; (vertico-scroll-margin 0) ;; Different scroll margin
  ;; (vertico-count 20) ;; Show more candidates
  ;; (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
  ;; (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
  :init (vertico-mode))

;; Persist history over Emacs restarts.
(use-package savehist
  :init (savehist-mode))

(use-package orderless
  :custom
  (completion-styles '(orderless basic))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles partial-completion)))))

;; Documentation in M-x and minibuffers
(use-package marginalia
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  ;; :bind (:map minibuffer-local-map
  ;;        ("M-A" . marginalia-cycle))

  :init (marginalia-mode))

;; Do not delay which-key (delay has to be above zero)
(use-package which-key
  :init (which-key-mode)
  :config
  (setq which-key-idle-delay 1)
  (setq which-key-idle-secondary-delay 0.05))
#+end_src

There is also https://github.com/oantolin/embark/,
but I haven't learned how to use it properly.

** Completion
:PROPERTIES:
:ID:       2ca8bb84-790f-4e68-8d3d-4893ef154e43
:END:

Using [[https://github.com/minad/corfu][Corfu]].

I do NOT normally want completion on in org, because that's distracting.
I do want completion when programming, and I want it to open up automatically.

Trying out SPC as separator:
pressing space does not exit completion, but instead begins a second chunk.
This makes corfu work a lot like consult et al,
where a search string can be entered using space-separated pieces.

#+begin_src emacs-lisp
(use-package corfu
  :hook ((prog-mode . corfu-mode))
  :custom
  (corfu-auto t)
  (corfu-quit-no-match t)
  :bind (:map corfu-map
              ("TAB" . corfu-expand)
              ("SPC" . corfu-insert-separator)))
#+end_src

* Org-mode

- Sacha Chua also has an [[https://sachachua.com/blog/2024/01/using-consult-and-org-ql-to-search-my-org-mode-agenda-files-and-sort-the-results-to-prioritize-heading-matches/][interesting use]] of org-ql.

Note that since I am using a literate config
and loading it with org-babel from my =init.el=,
I cannot defer loading org-mode at startup.
It's not a huge penalty though,
and I feel the convenience outweighs it.

#+begin_src emacs-lisp :noweb yes
(use-package org
  :init <<org-init>>
  :hook <<org-hooks>>
  :config
  <<org-settings>>
  <<org-src-settings>>
  <<org-functions>>
  <<org-keybindings>>
  <<org-agenda>>
  <<org-navigation-transient>>
  <<org-modules>>)
#+end_src

** Org settings

Enable indentation in org-mode.
#+begin_src emacs-lisp :tangle no :noweb-ref org-init
(setq org-startup-indented t)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-tags-column 0)
#+end_src

One of the many things I liked about Doom was the TODO settings.
Fast TODO selection was on by default, which I think is a great idea
if you are using more keywords than just TODO and DONE.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-use-fast-todo-selection t)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
;; (setq org-tag-faces (:foreground "blue" :weight normal))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
;; Set org file associations
(setq org-file-apps
      `((auto-mode . emacs)
        (,(rx ".pdf::" (group (one-or-more digit)) string-end) . "zathura %s -P %1")
        (,(rx ".pdf" string-end) . "zathura %s")
        (directory . emacs)))

;; browser needs to be set with a separate function
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "qutebrowser")

;; Don't use blank lines between text and the following heading
(setq org-blank-before-new-entry
      '((heading . nil) (plain-list-item . nil)))

;; Don't show empty lines between collapsed headings
(setq org-cycle-separator-lines 0)

;; Show tooltips.
;; I am using this for displaying org link paths.
;; This may not be the best use of the fns though,
;; and I have an alternative implementation.
(setq help-at-pt-display-when-idle t
      help-at-pt-timer-delay 0.1)
(help-at-pt-set-timer)

;; Org todo keywords and colours
(setq org-todo-keywords
      '((sequence "TODO(t)" "|" "DONE(d)")
        (sequence "NEXT(n)" "WAITING(w)" "LATER(l)" "LOOP(p)" "|" "CANCELLED(c)")))

;; Use LOOP keyword for repeating tasks
;; (after marking them as done)
(setq org-todo-repeat-to-state "LOOP")

;; Archive everything from org files in one directory
;; into a single hidden file.
(setq org-archive-location ".archive.org::")

;; My custom faces for todo items. I'm reusing most from Doom.
(with-no-warnings
  (custom-declare-face '+org-todo-important '((t (:inherit (bold default)))) ""))

;; In the datetime prompt, if entering a time that has already
;; passed today, interpret it as a time for tomorrow.
(setq org-read-date-prefer-future 'time)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-src-settings
(setq org-edit-src-content-indentation 0)
(setq org-confirm-babel-evaluate nil)
#+end_src


** Org keybindings

Note that some keybindings are set in their respective modes.
They still appear together in the final tangled file.

#+begin_src emacs-lisp :tangle no :noweb-ref org-keybindings
(evil-define-key '(normal visual) org-mode-map
  (kbd "<tab>") #'org-cycle
  (kbd "<return>") #'+org-return
  (kbd "<localleader>,") #'org-ctrl-c-ctrl-c
  (kbd "<localleader>s") #'org-edit-src-code
  (kbd "<localleader>t") #'org-todo
  (kbd "<localleader>dd") #'org-deadline
  (kbd "<localleader>ds") #'org-schedule
  (kbd "<localleader>dt") #'org-time-stamp
  (kbd "<localleader>S") #'org-sparse-tree
  (kbd "<localleader>q") #'org-set-tags-command
  (kbd "<localleader>Q") #'+org-remove-tags
  (kbd "<localleader>.") #'+consult-goto-org-heading
  (kbd "gh") #'+org-up-heading)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-keybindings
(evil-define-key '(normal insert) org-mode-map
  (kbd "C-l") #'+org-link-dwim
  (kbd "C-c") #'ebib-insert-citation)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-keybindings
(evil-define-key 'normal org-mode-map
  (kbd "<localleader>l") #'+link-transient)
#+end_src

Some keybindings, namely ones using a modifier key,
should be accessible in both normal and insert modes.
#+begin_src emacs-lisp :tangle no :noweb-ref org-keybindings
(evil-define-key '(normal insert) org-mode-map
  (kbd "M-h") #'org-metaleft
  (kbd "M-j") #'org-metadown
  (kbd "M-k") #'org-metaup
  (kbd "M-l") #'org-metaright
  (kbd "M-H") #'org-shiftmetaleft
  (kbd "M-J") #'org-shiftmetadown
  (kbd "M-K") #'org-shiftmetaup
  (kbd "M-L") #'org-shiftmetaright
  (kbd "C-<return>") #'+org-insert-item)
#+end_src

From evil-org, use evil bindings in source and table editing modes:
#+begin_src emacs-lisp :tangle no :noweb-ref org-keybindings
(with-eval-after-load 'org-src
  (define-key org-src-mode-map [remap evil-save-and-close]          'org-edit-src-exit)
  (define-key org-src-mode-map [remap evil-save-modified-and-close] 'org-edit-src-exit)
  (define-key org-src-mode-map [remap evil-quit]                    'org-edit-src-abort))
#+end_src

Binding to =org-cycle= (usually TAB)
or =org-ctrl-c-ctrl-c= (mine is =,,= instead)
does not follow the usual procedure.
Because these keys are context-dependent to begin with,
it's generally not a good idea to rebind them completely,
since you might screw up additional contexts
you didn't even realize were there before rebinding.
Instead, additional functionality is added via hooks
which are run before the main body of the function.
If any of the functions returns a non-nil value,
the main body is run instead.
It's the next best thing to a =cond= in the function itself.

Trying to bind tempel's expansion to TAB was a tad involved.
The expansion function returns a non-nil value even when it fails,
and the =tempel-expand= function by itself does not expand
when run programmatically.
I ended up writing a small wrapper function that returns nil
if an expansion fails, so that the hook can successfully fall through.
(See [[Org functions][Org functions]].)
Here I just add the function to the hook run before =org-cycle=.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-cycle-tab-first . +tempel-expand-interactively)
#+end_src

** Org agenda

#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda
(setq org-agenda-files (list org-directory))

(setq org-agenda-window-setup 'only-window)

;; Display one week, always starting from Monday.
(setq org-agenda-span 'week
      org-agenda-start-on-weekday 1
      org-agenda-start-day ".")

;; Show full context after switching to an item from agenda
(map-put! org-fold-show-context-detail 'agenda 'tree)
;; shold this be in agenda settings?
(map-put! org-fold-show-context-detail 'default 'tree)
#+end_src

There are no bindings for agenda in evil-collection,
so I had a choice between pulling another package and rolling my own.
I went with the DIY option, but took some inspiration from [[https://github.com/Somelauw/evil-org-mode/blob/master/evil-org-agenda.el][evil-org]] in setting up mine.

#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda
(evil-set-initial-state 'org-agenda-mode 'motion)

(evil-define-key 'motion org-agenda-mode-map
  "b" #'org-agenda-earlier
  "f" #'org-agenda-later
  "(" #'org-agenda-earlier
  ")" #'org-agenda-later
  "u" #'link-hint-open-link
  ;; :prefix ("v" . "switch view...")
  "vw" #'org-agenda-week-view
  "vm" #'org-agenda-month-view
  ;; bit different behaviour from link-hint
  (kbd "<return>") #'org-agenda-goto)
#+end_src

** TODO Org-modern bling

Just tried this out on the Surface go, and it isn't slow at all.
I think I'll keep using this package,
but I'll need to research the settings some more.
https://github.com/minad/org-modern

#+begin_src emacs-lisp
(use-package org-modern
  :hook org-mode
  :config
  (setq org-modern-todo nil
        org-modern-table nil))
#+end_src

** Transient navigation

Instead of pressing key combinations or chords repeatedly to navigate,
we can define a transient state and use simple keys while in it.
I got the idea from [[https://github.com/Somelauw/evil-org-mode/blob/master/doc/example_config.el][this evil-org example]] that uses hydra,
but I'm using transient because I'm more used to it,
and because it's now built into Emacs (as of 28).

#+begin_src emacs-lisp :tangle no :noweb-ref org-navigation-transient
(defmacro with-org-show (&rest body)
  `(progn
     ,@body
     (evil-scroll-line-to-top nil)
     (org-fold-show-entry)
     (org-fold-show-children)))

;; This is not in the transient, move out
(defun +org-up-heading ()
  "Go up to the nearest heading, or to a higher level heading.
If not on a heading, finds the next heading backwards.
If already on a heading, goes higher up in the tree. This
makes sense to me to combine into a single keybinding."
  (interactive)
  (if (org-at-heading-p)
      (org-up-element)
    (org-back-to-heading)))

(defun +org-up-level-and-show ()
  (interactive)
  (with-org-show
   (org-up-heading-safe)))

(defun +org-down-and-show ()
  (interactive)
  (with-org-show
   (org-next-visible-heading 1)))

(defun +org-up-same-level ()
  (interactive)
  (with-org-show
   (org-fold-hide-subtree)
   (org-backward-heading-same-level 1 t)))

(defun +org-down-same-level ()
  (interactive)
  (with-org-show
   (org-fold-hide-subtree)
   (org-forward-heading-same-level 1 t)))

;; added SPC scrolling, but need to add `org-back-to-heading' to h/k
;; add link-hint on u?
(transient-define-prefix +org-movement-transient ()
  ["Moving around in org"
   [("h" "up level" +org-up-level-and-show :transient t)
    ("k" "up (same level)" +org-up-same-level :transient t)
    ("j" "down (same level)" +org-down-same-level :transient t)
    ("l" "down level" +org-down-and-show :transient t)]
   [("<tab>" "cycle" org-cycle :transient t)
    ("<backtab>" "cycle all" org-shifttab :transient t)
    ("<SPC>" "scroll down" evil-scroll-down :transient t)]
   [("q" "quit" transient-quit-all)]])
#+end_src

** Pandoc integration

My personal interface to pandoc from Emacs
is written in a [[./pandoc.el][separate file]] as a module.
There is a single entry point: a transient function
(aptly named =pandoc-transient=),
which allows the user to interactively
construct a pandoc call, and then executes it.

I might make it into its own package later,
but there is currently no shortage of pandoc APIs for Emacs,
and my version is very much tailored to my personal needs
and those alone.

Here we load the file.
#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "pandoc.el"))
#+end_src

The only keybinding required is for the transient entry point.
#+begin_src emacs-lisp :tangle no :noweb-ref org-keybindings
(evil-define-key 'normal org-mode-map
  (kbd "<localleader>p") #'pandoc-transient)
#+end_src

** Links

#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "links.el"))
#+end_src

#+begin_src emacs-lisp
(transient-define-prefix +link-transient ()
  ["Org links"
   ["insert link..."
    ("l" "do-what-i-mean" +org-link-dwim)
    ("c" "from clipboard" +org-insert-link-from-clipboard)
    ("f" "to file" +org-insert-file-path)]
   ["link to org heading..."
    ("h" "with heading text" +org-insert-link)
    ("u" "with a unique ID" +org-insert-link-with-id)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Link path tooltip

Usually, we hide link URLs and display just the description.
Doom Emacs shows a link URL tooltip in the echo area,
similar to how eldoc shows the documentation for the function at point.
That's pretty neat functionality, but it was surprisingly difficult to search for online.
I found no discussions or questions about this sort of feature.

This is a relatively simple implementation.
The function itself checks if the point is in a link regex, and if it is,
displays the first group (the URL) as a message.
I then hook it up to =post-command-hook= *locally*,
so that it only works in org-mode.

I currently have it *turned off* because I'm using =help-at-pt-set-timer=
(NB: check source of the fn, see also [[info:elisp#Idle Timers][info node]]).
However, my approach is more flexible, and I might want to come back to it.

#+begin_src emacs-lisp :tangle no
(defun +org-link-tooltip ()
  "Display the URL of the link at point in the echo area."
  (interactive) ; for testing purposes only
  (when (org-in-regexp org-link-bracket-re)
    (message "Link: %s" (match-string 1))))

(add-hook 'org-mode-hook
          (lambda ()
            (add-hook 'post-command-hook #'+org-link-tooltip 0 'local)))
#+end_src

** Cross-referencing

#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "refs.el"))
#+end_src

I should think about an insert mode keybinding, too.

#+begin_src emacs-lisp :tangle no :noweb-ref org-keybindings
(evil-define-key 'normal org-mode-map
  (kbd "<localleader>r") #'+ref-transient)
#+end_src

Again, a transient.
Since I'm using transients instead of regular evil keybindings,
I could make capitalization an infix instead of having separate bindings.
Although it's not like I'm running out of keys. Something to ponder.

#+begin_src emacs-lisp
(transient-define-prefix +ref-transient ()
  ["Pandoc cross-references in Org"
   ["insert reference..."
    ("h" "to heading" +ref-insert-ref-heading)
    ("t" "to table" +ref-insert-ref-table)
    ("f" "to figure" +ref-insert-ref-figure)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Org cite

#+begin_src emacs-lisp :tangle no :noweb-ref org-cite
(defun +ebib-open-on-citation (citation _)
  (let ((key (map-elt (cadr citation) :key)))
    (ebib)
    (ebib-db-set-current-entry-key key ebib--cur-db)
    (ebib--update-buffers 'no-refresh)))

(org-cite-register-processor '+org-cite-follow-processor
  ;; Note that the citation is passed as an object, not a string.
  ;; The follow function must take two arguments.
  ;; See `org-cite-register-processor' documentation for details.
  :follow #'+ebib-open-on-citation)

(setq org-cite-global-bibliography (list my/default-bibliography))
(setq org-cite-follow-processor '+org-cite-follow-processor)
#+end_src

** Org functions

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-remove-tags ()
  "Remove all tags from current heading."
  (interactive)
  (org-set-tags nil))

(defun *org-list-insert-and-indent (&optional checkbox?)
  "Insert a new row in a list.
Respects current indentation and checkbox."
  (let ((indentation (current-indentation)))
    (end-of-line)
    (org-insert-item checkbox?)
    (indent-line-to indentation)
    (end-of-line)
    (evil-insert-state)))

(defun +org-insert-item ()
  "Insert an item determined from context."
  (interactive)
  (cond
   ;; list with checkboxes
   ((org-at-item-checkbox-p) (*org-list-insert-and-indent 'checkbox))
   ;; list without checkboxes
   ((org-at-item-p) (*org-list-insert-and-indent))
   ;; if in a table, break the table at that row
   ;; (since RET jumps to next row, adding one if needed)
   ((org-at-table-p)
    (progn
      (end-of-line)
      (newline)))
   ;; fall back to heading insertion
   (t (org-insert-heading-respect-content))))

(defun +tempel-expand-interactively ()
  "Try to expand a snippet with tempel.
If expansion fails, return nil.
This function is specifically for use with org-cycle."
  (ignore-errors
      (tempel--interactive #'tempel-expand)))
#+end_src

*** My version of org-return

I believe org-mode first started the fashion of
contextually dependent actions in Emacs (aka "dwim").
Then Doom took it and expanded it further.
The idea is great, and here I put my own spin on it.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-return ()
  "Perform an action dependent on context.
If on a...
- list item with checkbox: toggle checkbox.
- table: move to next row, possibly creating one (jump out of table with =C-RET=).
- image or image link: toggle displaying the image.
- citation: open in ebib.
- URL: open it.
- org link: follow it.
- source block: edit it (run block with =,,=).
"
  (interactive)
  (cond
   ;; list with checkbox
   ((org-at-item-checkbox-p) (org-toggle-checkbox))
   ;; table
   ((org-at-table-p) (org-table-next-row))
   ;; image
   ((when-cond ((bounds (org-in-regexp *org-image-regexp)))
      (*org-toggle-image (car bounds) (cdr bounds))))
   ;; citation
   ((when-cond ((bounds (org-in-regexp *org-cite-regexp)))
      (*org-follow-cite (car bounds) (cdr bounds))))
   ;; a regular URL string with no description
   ((when-cond ((bounds (org-in-regexp *url-regexp))
                (url (buffer-substring-no-properties (car bounds) (cdr bounds))))
      (browse-url url)))
   ;; an org link of any kind, including URLs with descriptions
   ((org-in-regexp org-link-bracket-re) (link-hint-open-link-at-point))
   ;; org-src block
   ((org-in-src-block-p) (org-edit-src-code))
   ;; Default action
   (t (evil-ret))))

(defmacro when-cond (spec &rest body)
  "Like `when-let', but returns true on successful binding.
For use inside `cond'."
  (declare (indent 1) (debug if-let))
  `(if-let ,spec ,(macroexp-progn (append body (list t)))))

(defun *org-follow-cite (beg end)
  (let* ((keys (->> (buffer-substring-no-properties beg end)
                    (s-match-strings-all *org-cite-key-regexp)
                    (-map #'-second-item))))
    (pcase (length keys)
      (0 (user-error "No keys found!"))
      (1 (+ebib-open-on-key (car keys)))
      (_ (let ((key (completing-read "Choose key to open: " keys)))
           (+ebib-open-on-key key))))))

(defvar *org-cite-regexp
  (rx (seq "[cite"
           (opt ?/ (one-or-more (any alnum ?/ ?_ ?-)))
           ":" (zero-or-more (not (any ?\[ ?\]))) "]")))

(defvar *org-cite-key-regexp
  (rx (seq "@" (group (one-or-more (or alnum ?- ?_))))))

(defun +ebib-open-on-key (key)
  (ebib)
  (ebib-db-set-current-entry-key key ebib--cur-db)
  (ebib--update-buffers 'no-refresh))

(defun *org-toggle-image (beg end)
  (org-toggle-inline-images nil beg end))

(defvar *org-image-regexp
  (rx (seq "[[./" (+? anything) "." (or "png" "jpg" "jpeg") "]]")))

(defvar *url-regexp
  (concat "\\<"
          (regexp-opt '("http://" "https://" "doi:") t)
          thing-at-point-url-path-regexp)
  "Basically a simplified version of `goto-address-url-regxp'")
#+end_src

** Org-refile

This bit of code works. I should test it more.
Right now it does not move the pointer after refiling.
Do I want to move to the new position? Depends.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-refile-to-this-file ()
  (interactive)
  (let* ((loc-pair (save-excursion
                     (consult-org-heading)
                     (cons (org-get-heading) (point))))
         (heading (car loc-pair))
         (location (cdr loc-pair)))
    (org-refile nil
                (current-buffer)
                (list heading (buffer-file-name) nil location))))
#+end_src

* Bibliography and citations

** Ebib

TODOs:
- disabled notes for now, figure out later

#+begin_src emacs-lisp :noweb yes
(use-package ebib
  :commands (ebib ebib-insert-citation)
  :config
  <<ebib-functions>>
  <<ebib-settings>>
  <<ebib-keybindings>>)
#+end_src

*** Settings

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-settings
(setq ebib-preload-bib-files (list my/default-bibliography))
;; (setq ebib-notes-directory my/ebib-notes)
(setq ebib-file-search-dirs (list my/ebib-file-search-dir))
(setq ebib-import-directory my/ebib-import-directory)
(setq ebib-file-associations '(("pdf" . "zathura") ("ps" . "gv")))
(setq ebib-bibtex-dialect 'biblatex)
(setq ebib-citation-insert-multiple t)
(setq ebib-index-columns '(("Author/Editor" 20 t)
                           ("Year" 6 t)
                           ("Title" 40 t)))
(map-put! ebib-reference-templates
          "Article"
          "{Author}. {Date|Year}. {\"Title\".} {Journaltitle|Journal} {Volume}{(Issue)}{:Pages}.{ Doi.}")
(map-put! ebib-reference-templates
          "Book"
          "{Author|Editor}. {Date|Year}. {\"Title\".} {Address: }{Publisher.}")
(setq ebib-notes-name-transform-function #'identity)
(setq ebib-name-transform-function #'+ebib-generate-filename)

;; Set auto-generated citation key options
(setq bibtex-autokey-year-length 4
      bibtex-autokey-titleword-length 0
      bibtex-autokey-name-separator "-"
      bibtex-autokey-year-title-separator ""
      bibtex-autokey-edit-before-use t)
(setq ebib-uniquify-keys t)

(map-put! ebib-citation-commands
          'org-mode
          '((("text" "[cite/t: %(@%K%< %A%>%; )]")
             ("paren" "[cite: %(@%K%< %A%>%; )]")
             ("bare" "@%K")
             ("no-name" "[cite/na: %(@%K%< %A%>%; )]"))))
(map-put! ebib-citation-commands
          'markdown-mode
          '((("text" "@%K%< [%A]%>")
             ("paren" "[%(@%K%<, %A%>%; )]")
             ("year" "[-@%K%< %A%>]"))))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-settings
(add-hook 'ebib-index-mode-hook #'turn-on-truncate-lines)
(add-hook 'ebib-index-mode-hook #'turn-off-visual-line-mode)
#+end_src

*** Functions

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-functions
(defun *ebib-get-author-names (key)
  (let ((names
         (->>
          (ebib-get-field-value "author" key ebib--cur-db "default" 'unbraced)
          (s-split " and ")
          (--map (car (s-split "," it))))))
    (if (< 2 (length names))
        (concat (car names) " et al")
      (s-join " and " names))))

(defun *ebib-get-year (key)
  (let ((date
         (or
          (ebib-get-field-value "date" key ebib--cur-db 'noerror 'unbraced)
          (ebib-get-field-value "year" key ebib--cur-db 'noerror 'unbraced))))
    (->> date
         (s-split "-")
         (-first-item))))

(defun *ebib-get-title (key)
  (let ((title
         (->> (ebib-get-field-value "title" key ebib--cur-db "default" 'unbraced)
              (s-split ":")
              (car)
              (replace-regexp-in-string "[{}]" "")
              (s-trim))))
    (s-truncate 100 title "")))

(defun +ebib-generate-filename (key)
  (let ((names (*ebib-get-author-names key))
        (year (*ebib-get-year key))
        (title (*ebib-get-title key)))
    (->> (list names year title)
         (-non-nil)
         (s-join " ")
         (replace-regexp-in-string "/" "")
         (replace-regexp-in-string "," "")
         (replace-regexp-in-string " " "_"))))

(defun +ebib-edit-as-string ()
  "Edit the current field as a string.
This is a function for `ebib-entry-mode'. Since `ebib-edit-field'
has to take a numeric prefix /= 1 in order to begin string
editing, it seems easier to abstract this into a function and
give it its own name and keybinding."
  (interactive)
  (ebib-edit-field 2))

(defun +ebib-import-file-from-index ()
  "Import a file and add to the entry at point.
Used from the ebib index."
  (interactive)
  (ebib-edit-entry)
  (ebib-import-file nil)
  (ebib-quit-entry-buffer))
#+end_src

*** Keybindings

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-keybindings
(evil-define-key 'normal ebib-index-mode-map
  "q" #'ebib-quit
  "s" #'ebib-save-current-database
  "S" #'ebib-save-all-databases
  "/" #'ebib-jump-to-entry
  (kbd "<tab>") #'ebib-edit-entry
  (kbd "<localleader>f") #'+ebib-import-file-from-index)

;; Unset N while I'm figuring out what to do with notes.
(keymap-unset ebib-index-mode-map "N")

(evil-define-key 'normal ebib-entry-mode-map
  "q" #'ebib-quit
  "z" #'ebib-leave-ebib-windows
  "E" #'+ebib-edit-as-string
  "s" #'ebib-save-current-database
  "S" #'ebib-save-all-databases
  "D" #'ebib-delete-current-field-contents
  (kbd "<tab>") #'ebib-quit-entry-buffer
  (kbd "<localleader>f") #'ebib-import-file)
#+end_src

* Programming languages

** Lisps
Smartparens is THE package for lisp code editing.
#+begin_src emacs-lisp :noweb yes
(use-package smartparens
  :hook (prog-mode) ;; should probably narrow it down to lisps
  :config
  ;; load default config
  (require 'smartparens-config)
  <<smartparens-keybindings>>)
#+end_src

#+begin_src emacs-lisp
(use-package eros
  :hook emacs-lisp-mode)
#+end_src

Examples can be found in the [[https://github.com/Fuco1/smartparens/wiki][wiki]] and in [[https://ebzzry.com/en/emacs-pairs/][this article]].

** Emacs Lisp

#+begin_src emacs-lisp
(use-package eldoc
  :config
  (setq eldoc-idle-delay 0))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref smartparens-keybindings
(evil-define-key '(normal visual) emacs-lisp-mode-map
  "(" #'sp-backward-up-sexp
  ")" #'sp-up-sexp)

(evil-define-key 'normal emacs-lisp-mode-map
  (kbd "<localleader>(") #'sp-backward-slurp-sexp
  (kbd "<localleader>)") #'sp-forward-slurp-sexp
  (kbd "<localleader><") #'sp-backward-barf-sexp
  (kbd "<localleader>>") #'sp-forward-barf-sexp
  (kbd "<localleader>w") #'sp-wrap-round
  (kbd "<localleader>e") #'+elisp-eval-transient)

(evil-define-key 'visual emacs-lisp-mode-map
  "(" #'sp-wrap-round
  ")" #'sp-wrap-round
  "[" #'sp-wrap-square
  "]" #'sp-wrap-square)
#+end_src

#+begin_src emacs-lisp
(transient-define-prefix +elisp-eval-transient ()
  ["Eval..."
   ("e" "last sexp" eval-last-sexp)
   ("r" "and replace" crux-eval-and-replace)
   ("b" "buffer" eval-buffer)])
#+end_src

** Clojure

See also the following:
- [[https://github.com/clojure-emacs/clojure-mode/][clojure-mode]]
- [[https://github.com/clojure-emacs/cider][cider]]
- [[https://github.com/clojure-emacs/clj-refactor.el][clj-refactor]]
- [[https://docs.doomemacs.org/latest/modules/lang/clojure/][clojure doom module]]

#+begin_src emacs-lisp
(use-package clojure-mode
  :defer t
  :config
  (evil-define-key 'normal clojure-mode-map
    (kbd "<localleader>'") #'cider-jack-in))
#+end_src

#+begin_src emacs-lisp
(use-package cider
  :commands (cider-jack-in cider-jack-in-clj cider-jack-in-cljs)
  :config
  (setq cider-allow-jack-in-without-project t
        cider-jack-in-default 'babashka
        cider-repl-pop-to-buffer-on-connect nil)

  (evil-define-key 'normal cider-mode-map
    (kbd "<localleader>ee") #'cider-eval-last-sexp
    (kbd "<localleader>pp") #'cider-pprint-eval-last-sexp-to-comment
    (kbd "<localleader>(") #'sp-backward-slurp-sexp
    (kbd "<localleader>)") #'sp-forward-slurp-sexp
    (kbd "<localleader>rq") #'cider-quit))
#+end_src

* Utils
** Magit

Consider also [[https://github.com/alphapapa/magit-todos][magit-todos]].

#+begin_src emacs-lisp
(use-package magit
  :commands (magit)
  :init
  (evil-define-key '(normal visual) 'global
    (kbd "<leader>gg") #'magit)
  :config
  (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1))
#+end_src

*** Git diff highlighting

Changed the settings using [[https://www.reddit.com/r/emacs/comments/582yms/question_changing_the_colour_of_diffhl_indicators/][this discussion]] as a reference.
#+begin_src emacs-lisp :noweb yes
(use-package diff-hl
  :defer 2
  :config
  <<diff-hl-colors>>
  (diff-hl-flydiff-mode)
  (global-diff-hl-mode)
  <<diff-hl-keybindings>>)
#+end_src

I stole the insert and delete shades from Doom, because they look really good.

#+begin_src emacs-lisp :tangle no :noweb-ref diff-hl-colors
(custom-set-faces
 '(diff-hl-change ((t (:background "orange2" :foreground "orange2")))) ; #cb4b16
 '(diff-hl-insert ((t (:background "#859900" :foreground "#859900"))))
 '(diff-hl-delete ((t (:background "#dc322f" :foreground "#dc322f")))))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref diff-hl-keybindings
(evil-define-key 'normal 'global
  (kbd "]h") #'diff-hl-next-hunk
  (kbd "[h") #'diff-hl-previous-hunk)
#+end_src

** Snippets
:PROPERTIES:
:ID:       0118536f-8f2f-4e6d-ab30-66bd3101401d
:END:
Trying https://github.com/minad/tempel.

#+begin_src elisp :noweb yes
(use-package tempel
  :config <<tempel-keybindings>>)
#+end_src

Once I'm inside a snippet, chances are I no longer need to expand more snippets.
Instead, I want to be able to use TAB to jump to next placeholder,
or move the point after the snippet.

#+begin_src emacs-lisp :tangle no :noweb-ref tempel-keybindings
(define-key tempel-map (kbd "TAB") #'tempel-next)
#+end_src

** TODO Modeline

 Currently using [[https://gitlab.com/jessieh/mood-line][mood-line]] (see [[https://www.reddit.com/r/emacs/comments/c5mel4/what_mode_line_do_you_use_and_why/][here]] for more great packages.)
 Check =mood-line-defformat= for custom formatting options.
 Customization is very simple, see =mood-line-format-default=
 and =mood-line-format-default-extended= for examples.
 TODO: add indicator for number of lines selected visually.

#+begin_src emacs-lisp
(use-package mood-line
  :config
  (setq mood-line-format mood-line-format-default)
  ;; can't use unicode glyphs with my current font
  (setq mood-line-glyph-alist mood-line-glyphs-fira-code)
  (mood-line-mode))
#+end_src

** Crux

#+begin_src emacs-lisp
(use-package crux
  :commands (crux-delete-file-and-buffer
             crux-sudo-edit
             crux-move-beginning-of-line
             crux-eval-and-replace))
#+end_src

** Link hinting

I could also hook it up to link-hint (see =link-hint-define-type=).

#+begin_src elisp :noweb yes
(use-package link-hint
  :commands (link-hint-open-link link-hint-open-link-at-point)
  :config
  <<link-hint-org-cite>>)
#+end_src

Here I add a new link type for org citations.
(Some of the relevant code, e.g. =*org-follow-cite=, is defined elsewhere in the config.)
The =:next= and =:at-point-p= keywords are required by link-hint,
and =:open= is the functionality that I want.
This lets me call link-hint the way I normally do,
and through it open citations with my custom function.

#+begin_src emacs-lisp :tangle no :noweb-ref link-hint-org-cite
(link-hint-define-type 'org-cite
  :next #'link-hint--next-org-cite
  :at-point-p #'*org-at-cite-p
  :open #'*org-follow-cite)

(push 'link-hint-org-cite link-hint-types)

(defun *org-at-cite-p ()
  "If the point is on an org citation, return its bounds.
The bounds are returned as a list, to be passed to `*org-follow-cite'."
  (flatten-tree (org-in-regexp *org-cite-regexp)))

(defun link-hint--find-org-cite (start-bound end-bound)
  "Find the first file link.
Only search the range between just after START-BOUND and END-BOUND."
  (save-excursion
    (let (org-cite-pos)
      (goto-char start-bound)
      (link-hint--find-regexp *org-cite-regexp
                              (point) end-bound))))

(defun link-hint--next-org-cite (bound)
  "Find the next org citation.
Only search the range between just after the point and BOUND."
  (link-hint--find-org-cite (point) bound))
#+end_src

** Anzu

[[https://github.com/emacsorphanage/anzu][Anzu]] is a small but pretty important package
that shows the number of search matches in the modeline.
It stays completely out of the way
until you search for occurrences of something,
and then it's indispensable.

#+begin_src emacs-lisp
(use-package anzu
  :init (global-anzu-mode 1))
#+end_src

** hl-todo

#+begin_src emacs-lisp
(use-package hl-todo
  :defer 2
  :config (global-hl-todo-mode 1)
  (transient-define-prefix +hl-todo-transient ()
    ["Change margins..."
     ("n" "next" hl-todo-next :transient t)
     ("p" "previous" hl-todo-previous :transient t)
     ("q" "quit" transient-quit-all)]))
#+end_src

** Olivetti

#+begin_src emacs-lisp
(use-package olivetti
  :commands (olivetti-mode)
  :config
  (transient-define-prefix +olivetti-transient ()
    ["Change margins..."
     ("e" "expand" olivetti-expand :transient t)
     ("s" "shrink" olivetti-shrink :transient t)
     ("q" "quit" transient-quit-all)]))
#+end_src

** ws-butler
One more package I learned of from Doom's config.

#+begin_src emacs-lisp
(use-package ws-butler
  :init (ws-butler-global-mode 1))
#+end_src

** Help

https://github.com/Wilfred/helpful

#+begin_src emacs-lisp
(use-package helpful
  :commands (+helpful-transient)
  :config
  (evil-define-key 'normal helpful-mode-map "q" #'kill-buffer-and-window)

  (transient-define-prefix +helpful-transient ()
    ["Emacs help"
     ["Helpful mode"
      ("f" "functions and macros" helpful-callable)
      ("v" "variables" helpful-variable)
      ("k" "key" helpful-key)
      ("c" "interactive functions" helpful-command)
      ("p" "thing at point" helpful-at-point)]
     ["In-built help"
      ("m" "describe mode" describe-mode)
      ("i" "info" info)]
     [("q" "quit" transient-quit-all)
      ("<escape>" "quit" transient-quit-all)]]))
#+end_src

* Finalize

Trick from [[https://blog.d46.us/advanced-emacs-startup/][here]]:
I increase the garbage collection threshold
during startup to speed up Emacs' load time,
but then decrease it once my config loads
so that GC pauses aren't so noticeable
when I'm actually using Emacs.

#+begin_src emacs-lisp
(setq gc-cons-threshold (* 2 1000 1000))
#+end_src
