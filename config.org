* Table of Contents :TOC:
- [[#introduction][Introduction]]
  - [[#history][History]]
  - [[#resources][Resources]]
- [[#basic-settings][Basic settings]]
  - [[#early-loading][Early loading]]
  - [[#package-management][Package management]]
  - [[#in-built-packages][In-built packages]]
  - [[#vars][Vars]]
  - [[#theming][Theming]]
  - [[#fonts][Fonts]]
  - [[#utility-functions][Utility functions]]
- [[#meow][Meow]]
  - [[#leader-map-bindings][Leader map bindings]]
  - [[#normal-state-bindings][Normal state bindings]]
  - [[#motion-state-bindings][Motion state bindings]]
  - [[#insert-state-bindings][Insert state bindings]]
  - [[#global-bindings][Global bindings]]
  - [[#meow-functions][Meow functions]]
  - [[#meow-settings][Meow settings]]
  - [[#meow-packages-and-resources][Meow packages and resources]]
- [[#minibuffer-keybindings][Minibuffer keybindings]]
- [[#transient-commands][Transient commands]]
  - [[#window-resizing-transient][Window resizing transient]]
  - [[#file-transient][File transient]]
  - [[#buffer-transient][Buffer transient]]
  - [[#helpful-transient][Helpful transient]]
  - [[#olivetti-transient][Olivetti transient]]
- [[#narrowing-and-completion][Narrowing and completion]]
  - [[#narrowing][Narrowing]]
  - [[#completion-corfu][Completion (Corfu)]]
- [[#org-mode][Org-mode]]
  - [[#org-settings][Org settings]]
  - [[#org-src][Org-src]]
  - [[#snippet-expansion-in-org][Snippet expansion in org]]
  - [[#org-agenda][Org agenda]]
  - [[#org-bling][Org bling]]
  - [[#transient-navigation][Transient navigation]]
  - [[#pandoc-integration][Pandoc integration]]
  - [[#links][Links]]
  - [[#link-path-tooltip][Link path tooltip]]
  - [[#cross-referencing][Cross-referencing]]
  - [[#org-cite][Org cite]]
  - [[#org-functions][Org functions]]
  - [[#org-refile][Org-refile]]
  - [[#toc-org][Toc-org]]
- [[#bibliography-and-citations][Bibliography and citations]]
  - [[#ebib][Ebib]]
- [[#programming-languages][Programming languages]]
  - [[#lisps][Lisps]]
  - [[#emacs-lisp][Emacs Lisp]]
  - [[#clojure][Clojure]]
- [[#utils][Utils]]
  - [[#magit][Magit]]
  - [[#tempel-snippets][Tempel snippets]]
  - [[#modeline][Modeline]]
  - [[#crux][Crux]]
  - [[#avy][Avy]]
  - [[#link-hinting][Link hinting]]
  - [[#anzu][Anzu]]
  - [[#hl-todo][hl-todo]]
  - [[#olivetti][Olivetti]]
  - [[#ws-butler][ws-butler]]
  - [[#help][Help]]
  - [[#undo][Undo]]
  - [[#evil-numbers][Evil-numbers]]
- [[#finalize][Finalize]]

* Introduction

Welcome to my literate Emacs configuration file! I suggest you read this section first before you go on. Note that a few of the links in this file are org-mode links. If you are reading this file online and stumble across a seemingly dead link, it might simply be an org link.

My config is:
- [[https://harryrschwartz.com/2016/02/15/switching-to-a-literate-emacs-configuration][literate]],
- centered on [[https://github.com/jwiegley/use-package][use-package]] with defers,
- based around modal editing, currently [[https://github.com/meow-edit/meow][meow]],
- [[https://github.com/magit/transient][transient]]- and leader-key heavy,
- full of my personal functions and quirks,
- still very much in flux.

Let's break some of the above down a little.

=use-package= is favoured by many Emacs gurus as a configuration technique /par excellence/ (along with literal configs of course). It helps keep related code in one place, instead of all around your config. And since it's included in newer versions of Emacs, using it is a no-brainer.

Crucially, =use-package= also supports lazy loading (i.e. delayed evaluation), which speeds up Emacs start-up time tremendously. The term used in =use-package= for this is 'defer'. Deferring packages is not particularly difficult, but it does require some thinking ahead and maybe tinkering. Of course, optimization is a never-ending game, but I try to keep it reasonable. As of this writing, Emacs starts in 2.6 seconds on my Surface Go 2 tablet (and a lot faster on my laptop and desktop), so I'm happy with where it is right now.

One more thing I'm doing with my literate config is splitting the source blocks with [[https://orgmode.org/manual/Noweb-Reference-Syntax.html][noweb]]. It goes like this: all the configuration and customization associated with a single package goes into one =use-package= block. That's simple and it makes sense. However, sometimes there is too much configuration, and the blocks get too long. I could add comments directly inside the source code (and I do that in a few places), but that seems to run counter to the core tenets of literate programming. Noweb allows me to separate blocks in the literate file to structure my text around them as I please, but still string them together when [[https://orgmode.org/manual/Extracting-Source-Code.html][tangling]] the resulting Elisp source file.

I am currently using the =meow= package for modal editing. However, my keybindings are somewhat idiosyncratic if not outright esoteric. This is partly to do with me using the [[https://en.wikipedia.org/wiki/Dvorak_layout][Dvorak]] layout on all my keyboards, and partly with the kind of configs I used before (see the [[History][history section]] below for details). Not only that, but I also use [[https://precondition.github.io/home-row-mods][home row modifiers]] on my mechanical keyboards, and on my laptop I [[https://gist.github.com/tanyuan/55bca522bf50363ae4573d4bdcf06e2e][bind the CapsLock key to both Escape and Ctrl]] (Escape if pressed and released, Ctrl if held down). I try to keep my bindings ergonomic and mnemonic: the most common commands should be easy to type, and the less common ones easy to remember. What's ergonomic for me may not be ergonomic for you; adjust to your own setup.

For reasons of both ergonomics and mnemonics, I tend to eschew commands that require modifiers (Ctrl and Alt, or =C= and =M= in Emacs parlance), and instead opt for key combinations. That's the whole premise of a modal editing system like the one I'm using, of course. But I take this further by using (and sometimes abusing) leader keys, including transient commands, to build my own mini-menus for all kinds of tasks from window management to export via pandoc.

I use quite a lot of my own functions in this config. As seems to be a convention with many users, I add a =+= to the beginning of my own functions to serve as a kind of namespace.

This config is still very much a work in progress, but it has reached a state where I can publish it for others to see.

** History

This section merely explains my history with Emacs, and may give a glimpse into my reasoning with some of the choices I have made. Feel free to skip it.

Before using Emacs, I cut my teeth on [[https://en.wikipedia.org/wiki/Vim_(text_editor)][vim]]. I kept hearing about Emacs of course, with its amazing features like [[https://orgmode.org/][org-mode]] and [[https://www.gnu.org/software/auctex/][auctex]] and [[https://magit.vc/][magit]], and that it wasn't just an editor, etc etc. But it was all so intimidating! I had no idea where to start. I tried a couple of times but got nowhere, and it seemed way too complicated and arcane.

My gateway to Emacs began with various [[https://github.com/emacs-evil/evil][evil]]-based "distributions" (really just ready-made configurations with a bunch of stuff already configured, mostly for programming). The first I found was [[https://github.com/syl20bnr/spacemacs][Spacemacs]], probably around the year 2015 or thereabouts, which I actually didn't even realize was just Emacs from its [[https://www.spacemacs.org/][website]]. (It says Emacs front and center now, but I seem to recall that wasn't the case ten years ago). Spacemacs was amazing! Suddenly I could use my vim knowledge for editing, and everything made sense! It had "layers" that you could enable and activate all the functionality you needed! You didn't even need to write much Elisp, just comment/uncomment stuff based on the layers you required. And it was slick, too. That futuristic pimp-purple theme made Emacs sexy again.

[[./img/vim2spacemacs.jpg]]

But Spacemacs was slow. It was huge, and its layers were a detriment to the editing experience. They even had a Spacemacs lite version, with a minimal amount of layers activated, so it wouldn't feel so sluggish. Another of Spacemacs' woes was its opacity, which in a way was its /raison d'être/: the Spacemacs config was (and still is) almost fully detached from Emacs internals. In a way, that's the whole point: separating the users from the 40-year history of Emacs idiosyncracies, and just letting them get on with their work. However, when things broke, and break they did, fixing them by yourself was nigh impossible. At about this time, talk of a newer, sexier Emacs distribution reached my ears---Doom Emacs.

As far as I have been able to determine, [[https://github.com/doomemacs/doomemacs/][Doom Emacs]] began as hlissner's personal config based on the good parts of Spacemacs, and also centered on [[https://github.com/emacs-evil/evil][evil]], but as a thinner layer on top of Emacs itself. Doom was for *advanced* users. It unabashedly required you to read and write Elisp, follow the Doom discord channel, and keep up to date with Doom's development. It occasionally broke in unexpected ways, and required you to change things in your config, or sometimes just reinstall Doom completely. It was. So. Fukken. Rad.

[[./img/spacemacs2doom.jpg]]

Doom had "modules", kind of like Spacemacs layers, but with an added layer of customizability. You could add extra flags to your module to activate certain features (LSP or org-roam, for example), but that required you to actually try and figure out what those flags were doing, and exposed you to the underlying packages. Which is really all those modules did: they added an extra package and some keybindings to go with it.

Doom also had lots of churn in its early days. Packages were constantly added to and discarded from the distribution, which had the (perhaps unintended) effect of exposing the users to a whole lot of Emacs packages. Unlike Spacemacs, which hid the complexity from the user, with Doom you were forced to choose: helm, ivy, or vertico? company or corfu? lsp-mode or eglot?

All in all, I learned a whole lot about Emacs through Doom. In fact, I learned so much that I started to strain against the limits it imposed on me. The Doom layer, thinner than Spacemacs though it may have been, was still a barrier between me and the soft underbelly of Emacs. Customizing certain settings or keybindings looked very different from how others were doing it. Doom grew in popularity, and became more stable. At the same time, I grew restless, and started chafing at the bit a little, daydreaming about having a literal config of my own one day, but not daring to take that first step.

And then one fateful day, with only my Surface Go tablet at my disposal, I failed to update Doom. I tried reinstalling, and failed again, multiple times. The Doom install process fetches a whole lot of packages from source repositories, which led [[https://codeberg.org/][Codeberg]] to block my IP in case I was trawling their repos to train a new LLM.

And that was it. With no other option for using Emacs during a whole long weekend, I bit the bullet, I took the plunge. I knew precisely the packages I needed first and foremost. I had my Doom configuration right at my disposal, so I could copy and paste from it to my heart's content. What I did not have was that thin layer of protection between me and the pure unadulterated essense of Emacs. I had no access to Doom's convenience macros, so I had to learn to configure =use-package= and =evil= the way they were meant to be configured. I had to look for packages that provided the functionality I had taken for granted with Doom. I found alternative packages that I hadn't heard of before. I learned about functionality that Doom provided by itself and not through packages, some of it quite impressive. Bit by bit, I got to a config that was reasonably close to what I had had within Doom.

But that was not the end. Having finally weaned myself off Emacs distributions, I found myself staring in the face of yet another barrier, one that I had never thought I could forsake: [[https://github.com/emacs-evil/evil][evil]] itself. I had not dared to imagine using something else, but all that configuration [[./img/inception.jpg][planted the seeds of an idea]] in me. What if vim was not editing perfection? What if, instead of donning the scuba-suit of evil to venture out into the oceans of Elisp, I could take off the respirator and swim freely? What if I could shave off a whole 0.5s of Emacs init time?

Evil is a behemoth. It is a complete editor inside an editor. Just like how Emacs distributions hide the complexity of Emacs behind a sleek (yet necessarily limited) API, evil hides the editing functionality of Emacs by replacing *everything* with vim-like alternatives. I was using =:s= and =:norm=, vim macros, [[https://github.com/emacs-evil/evil-surround][evil-surround]], [[https://github.com/hlissner/evil-snipe][evil-snipe]], [[https://github.com/bling/evil-visualstar][evil-visualstar]], and [[https://github.com/edkolev/evil-lion][evil-lion]]. I was a vim maestro, flying through both code and prose at the speed of thought. How could I give up ten years of muscle memory for [[http://xahlee.info/emacs/emacs/emacs_hand_pain_celebrity.html][RSI]]?

I couldn't, of course. Not to move to the default keybindings. Why would I ever do that? There is more choice than just evil and the default keybindings, and I could pick and choose my settings as I wanted. I was annoyed by the assumption in many online discussions that using the default keybindings is the only proper way to Emacs. The whole point of Emacs, as I see it, is infinite customizability. Why should I ever let anyone tell me how I should be using *my Emacs*?

It was not hard to find other modal editing schemes for Emacs. In fact, Emacs has plenty of those. The difference is, people arriving to Emacs from vim tend to miss the comfort of that editing model, and evil exists to fill that niche. Other modal editing packages mostly exist for people coming from the default Emacs keybindings, when they decide they want to keep the use of their hands a little longer. Evil stands apart from the pack in that it is, essentially, vim. It implements pretty much all of vim's functionality in Emacs; anything different is considered a bug. Other packages, by choice and by necessity, play nice with Emacs internals. This makes them a lot more lightweight, at the cost of having to know more about the default Emacs editing experience.

In for a penny, in for a pound, I decided. I had had my eyes on =meow= for some time. It's a lightweight package that respects Emacs conventions, yet at the same time provides a full-fledged modal editing experience. Its editing mentality is not that of vim, but rather of [[https://kakoune.org/][kakoune]]: the normal and visual modes are combined, so that you select the text first before performing an action on it. To my surprise, it didn't take me particularly long to acclimatize. I took a few liberties with the suggested [[https://github.com/meow-edit/meow/blob/master/KEYBINDING_DVORAK.org][bindings for Dvorak]], based on my vim/evil experiences, and also my personal ideas. And that's okay! Unlike vim land, where almost any rebinding is frowned upon, and online discussions frequently devolve into games of one-upmanship about whose config is the shortest, meow doesn't even have a default layout, and encourages its users to create their own bindings.

This is where I am right now. Ten years of vim/evil, most of them spent using Doom. Suddenly, I'm in territory that's at once familiar and not. I've learned a lot about Emacs using Doom, and I've learned a lot more about Emacs after leaving Doom for my own config. I'm really grateful for Spacemacs, Doom, and evil, because without these projects I likely would not have started using Emacs. Now though, I'm ready for something new.

** Resources

Here are some of the resources I have consulted while writing my own config:
- [[https://github.com/bbatsov/emacs.d/blob/master/init.el][bbatsov's minimalist config]]
- [[https://github.com/hrs/dotfiles/blob/main/emacs/.config/emacs/configuration.org][Great evil-based config]] with a bunch of functional lang settings.
- [[https://github.com/zzamboni/dot-emacs/blob/master/init.org][Zzamboni's evil-based config]] prior to his migration to Doom. Lots of org gems there.
- [[https://zzamboni.org/post/my-doom-emacs-configuration-with-commentary/][Zzamboni's Doom config]]
- [[https://github.com/rougier/dotemacs/blob/master/dotemacs.org][Nicholas Rougier's literate config]]
- See [[https://github.com/jschaf/dotfiles/blob/master/emacs/core/abn-core-emacs-settings.el][this config]] (including other files) for some obscure settings and startup hacks.
- [[https://sophiebos.io/posts/prettifying-emacs-org-mode/][org prettifying]]
- See [[https://www.reddit.com/r/emacs/comments/9zad13/managing_personal_packages_with_usepackage/][here]] for instructions on how to load local files with =use-package= (so that they can be deferred, of course).
- [[https://github.com/positron-solutions/transient-showcase][transient showcase]]
- Some interesting stuff here: https://github.com/daviwil/emacs-from-scratch

* Basic settings
** Early loading

Some of these settings were taken from the [[https://github.com/hrs/sensible-defaults.el][sensible-defaults]] package.

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
(use-package emacs
  :custom
  ;; reduce the frequency of garbage collection by making it happen on
  ;; each 50MB of allocated data (the default is on every 0.76MB)
  (gc-cons-threshold (* 50 1000 1000))
  ;; warn when opening files bigger than 50MB
  (large-file-warning-threshold (* 50 1000 1000))
  ;; do not create backups
  (make-backup-files nil)
  ;; use regular spacing with sentences.
  ;; this is important because it directly impacts sentence motions in evil.
  (sentence-end-double-space nil)
  ;; do not pollute this file with custom variables
  (custom-file "~/.emacs.d/custom.el")
  :config
  (load custom-file)
  (setq warning-minimum-level :emergency)
  ;; do not use tabs for indentation
  (setq-default indent-tabs-mode nil)
  ;; scrolling settings
  (setq scroll-conservatively 200
        scroll-preserve-screen-position 1))
#+end_src

** Package management
Instead of putting =:ensure t= everywhere, I can just set it here once.
(This is not recommended by some.)

#+begin_src elisp
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+end_src

I also turn on the profiler, so that I can see which packages
take the longest amount of time to load
(with the =use-package-report= command)
and see if their loading can be deferred.

#+begin_src emacs-lisp
(setq use-package-compute-statistics t)
#+end_src

See also =use-package-defaults= for other settings.

#+begin_src elisp
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+end_src

** In-built packages

Packages that form part of Emacs live here.

Some in-built packages are very useful, but not needed at startup. They may also lack handy trigger functions to bind them to. I defer the loading of these packages with idle timers as suggested [[https://blog.d46.us/advanced-emacs-startup/][here]].

*** Save place mode

Save place mode, as may be guessed from its name, saves the cursor position in files you visit. It's nice to open a file in Emacs and immediately see where you left off last time.

I prefer not to defer save-place-mode. Waiting a couple of seconds after startup to ensure it loads seems counterproductive to me, if it adds a few centiseconds to startup time at best. When trying it with defers, I found that I was often too quick to open a file, and save-place-mode hadn't started yet.

#+begin_src emacs-lisp
(use-package saveplace
  :init
  (setq save-place-forget-unreadable-files nil
        save-place-file (file-name-concat user-emacs-directory "tmp/places"))
  (save-place-mode 1))
#+end_src

*** Savehist mode

Savehist mode might be confused with save-place mode, but they do very different things. Savehist mode keeps track of *minibuffer* history, so that (for example) recently used =M-x= commands are shown on top.

#+begin_src emacs-lisp
(use-package savehist
  :init
  (setq savehist-file (file-name-concat user-emacs-directory "tmp/history"))
  (savehist-mode 1))
#+end_src

*** Tramp

#+begin_src emacs-lisp
(use-package tramp
  :defer 2
  :config
  (setq tramp-persistency-file-name
        (file-name-concat user-emacs-directory "tmp/tramp")))
#+end_src

*** Recentf

The 'f' in recentf stands for 'file'. I tend to open lots of different files from lots of different directories, and most of them are org-mode files rather than programming projects. Most of the time whenever I need to open a file, the first thing I do is try =recentf= (with [[id:53556f3d-c05c-4d6f-a9ae-3a59785b03e3][incremental narrowing and completion]]). Usually I only need to type a few disconnected syllables to filter out the file I need.

#+begin_src emacs-lisp
(use-package recentf
  :init
  (setq recentf-max-saved-items 1000
        recentf-max-menu-items 1000
        recentf-save-file (file-name-concat user-emacs-directory "tmp/recentf"))
  (recentf-mode 1))
#+end_src

*** Bookmarks

#+begin_src emacs-lisp
(use-package bookmark
  :config
  (setq bookmark-default-file (file-name-concat user-emacs-directory "tmp/bookmarks")))
#+end_src

** Vars

I use the same Emacs config on three machines at the moment. Most things do not need to change, but a few file locations differ from system to system. I set these here.

#+begin_src emacs-lisp
(pcase (system-name)
  ;; Laptop
  ("iwaka-thinkpad"
   (setq my/org-directory "~/org"
         my/default-bibliography "~/files/academic/bib/bibliography.bib"
         my/ebib-file-search-dir "~/files/syncthing/papers/ebib"
         my/ebib-import-directory "~/files/syncthing/papers/papers/articles"
         my/fontsize 200))

  ;; Office PC
  ("goderich-ncue"
   (setq my/org-directory "~/org"
         my/default-bibliography "~/files/academic/bib/bibliography.bib"
         my/ebib-file-search-dir "~/files/papers/ebib"
         my/ebib-import-directory "~/files/papers/papers/articles"
         my/fontsize 200))

  ;; Tablet
  ("goderich-surface"
   (setq my/org-directory "~/org"
         my/default-bibliography "~/academic/bib/bibliography.bib"
         my/ebib-file-search-dir "~/papers/ebib"
         my/ebib-import-directory "~/papers/papers/articles"
         my/fontsize 180)))
#+end_src

** Theming

As has been a longstanding tradition of Emacs tutorials since time immemorial, the first thing users are recommended to put into their config is the code to turn off all menus. Since I came to Emacs from vim, that has never been an issue with me. I never would have used them anyway.

Unlike vimmers (and a lot of Emacs users who had been clamoring for the functionality), I prefer *not* to display line numbers in the fringe. I can still go to specific lines by number, and I still see the current line number in my mode line in case I ever need it (which is never). When editing existing text, I use semantic operations like paragraphs, sentences, or parenthetic blocks. I haven't regretted turning line numbers off, and I don't miss them at all.

#+begin_src elisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(display-line-numbers-mode -1)
(tooltip-mode -1)

;; Soft wrap long lines
(global-visual-line-mode 1)

;; Maintain a small margin when scrolling
(setq scroll-margin 2)
#+end_src

Dark themes are all the rage with Linux hackers, but I usually work during the day, when a light theme makes text more readable. With Doom, I used =doom-solarized-light= most of the time, and its palette is gorgeous. I considered using the [[https://github.com/doomemacs/themes][doom themes]] package, but it's a little too large for my taste. Bozhidar Batsov's [[https://github.com/bbatsov/solarized-emacs][solarized themes]] package, while no bantamweight itself, provides a reasonable alternative.

Having said that, I found myself missing a few of the colours in Doom's version of solarized light, so I set them here. For some other settings I prefer bbatsov's way, or even my own tweaks.

#+begin_src emacs-lisp
(use-package solarized-theme
  :init
  (setq solarized-scale-org-headlines nil)
  (load-theme 'solarized-light t)

  :config
  ;; should be using #'set-face-attribute instead
  (face-spec-set 'default
                 '((t :background "#fdf6e3")))
  ;; org headlines
  (face-spec-set 'org-done
                 '((t :foreground "gray"
                      :weight bold)))
  (face-spec-set 'org-headline-done
                 '((t :foreground "gray")))
  (face-spec-set 'org-todo
                 '((t :foreground "#859900")))
  (face-spec-set 'font-lock-builtin-face
                 '((t :foreground "#d33682"
                      :weight normal)))
  (face-spec-set 'org-level-1 '((t :foreground "#268bd2")))
  (face-spec-set 'org-level-2 '((t :foreground "#d33682")))
  (face-spec-set 'org-level-3 '((t :foreground "#6c71c4")))
  (face-spec-set 'org-level-4 '((t :foreground "#5ca8dd")))
  (face-spec-set 'org-level-5 '((t :foreground "#de68a1")))
  (face-spec-set 'org-level-6 '((t :foreground "#92c4e8")))
  (face-spec-set 'org-level-7 '((t :foreground "#e99ac0")))
  (face-spec-set 'org-level-8 '((t :foreground "#d3e7f6")))
  (face-spec-set 'org-table   '((t :foreground "#6c71c4")))
  (face-spec-set 'org-cite    '((t :foreground "#b58900")))
  ;; org src blocks
  (face-spec-set 'org-block
                 '((t :background "#faf1d9"
                      :extend t)))
  (face-spec-set 'org-meta-line
                 '((t :background "#faf1d9"
                      :slant normal
                      :extend t)))
  ;; org checkbox
  (face-spec-set 'org-checkbox
                 '((t :box unspecified)))
  ;; org agenda
  (face-spec-set 'org-agenda-date
                 '((t :foreground "#657b83" ; same as default
                      :weight bold)))
  (face-spec-set 'org-scheduled-previously
                 '((t :foreground "#657b83"))) ; same as default
  (face-spec-set 'org-agenda-done
                 '((t :slant normal)))
  (face-spec-set 'link
                 '((t :foreground "#268bd2"
                      :weight bold
                      :underline t)))
  ;; info
  (face-spec-set 'Info-quoted
                 '((t :inherit font-lock-keyword-face))))
#+end_src

** Fonts

Font configuration in Emacs is a little complicated, and tied to theming as well. I try to keep it relatively simple, but I also like my Emacs to look nice.

Since I spend so much time in org-mode, and a lot of it writing prose, it makes sense for me to configure variable width fonts in addition to monospace ones for programming. I use [[https://gitlab.com/jabranham/mixed-pitch][mixed-pitch]] mode to have both types of fonts in a single buffer. Some of the ideas for font configuration came from [[https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/#h:c7528f3d-9fc8-49e5-9468-6868fb5c07b5][Prot's tutorial]], although I looked at various other configs as well. That =mixed-pitch-set-height= setting is super important: without it, you can't adjust the relative height of monospace and variable width fonts in mixed-pitch buffers.

#+begin_src emacs-lisp
(use-package mixed-pitch
  :hook ((text-mode . mixed-pitch-mode)
         (Info-mode . mixed-pitch-mode))
  :config
  (setq mixed-pitch-set-height t))
#+end_src

Next are the fonts themselves. [[https://github.com/be5invis/Iosevka][Iosevka]] gets mentioned a lot as a popular monospace font, but I don't like it much (too thin). The monospace fonts I do like are (see also [[https://coding-fonts.pages.dev/fonts/input/?language=js][here]]):
- Cascadia Code (round and funky, a bit on the thick side)
- Fantasque Sans Mono (like Cascadia, but thinner and a more handwritten style)
- Input (a bit like Cascadia, but thinner and more square)
- Source Code Pro (nice and round, if a little boring)
- Fira Code (similar to Source Code Pro, could try when I want something more mainstream)
- [[https://pcaro.es/hermit/][Hermit]] (a little of an old-school 8-bit quality to it, but modernized)
- [[https://www.dafont.com/lotion.font][Lotion]] (funky and slightly cartoonish)

With variable width fonts, it's not always just a matter of liking a typeface, but also it being compatible with the things I type. E.g. I like the [[https://edwardtufte.github.io/et-book/][ET Book]] quite a lot, but unfortunately it has minimal support for non-ASCII characters, which is less than ideal, because I type those a lot. A few other variable width fonts I like are (also see [[https://wiki.archlinux.org/title/Fonts][here]]):
- Crimson Pro
- Gentium family (has all of the IPA, but the line spacing is too big)
- Libertinus

#+begin_src emacs-lisp
(let ((monospace-font "Cascadia Code")
      (variable-font "Crimson Pro"))
  (set-face-attribute 'default nil
                      :family monospace-font
                      :height my/fontsize)
  (set-face-attribute 'fixed-pitch nil
                      :family monospace-font
                      :height 1.0)
  (set-face-attribute 'variable-pitch nil
                      :family variable-font
                      :height 1.3))
#+end_src

For CJK fonts specifically, check [[https://www.shimmy1996.com/en/posts/2018-06-24-fun-with-fonts-in-emacs/][this]], or [[https://www.reddit.com/r/emacs/comments/8tz1r0/how_to_set_font_according_to_languages_that_i/e1bjce6/][this snippet]].
[[https://github.com/be5invis/Sarasa-Gothic][Sarasa]] is a CJK font affiliated with Iosevka.
Also [[https://coldnew.github.io/d5011be2/][this article]] deals with CJK alignment in org tables. However, I already have valign-mode, so that might be moot.

** TODO Utility functions

Some functions I use in my config. They are placed here temporarily, and I should move them under more appropriate headings.

#+begin_src emacs-lisp
(defun +consult-goto-org-heading ()
    "Find an org heading in the current buffer, and open it.
`consult-org-heading' doesn't do this automatically for some reason."
    (interactive)
    (consult-org-heading)
    (org-fold-show-context)
    (org-fold-show-entry)
    (org-fold-show-children))

(defun +scroll-line-to-top ()
  ;; Taken from `evil-scroll-line-to-top'
  (interactive)
  (recenter (1- (max 1 scroll-margin))))

(defun +open-config ()
  (interactive)
  (find-file "~/.emacs.d/config.org"))

(defun +open-org-dir ()
  (interactive)
  (ido-find-file-in-dir "~/org/"))

(defun turn-off-visual-line-mode ()
  (visual-line-mode -1))

(defun turn-on-truncate-lines ()
  (toggle-truncate-lines 1))
#+end_src

* Evil (disabled) :noexport:

I am no longer using evil as of December 2024. Feel free to go ahead and jump straight to [[#meow][meow]]. This config is here temporarily, but I will remove it once I'm fully settled with meow, which now appears to be only a question of time.

#+begin_src elisp :tangle no :noweb yes
(use-package evil
  :init
  ;; for use with evil-collection
  (setq evil-want-keybinding nil)
  (evil-mode 1)
  ;; Sane undo
  (evil-set-undo-system 'undo-fu)

  :bind <<evil-escape>>
  :custom
  (evil-esc-delay 0)
  ;; Substitute with :s globally by default
  (evil-ex-substitute-global t)
  ;; Make evil commands operate on logical, not visual lines
  (evil-respect-visual-line-mode nil)
  ;; Have Y behave like D and C
  (evil-want-Y-yank-to-eol t)
  ;; * and # search for the whole symbol
  (evil-symbol-word-search t)

  :config
  <<evil-cursor>>
  <<evil-keybindings>>
  <<transients>>

  ;; Elisp mode
  (evil-define-key 'normal emacs-lisp-mode-map
    (kbd "<localleader>ee") #'eval-last-sexp))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref evil-cursor
(setq evil-emacs-state-cursor  '("red" box))
(setq evil-normal-state-cursor '("gray" box))
(setq evil-visual-state-cursor '("gray" box))
(setq evil-insert-state-cursor '("gray" bar))
(setq evil-motion-state-cursor '("gray" box))
(blink-cursor-mode -1)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package evil-surround
  :ensure t
  :config (global-evil-surround-mode 1))
#+end_src

** Global keybindings
:PROPERTIES:
:ID:       483821dc-9279-4372-93b3-a7f4fa65202e
:END:

*** Escape everything

Make ESC quit everything.
I tried setting this up in the minibuffer to no avail,
and with other keybinding methods and functions,
but it turned out that a simple line with a =use-package= keyword
was all that was needed.
See also [[https://github.com/doomemacs/doomemacs/blob/9c8cfaadde1ccc96a780d713d2a096f0440b9483/lisp/doom-keybinds.el#L81][Doom's ESC function]].

#+begin_src emacs-lisp :tangle no :noweb-ref evil-escape
("<escape>" . keyboard-escape-quit)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(defun +evil-normal-state-maybe ()
  (interactive)
  (cond
   ((and corfu-mode completion-in-region-mode) (corfu-quit))
   (tempel--active (tempel-done))
   (t (evil-normal-state))))

(evil-define-key 'insert 'global (kbd "<escape>") #'+evil-normal-state-maybe)
#+end_src

*** Leader keys

I first encountered the idea of using SPC as the global leader in Spacemacs, and I think it's great.
I use the comma for localleader binds, because in Dvorak it's very conveniently positioned,
and not a great loss in normal mode.
(The lack of =,= in normal mode is remedied by [[id:8c7a6f08-49e4-47c8-acbb-45de731cdb1f][evil-snipe]].)

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-set-leader '(normal visual) (kbd "SPC"))
(evil-set-leader '(normal visual) (kbd ",") 'localleader)
#+end_src

*** M-x (execute-extended-command)

I run commands by name quite a lot, and so to me it makes sense
to bind the command menu to an easily reachable key,
preferably with no modifiers.
Doom has it on =SPC := if I recall correctly.
I think vim's =;= command is not worth an unmodified key,
especially since it is made redundant with [[https://github.com/hlissner/evil-snipe][evil-snipe]].

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key '(normal visual motion) 'global ";" #'execute-extended-command)
#+end_src

*** Line movements (j and k)

I write a lot of prose, and so encounter wrapped lines quite often.
For me, =j= and =k= moving by visual line just makes sense.
=gj= and =gk= bindings are there mostly for macros,
as I don't use them interactively.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key '(normal visual) 'global
  "k"  #'evil-previous-visual-line
  "j"  #'evil-next-visual-line
  "gj" #'evil-next-line
  "gk" #'evil-previous-line)
#+end_src

*** Move to beginning of line (H and ^)

Swapping =H= and =^= is an old vimmer trick.
Since moving to the beginning of the line is arguably a more common action,
it makes sense to place it on the more reachable =H=.
I also augment it with a crux function that jumps to the first non-whitespace char,
and to the first column if pressed again.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key '(normal visual) 'global
  "H"  #'crux-move-beginning-of-line
  "^"  #'evil-window-top)
#+end_src

*** Search at point (* and #)

I use the [[https://github.com/bling/evil-visualstar][evil-visualstar]] package to augment =*= and =#= in visual mode.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key 'visual 'global
  "*" #'evil-visualstar/begin-search-forward
  "#" #'evil-visualstar/begin-search-backward)
#+end_src

*** Incrementing numbers

Incrementing numbers with the [[https://github.com/cofi/evil-numbers][evil-numbers]] package.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key '(normal visual) 'global
  "g="  #'evil-numbers/inc-at-pt
  "g-"  #'evil-numbers/dec-at-pt
  "g+"  #'evil-numbers/inc-at-pt-incremental)
#+end_src

*** Other keybindings

Spacemacs also introduced me to mnemonic keybindings.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key 'normal 'global
  (kbd "<leader>/") #'consult-line
  ;; Files
  (kbd "<leader>.") #'find-file
  (kbd "<leader>f") #'+file-transient
  ;; Buffers
  (kbd "<leader>,") #'consult-buffer
  (kbd "<leader>bd") #'kill-this-buffer
  (kbd "<leader>bq") #'kill-this-buffer
  ;; Windows
  (kbd "<leader>w") #'+window-transient
  ;; Help
  (kbd "<leader>h") #'+helpful-transient
  ;; org
  (kbd "<leader>a") #'org-agenda-list
  ;; links
  (kbd "<leader>u") #'link-hint-open-link
  ;; olivetti
  (kbd "<leader>o") #'+olivetti-transient
  ;; todo items
  (kbd "]t") #'hl-todo-next
  (kbd "[t") #'hl-todo-previous
  ;; there is also the hl-todo-occur command
  ;; Line comments
  (kbd "gc") #'comment-line
  ;; ebib
  (kbd "<leader>e") #'ebib)
#+end_src

*** Home row mod workaround

I hit =C-a= on my keyboard when typing "ea"
(because of Dvorak + [[https://precondition.github.io/home-row-mods][home row modifiers]]).
In evil insert mode, it pastes the last insertion my default.
In regular Emacs keybindings, it goes to the beginning of the line.
Neither is worth keeping if it leads to borking up my typing.
The two need to be disabled separately.
#+begin_src emacs-lisp :tangle no :noweb-ref evil-keybindings
(evil-define-key 'insert 'global (kbd "C-a") nil)
(keymap-global-unset "C-a")
#+end_src

** Packages
*** Evil collection

I'm on the fence about pulling all of [[https://github.com/emacs-evil/evil-collection][evil-collection]] for just a few modes,
so I'm trying it out for now. Can always copy/rewrite myself later.
Consider also modes: [[https://github.com/emacs-evil/evil-collection/blob/master/modes/macrostep/evil-collection-macrostep.el][macrostep]], [[https://github.com/emacs-evil/evil-collection/tree/master/modes/smerge-mode][smerge]], calendar (?), calc
Note that evil-collection does not include bindings for org-agenda

#+begin_src emacs-lisp :tangle no
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init '(ebib magit info)))
#+end_src

*** Evil-snipe
:PROPERTIES:
:ID:       8c7a6f08-49e4-47c8-acbb-45de731cdb1f
:END:

Sniping is an incredibly efficient way to move around nearby text.

#+begin_src emacs-lisp :noweb yes
(use-package evil-snipe
  :after evil
  :init
  (evil-snipe-mode 1)
  (evil-snipe-override-mode 1)
  :config
  <<evil-snipe-settings>>)
#+end_src

I like to have evil-snipe capture f/F/t/T for its own use,
so I turn on =evil-snipe-override-mode=.
This way, I can use these keys to jump to the next occurrence
of the searched character.
However, I do *not* want evil-snipe to steal my =,= and =;= keys,
even in a transient mode after a snipe.
They are my =localleader= and execute command keys, respectively,
and I want them to be available at all times.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-snipe-settings
(keymap-set evil-snipe-parent-transient-map "," nil)
(keymap-set evil-snipe-parent-transient-map ";" nil)
#+end_src

By default, snipe searches only on the current line.
I think it's a waste of potential,
since it can replace some =/= searches on adjacent lines as well.
I make the repeat scope broader, in case I want to search backwards as well.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-snipe-settings
(setq evil-snipe-scope 'visible)
(setq evil-snipe-repeat-scope 'whole-visible)
#+end_src

There are also some places where evil-snipe doesn't make sense,
but its high priority means it would capture keys even if I map them elsewhere.
In these modes, I turn it off.

#+begin_src emacs-lisp :tangle no :noweb-ref evil-snipe-settings
(dolist (it '(ebib-index-mode ebib-entry-mode))
  (push it evil-snipe-disabled-modes))
#+end_src

*** Evil-visualstar

This tiny package allows =*= and =#= to be usable in visual mode.
Instead of evil's default behaviour, which is to search for the word at point,
whatever that may be, these commands search for the selection.
The package also takes care of search history.
I do not use the package's own setup,
and instead rely on use-package's autoload functionality.
The keybindings are get in [[id:483821dc-9279-4372-93b3-a7f4fa65202e][the global keybinds section]].

#+begin_src emacs-lisp
(use-package evil-visualstar
  :commands (evil-visualstar/begin-search-forward
             evil-visualstar/begin-search-forward))
#+end_src

* Meow

[[https://github.com/meow-edit/meow/blob/master/EXPLANATION.org][Meow]] is a modal editing package. It's both like and unlike evil. If you come to it expecting it to be "just like evil, but better", you will inevitably be disappointed. If you keep an open mind and invest some time in it, it will work just as well as evil, but with much better coupling with Emacs.

#+begin_src emacs-lisp :noweb yes
(use-package meow
  :init
  (require 'meow) ; <- must be present
  <<meow-keybindings>>
  <<meow-functions>>
  <<meow-settings>>
  (meow-global-mode 1))
#+end_src

** Leader map bindings

Similar to both Spacemacs and Doom, meow utilizes the Space key as its leader key. This way instead of getting RSI on your pinkies, you can get it on your [[./img/thumbs-up.jpg][thumbs]]!

The biggest difference is that meow embraces Emacs defaults. Space followed by any of =x, c, h, g, m= enters [[https://github.com/meow-edit/meow/blob/master/TUTORIAL.org#keypad][Keypad state]], which is used to enter Emacs commands without using modifiers. So these five keys are off-limits, but that still leaves us with enough room to fill with our own bindings.

Notably, keypad state bindings are also made available as regular Emacs keybindings, with =C-c= as the leader key.

In the spirit of Spacemacs and Doom, I use the Space key as a "global leader", and save it for commands that I want to be available everywhere. I have figured out a way to have local leader commands as well, with bindings based on modes: see the [[id:1e5a8fcf-39f6-41ce-a9a0-88583045fcde][meow functions]] section for that.

Quite a few of my leader map functions are in fact [[id:1d67b9e6-b143-425a-8dec-d124f95eedc4][transients]]. These are easy to spot because I always name them as such.

#+begin_src emacs-lisp :tangle no :noweb-ref meow-keybindings
(meow-leader-define-key
 '("SPC" . execute-extended-command)
 '("a" . org-agenda-list)
 '("b" . +buffer-transient)
 ;; "c" reserved by meow
 '("e" . ebib)
 '("f" . +file-transient)
 ;; "g" reserved by meow
 ;; "h" reserved by meow, I rebind it elsewhere
 ;; "m" reserved by meow
 '("o" . +olivetti-transient)
 '("u" . link-hint-open-link)
 '("v" . magit) ; v for +vendetta+ version control
 '("w" . +window-transient)
 ;; "x" reserved by meow
 '("," . switch-to-buffer)
 '("." . find-file)
 '("/" . consult-line)
 '("?" . meow-cheatsheet))
#+end_src

** Normal state bindings

The normal state is the bread and butter of editing with meow, just like in vim/evil. Unlike vim/evil, meow's normal state operates on selections. Vimmers love talking about the 'grammar' of vim (verb → adjective → noun), which is flipped in meow's model (really kakoune's editing model).

I took the [[https://github.com/meow-edit/meow/blob/master/KEYBINDING_DVORAK.org][suggested Dvorak bindings]] and distorted them almost to the point of irrecognizability. I swapped things around somewhat to have a little "WASD" pyramid of movement on the right hand side (IJKL on qwerty keyboards). I replaced certain commands with packages like consult and avy. There are a few places where I have the same command bound to multiple keys. This is not an accident, instead I'm trying out various configurations and see which ones I prefer.

One package I bind to a key is [[https://github.com/abo-abo/avy][avy]], which is great for moving around the screen in Emacs, and it replaces [[https://github.com/hlissner/evil-snipe][evil-snipe]] and evil's own motions for me. I also use it to [[id:067dfe76-a65f-44b6-ab9d-a72b875071d2][open links]] (with the link-hint package).

However, a few evil habits are reflected in this layout, not least of which being =ZZ= and =ZQ= to exit Emacs with and without saving, respectively.

So this keymap will likely change in future, but right now it looks something like this:

[[./img/meow-cheatsheet.png]]

#+begin_src emacs-lisp :tangle no :noweb-ref meow-keybindings
(meow-normal-define-key
 '("0" . meow-expand-0)
 '("9" . meow-expand-9)
 '("8" . meow-expand-8)
 '("7" . meow-expand-7)
 '("6" . meow-expand-6)
 '("5" . meow-expand-5)
 '("4" . meow-expand-4)
 '("3" . meow-expand-3)
 '("2" . meow-expand-2)
 '("1" . meow-expand-1)
 '("-" . negative-argument)
 '("/" . meow-visit) ; superfluous?
 '(";" . ignore)
 '("," . meow-inner-of-thing)
 '("." . meow-bounds-of-thing)
 '("<" . meow-beginning-of-thing)
 '(">" . meow-end-of-thing)
 '("a" . meow-append)
 '("A" . meow-open-below)
 '("b" . meow-back-word)
 '("B" . meow-back-symbol)
 '("c" . meow-prev)
 '("C" . meow-prev-expand)
 '("d" . meow-change)
 '("e" . meow-line)
 '("E" . meow-goto-line)
 '("f" . meow-find)
 '("g" . meow-cancel-selection) ; superfluous?
 '("G" . meow-grab)
 '("h" . meow-left)
 '("H" . meow-left-expand)
 '("i" . meow-insert)
 '("I" . meow-open-above)
 '("j" . meow-join)
 '("k" . meow-kill)
 '("l" . meow-till)
 '("m" . meow-mark-word)
 '("M" . meow-mark-symbol)
 '("n" . meow-right)
 '("N" . meow-right-expand)
 '("o" . +meow-localleader)
 '("p" . meow-yank)
 '("q" . meow-quit)
 '("r" . meow-replace)
 '("R" . meow-swap-grab)
 '("s" . avy-goto-char-timer)
 '("S" . meow-visit)
 '("t" . meow-next)
 '("T" . meow-next-expand)
 '("u" . undo-fu-only-undo)
 '("U" . undo-fu-only-redo)
 '("v" . meow-reverse)
 '("w" . meow-next-word)
 '("W" . meow-next-symbol)
 '("x" . execute-extended-command) ; superfluous?
 '("y" . meow-save)
 '("z" . meow-pop-selection)
 '("ZZ" . save-buffers-kill-terminal)
 '("ZQ" . kill-emacs)
 '("'" . repeat) ; not as useful as in evil
 '("\\" . execute-extended-command)
 '("<escape>" . meow-cancel-selection))
#+end_src

** Motion state bindings

Meow's motion state in itself is not a new idea. Evil has a motion state too, used in exactly the same situations. It's triggered by default in non-text modes, such as magit, dired, org-agenda, etc. What makes meow's motion state special is two things:
1. it has no bindings by default,
2. it has a peculiar [[https://github.com/meow-edit/meow/blob/master/TUTORIAL.org#motion][binding overwrite]] mechanism.

No bindings means this state is completely transparent and lets you use the bindings set by the mode itself, which is great if you are already familiar with those. It's also what Emacs expects, so there's a lot less friction in these modes than with evil, where you need a project like [[https://github.com/emacs-evil/evil-collection][evil-collection]] to maintain some semblance of coherence. With meow, something like =q= for quitting a mode /just works/. It's great.

The binding overwrite is a really clever idea. Instead of letting you bind keys in motion mode and thus lose keybindings in all modes where it's activated, meow automatically rebinds those keys with a Hyper modifier. Naturally, most of us don't have a Hyper key---even on my mechanical keyboards I have never felt the need to include one---but the point is you can then rebind other keys to those Hyper key bindings, letting you preserve at least some of the more common commands. I do this in the code below.

#+begin_src emacs-lisp :tangle no :noweb-ref meow-keybindings
(meow-motion-overwrite-define-key
 '("<escape>" . ignore)
 '("\\" . execute-extended-command)
 '("h" . meow-left)
 '("t" . meow-next)
 '("c" . meow-prev)
 '("n" . meow-right)
 '("<" . beginning-of-buffer)
 '(">" . end-of-buffer)
 '("H" . "H-h")
 '("T" . "H-t")
 '("C" . "H-c")
 '("N" . "H-n"))
#+end_src

** Insert state bindings

The insert state is what you use for actual typing. For most users, there's probably no need to modify it (hence meow doesn't even supply a helper function for insert state, unlike normal and motion states). I do a couple of things with it.

I like having =C-w= delete the previous word. I'm not sure where I picked up this keybinding, but it's all over Linux, including shell and vim. I kept hitting it, trying to delete the previous word and instead executing the =kill-region= command, which is the Emacs binding. In the end I just gave up and rebound it in insert mode.

With my [[https://precondition.github.io/home-row-mods][home row modifiers]] and sausage fingers, I sometimes end up hitting a modifier + a key instead of typing a sequence like "ea", "pa", or "ga". On Dvorak, this tends to happen with a-final sequences. I disable these commands in insert mode by setting them to =ignore=.

#+begin_src emacs-lisp :tangle no :noweb-ref meow-keybindings
(meow-define-keys 'insert
  '("C-w" . meow-backward-kill-symbol)
  '("C-a" . ignore)
  '("M-a" . ignore))
#+end_src

I do not have Tab bindings collected in any single specific place, but this bears stating somewhere. Insert mode keybindings are as good a place as any. I have the following functionality on my Tab key:
- expand a snippet if one is available, but *only* in insert state,
- act as org-cycle in org mode, in both normal and insert states,
- act as indent key in programming modes in both normal and insert states.

** Global bindings

Since =h= is one of the keys that get captured in keypad state, pressing =SPC h= gets translated into =C-h= directly. Here, I bind =C-h= to my transient, because it does essentially the same thing as the default =describe-*= functions, but better.

#+begin_src emacs-lisp :tangle no :noweb-ref meow-keybindings
(keymap-global-set "C-h" #'+helpful-transient)
#+end_src

On my mechanical keyboards with home row mods, I can do all sorts of shenanigans without moving my hands too much. The most reachable modifiers in my layout are Ctrl and Shift, bound under the middle and index fingers, respectively (on both sides, so each hand can use them). Even though I move Escape to the Home row, it's still on the Caps key, so I have to move my left hand quite a bit to reach it. =C-t= is a motion made by the two middle fingers, so it's even easier, even though it may not seem so. I bind =C-t= to Escape globally in Emacs, so I can use it everywhere (I should probably think about binding it directly in my keyboards' firmware).

#+begin_src emacs-lisp :tangle no :noweb-ref meow-keybindings
;; home row mod esc
(keymap-global-set "C-t" "<escape>")
#+end_src

** Meow functions
:PROPERTIES:
:ID:       1e5a8fcf-39f6-41ce-a9a0-88583045fcde
:END:

I loved using local leader keys in Doom. One of my favourite things about evil was being able to configure keybindings in all modes to be precisely what I wanted (although it was a bit of a pain with evil + Doom, especially at first). In fact, my biggest fear before switching to meow was not the unfamiliar editing model, but losing the ability to find keys via my local leader.

A solution I found was binding keys to a longer prefix. Here I choose =C-c o= (partly because I bound it to the =o= key in normal mode). I can then have global keybindings use the keypad state and =C-c= + letter, and bind keys local to particular modes to begin with =C-c o=. In practice, if you see a binding like =C-c o o= for org-mode, I'm actually pressing =o o=.

The beauty of this approach is that I can have more that one local leader if I want to, but at the same time I get to fully keep the default Emacs keybindings AND the keymap state with =C-c= (keymap using SPC is a given in meow).

#+begin_src emacs-lisp :tangle no :noweb-ref meow-functions
(defun +meow-localleader ()
  (interactive)
  (meow-keypad-start-with "C-c o"))
#+end_src

** Meow settings

I was pleasantly surprised by the amout of customization available in meow. The developers have foreseen quite a large number of possible needs and provided comfortable solutions.

I still refer to the cheatsheet from time to time, so I prefer to see it with the proper layout.
#+begin_src emacs-lisp :tangle no :noweb-ref meow-settings
(setq meow-cheatsheet-layout meow-cheatsheet-layout-dvorak)
#+end_src

The default normal cursor and region selection faces are too similar in my layout, so I change them slightly. I like to be able to see where my cursor is when selecting, because by default it turns into a bar, making it difficult to see with an active region. I also deactivate cursor blinking, because it annoys me.
#+begin_src emacs-lisp :tangle no :noweb-ref meow-settings
(custom-set-faces
 '(meow-normal-cursor ((t (:background "#aab2ac")))))
(setq meow-cursor-type-region-cursor '(box . 2))
(blink-cursor-mode -1)
#+end_src

The =meow-selection-command-fallback= setting is fantastic. It works like this: most operations in meow require a selection (= region). What should we do when there is no selection? There are defaults, but you can easily change them.

I use =k= for the =meow-kill= command, which is 'cut' in CUA. By default, it kills to the end of the line with no selection, but that's already bound to =C-k= in Emacs, so not that far off to begin with, plus it's not a particularly common action. I instead have it delete a single character when there's no selection, which frees me from having to bind =meow-delete= to a key.
#+begin_src emacs-lisp :tangle no :noweb-ref meow-settings
;; When k is used without a selection, delete char
(map-put! meow-selection-command-fallback #'meow-kill #'meow-delete)
#+end_src

Meow has a binding for goto-line, but it accepts functions other than the default. The reason to use avy here is pretty obvious, as it is strictly better than the in-built goto-line. The reason to wrap it in meow instead of just binding it directly, is that meow also selects the line which is jumped to.
#+begin_src emacs-lisp :tangle no :noweb-ref meow-settings
(setq meow-goto-line-function #'avy-goto-line)
#+end_src

Both vim and Emacs have their own ways of dealing with copying and pasting text. Vim has registers, and Emacs has the kill ring. I'm not interested. I use a system-wide clipboard manager, and I want all my copied text to be in one place, regardless of the program I'm using.
#+begin_src emacs-lisp :tangle no :noweb-ref meow-settings
(setq meow-use-clipboard t)
#+end_src

Selection directions mean whether the cursor appears at the beginning or the end of the selection. Makes sense to me to keep both inner and outer bound directions the same.
#+begin_src emacs-lisp :tangle no :noweb-ref meow-settings
(map-put! meow-thing-selection-directions 'bounds 'forward)
#+end_src

** Meow packages and resources

While I'm still getting used to meow, here are reminders for things that I used with evil but no longer have access to, and what I should replace them with.
- [[https://github.com/juliapath/evil-numbers][evil-numbers]] for incrementing/decrementing (does not require evil)
- Look into [[https://www.emacswiki.org/emacs/KeyboardMacros][Emacs macros]] and [[https://github.com/meow-edit/meow/blob/master/TUTORIAL.org#beacon][beacon state]] to replace vim =q=
- Look into [[info:emacs#Replace][replacement commands]] instead of vim =:=

* Minibuffer keybindings

Keybindings in the minibuffer have to be set differently.
I am not using evil in the minibuffer, and the bindings
have to be set up using a hook each time.

I went through this trouble to replicate Doom's behaviour
when pressing backspace in the minibuffer.
It works as normal when typing the name of a file,
but if you keep deleting, the parent directories will be deleted
with a single press of backspace.
This is pretty convenient when jumping upwards many levels.

Right now my implementation is still relatively naive,
and I'm still in the process of refining it.

#+begin_src emacs-lisp
(defun +delete-char-or-directory ()
  (interactive)
  (cond
   ((string= (minibuffer-contents) "/")
    (delete-backward-char 1))
   ((string= (minibuffer-contents) "~/")
    (delete-minibuffer-contents)
    (insert (expand-file-name "~/")))
   ((eq (char-before) ?/)
    (let ((pt (point))
          (slash-pos (search-backward "/" nil t 2)))
      (if slash-pos
          (progn
            (delete-region (1+ slash-pos) pt)
            (move-end-of-line nil))
        (delete-backward-char 1))))
   (t (delete-backward-char 1))))

(defun +minibuffer-setup ()
  (keymap-set minibuffer-local-map "<backspace>" #'+delete-char-or-directory)
  (keymap-set minibuffer-local-map "C-w" #'backward-kill-word)
  (keymap-set minibuffer-local-map "C-<return>" #'vertico-exit-input))

(add-hook 'minibuffer-setup-hook #'+minibuffer-setup)
#+end_src

* Transient commands
:PROPERTIES:
:ID:       1d67b9e6-b143-425a-8dec-d124f95eedc4
:END:

Transients are an amazing feature of Emacs, and really handy for people who like to over-personalize their configs. They don't run a command, but instead pop up a menu where you can choose further actions, or enter a transitory state so that you can mash one key to, e.g. increase the font size or text width. I prefer using transients to mapping every function individually, because transients are a lot easier to remap, and their functionality is strictly more powerful. Since Emacs 28, the transient package has been included in Emacs itself.

Right now, all my transient menus live here. So far they are missing descriptions.

** Window resizing transient

#+begin_src emacs-lisp
(transient-define-prefix +window-transient ()
  ["Resizing windows"
   ["Transient"
    ("b" "bigger" enlarge-window :transient t)
    ("s" "smaller" shrink-window :transient t)
    ("=" "balance" balance-windows :transient t)]
   ["Non-transient"
    ("d" "delete" delete-window)
    ("w" "other" other-window)
    ("m" "maximize" delete-other-windows)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** File transient

#+begin_src emacs-lisp
(transient-define-prefix +file-transient ()
  ["File commands"
   ["With this file..."
    ("s" "save" save-buffer)
    ("D" "delete" crux-delete-file-and-buffer)
    ("R" "rename" crux-rename-file-and-buffer)
    ("u" "sudo edit" crux-sudo-edit)]
   ["Open..."
    ("r" "recent file" recentf)
    ("o" "org directory" +open-org-dir)
    ("c" "config.org" +open-config)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Buffer transient

#+begin_src emacs-lisp
(transient-define-prefix +buffer-transient ()
  ["Buffer commands"
   [("b" "open" consult-buffer)
    ("s" "save" save-buffer)
    ("u" "sudo edit" crux-sudo-edit)]
   [("d" "quit" kill-this-buffer)
    ("q" "quit" kill-this-buffer)]
   [("<escape>" "quit" transient-quit-all)]])
#+end_src


** Helpful transient

#+begin_src emacs-lisp
(transient-define-prefix +helpful-transient ()
  ["Emacs help"
   ["Helpful mode"
    ("f" "functions and macros" helpful-callable)
    ("v" "variables" helpful-variable)
    ("k" "key" helpful-key)
    ("c" "interactive functions" helpful-command)
    ("p" "thing at point" helpful-at-point)]
   ["In-built help"
    ("m" "describe mode" describe-mode)
    ("F" "describe face" describe-face)
    ("i" "info" info)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Olivetti transient

#+begin_src emacs-lisp
(transient-define-prefix +olivetti-transient ()
  ["Change text column width..."
   [("w" "wider" olivetti-expand :transient t)
    ("n" "narrower" olivetti-shrink :transient t)]
   [("f" "turn off olivetti" turn-off-olivetti-mode)
    ("q" "quit" transient-quit-all)]]
  (interactive)
  (olivetti-mode +1)
  (transient-setup '+olivetti-transient))
#+end_src

* Narrowing and completion
** Narrowing
:PROPERTIES:
:ID:       53556f3d-c05c-4d6f-a9ae-3a59785b03e3
:END:

TODO: There is a lot of functionality here, I should explore it.
https://github.com/minad/consult
#+begin_src emacs-lisp
(use-package consult)

(use-package vertico
  ;; :custom
  ;; (vertico-scroll-margin 0) ;; Different scroll margin
  ;; (vertico-count 20) ;; Show more candidates
  ;; (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
  ;; (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
  :init (vertico-mode))

(use-package orderless
  :custom
  (completion-styles '(orderless basic))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles partial-completion)))))

;; Documentation in M-x and minibuffers
(use-package marginalia
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  ;; :bind (:map minibuffer-local-map
  ;;        ("M-A" . marginalia-cycle))

  :init (marginalia-mode))

;; Do not delay which-key (delay has to be above zero)
;; (use-package which-key
;;   :init (which-key-mode)
;;   :config
;;   (setq which-key-idle-delay 1)
;;   (setq which-key-idle-secondary-delay 0.05))
#+end_src

There is also https://github.com/oantolin/embark/,
but I haven't learned how to use it properly.

** Completion (Corfu)
:PROPERTIES:
:ID:       2ca8bb84-790f-4e68-8d3d-4893ef154e43
:END:

Using [[https://github.com/minad/corfu][Corfu]].

I do NOT normally want completion on in org, because that's distracting. I do want completion when programming, and I want it to open up automatically.

I'm using SPC as separator: pressing space does not exit completion, but instead begins a second chunk. This makes corfu work a lot like consult et al, where a search string can be entered using space-separated pieces.

When I'm in insert mode and a [[id:2ca8bb84-790f-4e68-8d3d-4893ef154e43][completion]] overlay is active, I want ESC to quit completion or templating *while keeping me in insert mode*. In my evil config, I used a wrapper function. With meow, I can just bind the keys directly in the respective modes.

#+begin_src emacs-lisp
(use-package corfu
  :hook ((prog-mode . corfu-mode))
  :custom
  (corfu-auto t)
  (corfu-quit-no-match t)
  :bind (:map corfu-map
         ("TAB" . corfu-expand)
         ("SPC" . corfu-insert-separator)
         ("<escape>" . corfu-quit)))
#+end_src

* Org-mode

- Sacha Chua also has an [[https://sachachua.com/blog/2024/01/using-consult-and-org-ql-to-search-my-org-mode-agenda-files-and-sort-the-results-to-prioritize-heading-matches/][interesting use]] of org-ql.

Note that since I am using a literate config
and loading it with org-babel from my =init.el=,
I cannot defer loading org-mode at startup.
It's not a huge penalty though,
and I feel the convenience outweighs it.

#+begin_src emacs-lisp :noweb yes
(use-package org
  :ensure nil
  :init <<org-init>>
  :hook <<org-hooks>>
  :bind (:map org-mode-map
         ([remap meow-open-below] . +org-open-below)
         ([remap meow-open-above] . +org-open-above)
         ("<return>" . +org-return)
         ("C-<return>" . +org-insert-item)
         ("C-l" . +org-link-dwim) ;; could move to M-l instead, together with M-c and M-r
         ;; local leader bindings
         ("C-c o d d" . org-deadline)
         ("C-c o d s" . org-schedule)
         ("C-c o d t" . org-time-stamp)
         ("C-c o h" . +consult-goto-org-heading)
         ("C-c o l" . +link-transient)
         ("C-c o o" . org-ctrl-c-ctrl-c)
         ("C-c o p" . pandoc-transient)
         ("C-c o q" . org-set-tags-command)
         ("C-c o Q" . +org-remove-tags)
         ("C-c o s" . org-edit-src-code)
         ("C-c o S" . org-sparse-tree)
         ("C-c o t" . org-todo)
         ;; org movement
         ("M-h" . org-metaleft)
         ("M-t" . org-metadown)
         ("M-c" . org-metaup)
         ("M-n" . org-metaright)
         ("M-H" . org-shiftmetaleft)
         ("M-T" . org-shiftmetadown)
         ("M-C" . org-shiftmetaup)
         ("M-N" . org-shiftmetaright))
  :config
  <<org-settings>>
  <<org-src-settings>>
  <<org-functions>>
  <<org-agenda>>
  <<org-navigation-transient>>
  <<org-modules>>)
#+end_src

** Org settings

Enable indentation in org-mode.
#+begin_src emacs-lisp :tangle no :noweb-ref org-init
(setq org-startup-indented t)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-tags-column 0)
#+end_src

One of the many things I liked about Doom was the TODO settings.
Fast TODO selection was on by default, which I think is a great idea
if you are using more keywords than just TODO and DONE.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-use-fast-todo-selection t)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
;; Set org file associations
(setq org-file-apps
      `((auto-mode . emacs)
        (,(rx ".pdf::" (group (one-or-more digit)) string-end) . "zathura %s -P %1")
        (,(rx ".pdf" string-end) . "zathura %s")
        (directory . emacs)))

;; browser needs to be set with a separate function
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "qutebrowser")

;; Don't use blank lines between text and the following heading
(setq org-blank-before-new-entry
      '((heading . t) (plain-list-item . nil)))

;; Don't show empty lines between collapsed headings
(setq org-cycle-separator-lines 0)

;; Show tooltips.
;; I am using this for displaying org link paths.
;; This may not be the best use of the fns though,
;; and I have an alternative implementation.
(setq help-at-pt-display-when-idle t
      help-at-pt-timer-delay 0.1)
(help-at-pt-set-timer)

;; Org todo keywords and colours
(setq org-todo-keywords
      '((sequence "TODO(t)" "|" "DONE(d)")
        (sequence "NEXT(n)" "WAITING(w)" "LATER(l)" "LOOP(p)" "|" "CANCELLED(c)")))

;; Use LOOP keyword for repeating tasks
;; (after marking them as done)
(setq org-todo-repeat-to-state "LOOP")

;; Archive everything from org files in one directory
;; into a single hidden file.
(setq org-archive-location ".archive.org::")

;; My custom faces for todo items.
(defface +org-todo-important
  '((t :inherit org-todo
       :foreground "#dc322f"))
  "For very important todo items.")

;; Colour taken from hl-todo.
(defface +org-todo-unimportant
  '((t :inherit org-todo
       :foreground "#d0bf8f"))
  "For less urgent todo items.")

(setq org-todo-keyword-faces
      '(("LATER"     +org-todo-unimportant)
        ("NEXT"      +org-todo-important)
        ("WAITING"   +org-todo-unimportant)
        ("LOOP"      +org-todo-unimportant)
        ("CANCELLED" org-done)))

;; In the datetime prompt, if entering a time that has already
;; passed today, interpret it as a time for tomorrow.
(setq org-read-date-prefer-future 'time)
#+end_src

This bit of witchcraft, extracted from Doom and simplified, colours a file link with a different colour (from the current theme's warning face) if Emacs can't find the file it refers to. Very simple idea, but brilliant in its simplicity, and wonderfully executed.

#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
;; Source: https://github.com/doomemacs/doomemacs/blob/ba1dca322f9a07bc2b7bec6a98f2c3c55c0bbd77/modules/lang/org/config.el#L503-L517
;; Modify default file: links to colorize broken file links red
(org-link-set-parameters
 "file" :face (lambda (path)
                (if (file-exists-p path)
                    'org-link
                  '(warning org-link))))
#+end_src

** Org-src

I don't want to see any extra indentation in my source blocks, nor be asked questions about the safety of my own code.

#+begin_src emacs-lisp :tangle no :noweb-ref org-src-settings
(setq org-edit-src-content-indentation 0)
(setq org-confirm-babel-evaluate nil)
#+end_src

I mostly use org-src when editing this config, but since I've been doing that a lot lately, I decided to make it a little more comfortable for myself. I use my =ZZ= and =ZQ= bindings to exit org-src buffers with and without saving my changes, respectively.

#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(with-eval-after-load 'org-src
  (keymap-set org-src-mode-map "<remap> <save-buffers-kill-terminal>" 'org-edit-src-exit)
  (keymap-set org-src-mode-map "<remap> <save-buffers-kill-terminal>" 'org-edit-src-exit)
  (keymap-set org-src-mode-map "<remap> <kill-emacs>" #'org-edit-src-abort))
#+end_src

** Snippet expansion in org

Binding to =org-cycle= (usually TAB) or =org-ctrl-c-ctrl-c= does not follow the usual procedure. Because these keys are context-dependent to begin with, it's generally not a good idea to rebind them completely, since you might screw up additional contexts you didn't even realize were there before rebinding. Instead, additional functionality is added via hooks which are run before the main body of the function. If any of the functions returns a non-nil value, the main body is run instead. It's the next best thing to a =cond= in the function itself.

Trying to bind tempel's expansion to TAB was a tad involved. The expansion function returns a non-nil value even when it fails, and the =tempel-expand= function by itself does not expand when run programmatically. I ended up writing a small wrapper function that returns =nil= if an expansion fails, so that the hook can successfully fall through.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +tempel-expand-maybe ()
  "Try to expand a snippet with tempel.
If expansion fails, return nil.
This function is specifically for use with org-cycle."
  (ignore-errors ; <- returns nil instead of error
    (when meow-insert-mode
      (tempel-expand t))))
#+end_src

I then add the function to the hook run before =org-cycle=.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-cycle-tab-first . +tempel-expand-maybe)
#+end_src

** Org agenda

#+begin_src emacs-lisp
(use-package org-agenda
  :ensure nil
  :after org
  :bind
  (:map org-agenda-mode-map
   ("b" . org-agenda-earlier)
   ("f" . org-agenda-later)
   ("(" . org-agenda-earlier)
   (")" . org-agenda-later)
   ("u" . link-hint-open-link)
   ("v" . nil)
   ("vw" . org-agenda-week-view)
   ("vm" . org-agenda-month-view)
   ;; bit different behaviour from link-hint
   ("<return>" . org-agenda-goto)))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda
(setq org-agenda-files (list org-directory))

(setq org-agenda-window-setup 'only-window)

;; Display one week, always starting from Monday.
(setq org-agenda-span 'week
      org-agenda-start-on-weekday 1
      org-agenda-start-day ".")

;; Show full context after switching to an item from agenda
(map-put! org-fold-show-context-detail 'agenda 'tree)
;; shold this be in agenda settings?
(map-put! org-fold-show-context-detail 'default 'tree)
#+end_src

** Org bling

Org-mode is amazing, but doesn't look it out of the box. Some light eye candy makes it an even bigger pleasure to use.

I could also consider pimping my [[https://pank.eu/blog/pretty-babel-src-blocks.html][source blocks]]. Some of this functionality can be achieved through org-modern.

*** Org-modern

When using Doom, I bounced on one of its org beautification settings, which slowed down my Emacs quite noticeably. Right now I am using [[https://github.com/minad/org-modern][org-modern]] on a Surface Go 2, and it isn't slow at all.

I don't use all of the defaults though. I prefer my own faces for todos, and I'm not yet sure what to do with the tables.

With org-lists, I use "-" everywhere, because it's easily reachable on Dvorak. The defaults replacement for "-" is a longer dash, but I like nice fat dots instead.

#+begin_src emacs-lisp
(use-package org-modern
  :hook org-mode
  :config
  (setq org-modern-todo nil
        org-modern-table nil)
  (map-put! org-modern-list ?- "•"))
#+end_src

*** Table alignment with valign

Valign works much better with tables containing CJK and symbols than other similar packages. However, I've had it be a little slow, so I'm not turning it on by default, at least not yet.

#+begin_src emacs-lisp
(use-package valign
  :commands (valign-mode))
#+end_src

*** Font lock for text in org checked items

Yet another fantastic idea from Doom: a special face for list items with a checked checkbox, as in this example:

- [ ] unchecked
- [X] checked

Headings with DONE have a special face that's in-built and can be customized, but the same does not exist for checked list items. Doom had its own workaround, which I was unable to find after a couple days' searching, but I did find [[https://fuco1.github.io/2017-05-25-Fontify-done-checkbox-items-in-org-mode.html][this blog post]], which referenced hlissner's config from 2017 (aka proto-Doom). Based on the code therein and on the [[info:elisp#Search-based Fontification][info node]], I wrote my own version. I use a simpler regex than what I've seen online, because I don't use =[X/Y]= in checkboxes.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-add-checked-font-lock ()
  (font-lock-add-keywords
   nil
   ;; (rx (seq line-start (* space) "- [X] " (+ not-newline)))
   `(("^[[:space:]]*- \\[X] .+" 0 'org-headline-done prepend))
   'append))
#+end_src

Using a hook appears to be more reliable than just a bare =font-lock-add-keywords= setting, though. I'm not sure why, since other people's configs use it without a hook. Some part of my config must be interfering with it.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-mode . +org-add-checked-font-lock)
#+end_src

*** Org-appear

Hiding emphasis markers in org-mode makes it look quite nice, however it also makes editing more difficult. The [[https://github.com/awth13/org-appear][org-appear]] package shows hidden emphasis markers when the cursor is on an emphasized word, solving that problem.

#+begin_src emacs-lisp
(use-package org-appear
  :commands (org-appear-mode))
#+end_src

I hook the package to open together with org.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-mode . org-appear-mode)
#+end_src

Now the emphasis markers may safely be hidden.

#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-hide-emphasis-markers t)
#+end_src

** Transient navigation

Instead of pressing key combinations or chords repeatedly to navigate,
we can define a transient state and use simple keys while in it.
I got the idea from [[https://github.com/Somelauw/evil-org-mode/blob/master/doc/example_config.el][this evil-org example]] that uses hydra,
but I'm using transient because I'm more used to it,
and because it's now built into Emacs (as of 28).

#+begin_src emacs-lisp :tangle no :noweb-ref org-navigation-transient
(defmacro with-org-show (&rest body)
  `(progn
     ,@body
     (+scroll-line-to-top)
     (org-fold-show-entry)
     (org-fold-show-children)))

;; This is not in the transient, move out
(defun +org-up-heading ()
  "Go up to the nearest heading, or to a higher level heading.
If not on a heading, finds the next heading backwards.
If already on a heading, goes higher up in the tree. This
makes sense to me to combine into a single keybinding."
  (interactive)
  (if (org-at-heading-p)
      (with-org-show
       (org-previous-visible-heading 1))
    (org-back-to-heading)))

(defun +org-up-level-and-show ()
  (interactive)
  (cond
   ((not (org-at-heading-p)) (org-back-to-heading))
   ((= 1 (org-current-level)) (ignore))
   (t (org-up-element))))

  ;; (with-org-show
  ;;  (org-up-heading-safe)))

(defun +org-down-and-show ()
  (interactive)
  (when (org-at-heading-p)
    (with-org-show
     (org-next-visible-heading 1))))

(defun +org-up-same-level ()
  (interactive)
  (with-org-show
   (org-fold-hide-subtree)
   (org-backward-heading-same-level 1 t)))

(defun +org-down-same-level ()
  (interactive)
  (with-org-show
   (org-fold-hide-subtree)
   (org-forward-heading-same-level 1 t)))

;; add link-hint on u?
(transient-define-prefix +org-movement-transient ()
  ["Moving around in org"
   [("h" "up level" +org-up-level-and-show :transient t)
    ("c" "up (same level)" +org-up-heading :transient t)
    ("t" "down (same level)" +org-down-same-level :transient t)
    ("n" "down level" +org-down-and-show :transient t)]
   [("<tab>" "cycle" org-cycle :transient t)
    ("<backtab>" "cycle all" org-shifttab :transient t)
    ("<SPC>" "scroll down" scroll-up :transient t)]
   [("q" "quit" transient-quit-all)]])
#+end_src

** Pandoc integration

My personal interface to pandoc from Emacs
is written in a [[./pandoc.el][separate file]] as a module.
There is a single entry point: a transient function
(aptly named =pandoc-transient=),
which allows the user to interactively
construct a pandoc call, and then executes it.

I might make it into its own package later,
but there is currently no shortage of pandoc APIs for Emacs,
and my version is very much tailored to my personal needs
and those alone.

Here we load the file.
#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "pandoc.el"))
#+end_src

The only keybinding required is for the transient entry point.
#+begin_src emacs-lisp :tangle no
(evil-define-key 'normal org-mode-map
  (kbd "<localleader>p") #'pandoc-transient)
#+end_src

** Links

#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "links.el"))
#+end_src

#+begin_src emacs-lisp
(transient-define-prefix +link-transient ()
  ["Org links"
   ["insert link..."
    ("l" "do-what-i-mean" +org-link-dwim)
    ("c" "from clipboard" +org-insert-link-from-clipboard)
    ("f" "to file" +org-insert-file-path)]
   ["link to org heading..."
    ("h" "with heading text" +org-insert-link)
    ("u" "with a unique ID" +org-insert-link-with-id)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Link path tooltip

Usually, we hide link URLs and display just the description.
Doom Emacs shows a link URL tooltip in the echo area,
similar to how eldoc shows the documentation for the function at point.
That's pretty neat functionality, but it was surprisingly difficult to search for online.
I found no discussions or questions about this sort of feature.

This is a relatively simple implementation.
The function itself checks if the point is in a link regex, and if it is,
displays the first group (the URL) as a message.
I then hook it up to =post-command-hook= *locally*,
so that it only works in org-mode.

I currently have it *turned off* because I'm using =help-at-pt-set-timer=
(NB: check source of the fn, see also [[info:elisp#Idle Timers][info node]]).
However, my approach is more flexible, and I might want to come back to it.

#+begin_src emacs-lisp :tangle no
(defun +org-link-tooltip ()
  "Display the URL of the link at point in the echo area."
  (interactive) ; for testing purposes only
  (when (org-in-regexp org-link-bracket-re)
    (message "Link: %s" (match-string 1))))

(add-hook 'org-mode-hook
          (lambda ()
            (add-hook 'post-command-hook #'+org-link-tooltip 0 'local)))
#+end_src

** Cross-referencing

#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "refs.el"))
#+end_src

I should think about an insert mode keybinding, too.

#+begin_src emacs-lisp :tangle no
(evil-define-key 'normal org-mode-map
  (kbd "<localleader>r") #'+ref-transient)
#+end_src

Again, a transient.
Since I'm using transients instead of regular evil keybindings,
I could make capitalization an infix instead of having separate bindings.
Although it's not like I'm running out of keys. Something to ponder.

#+begin_src emacs-lisp
(transient-define-prefix +ref-transient ()
  ["Pandoc cross-references in Org"
   ["insert reference..."
    ("h" "to heading" +ref-insert-ref-heading)
    ("t" "to table" +ref-insert-ref-table)
    ("f" "to figure" +ref-insert-ref-figure)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Org cite

#+begin_src emacs-lisp :tangle no :noweb-ref org-cite
(defun +ebib-open-on-citation (citation _)
  (let ((key (map-elt (cadr citation) :key)))
    (ebib)
    (ebib-db-set-current-entry-key key ebib--cur-db)
    (ebib--update-buffers 'no-refresh)))

(org-cite-register-processor '+org-cite-follow-processor
  ;; Note that the citation is passed as an object, not a string.
  ;; The follow function must take two arguments.
  ;; See `org-cite-register-processor' documentation for details.
  :follow #'+ebib-open-on-citation)

(setq org-cite-global-bibliography (list my/default-bibliography))
(setq org-cite-follow-processor '+org-cite-follow-processor)
#+end_src

** Org functions

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-remove-tags ()
  "Remove all tags from current heading."
  (interactive)
  (org-set-tags nil))

(defun +org-list-insert-and-indent (&optional checkbox?)
  "Insert a new row in a list.
Respects current indentation and checkbox."
  (let ((indentation (current-indentation)))
    (end-of-line)
    (org-insert-item checkbox?)
    (indent-line-to indentation)
    (end-of-line)
    (evil-insert-state)))

(defun +org-insert-item ()
  "Insert an item determined from context."
  (interactive)
  (cond
   ;; list with checkboxes
   ((org-at-item-checkbox-p) (+org-list-insert-and-indent 'checkbox))
   ;; list without checkboxes
   ((org-at-item-p) (+org-list-insert-and-indent))
   ;; if in a table, break the table at that row
   ;; (since RET jumps to next row, adding one if needed)
   ((org-at-table-p)
    (progn
      (end-of-line)
      (newline)))
   ;; fall back to heading insertion
   (t (org-insert-heading-respect-content))))
#+end_src

*** My version of org-return

I believe org-mode first started the fashion of
contextually dependent actions in Emacs (aka "dwim").
Then Doom took it and expanded it further.
The idea is great, and here I put my own spin on it.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-return ()
  "Perform an action dependent on context.
If on a...
- list item with checkbox: toggle checkbox.
- table: move to next row, possibly creating one (jump out of table with =C-RET=).
- image or image link: toggle displaying the image.
- citation: open in ebib.
- URL: open it.
- org link: follow it.
- source block: edit it.
"
  (interactive)
  (cond
   ;; table, including in insert state
   ((org-at-table-p) (org-table-next-row))
   ;; insert state everywhere else
   ((meow-insert-mode-p) (newline-and-indent))
   ;; list with checkbox
   ((org-at-item-checkbox-p) (org-toggle-checkbox))
   ;; image
   ((when-cond ((bounds (org-in-regexp +org-image-regexp)))
      (+org-toggle-image (car bounds) (cdr bounds))))
   ;; citation
   ((when-cond ((bounds (org-in-regexp +org-cite-regexp)))
      (+org-follow-cite (car bounds) (cdr bounds))))
   ;; a regular URL string with no description
   ((when-cond ((bounds (org-in-regexp +url-regexp))
                (url (buffer-substring-no-properties (car bounds) (cdr bounds))))
      (browse-url url)))
   ;; an org link of any kind, including URLs with descriptions
   ((org-in-regexp org-link-bracket-re) (link-hint-open-link-at-point))
   ;; org-src block
   ((org-in-src-block-p) (org-edit-src-code))
   ;; Default action
   (t nil)))

(defmacro when-cond (spec &rest body)
  "Like `when-let', but returns true on successful binding.
For use inside `cond'."
  (declare (indent 1) (debug if-let))
  `(if-let ,spec ,(macroexp-progn (append body (list t)))))

(defun +org-follow-cite (beg end)
  (let* ((keys (->> (buffer-substring-no-properties beg end)
                    (s-match-strings-all +org-cite-key-regexp)
                    (-map #'-second-item))))
    (pcase (length keys)
      (0 (user-error "No keys found!"))
      (1 (+ebib-open-on-key (car keys)))
      (_ (let ((key (completing-read "Choose key to open: " keys)))
           (+ebib-open-on-key key))))))

(defvar +org-cite-regexp
  (rx (seq "[cite"
           (opt ?/ (one-or-more (any alnum ?/ ?_ ?-)))
           ":" (zero-or-more (not (any ?\[ ?\]))) "]")))

(defvar +org-cite-key-regexp
  (rx (seq "@" (group (one-or-more (or alnum ?- ?_))))))

(defun +ebib-open-on-key (key)
  (ebib)
  (ebib-db-set-current-entry-key key ebib--cur-db)
  (ebib--update-buffers 'no-refresh))

(defun +org-toggle-image (beg end)
  (org-toggle-inline-images nil beg end))

(defvar +org-image-regexp
  (rx (seq "[[./" (+? anything) "." (or "png" "jpg" "jpeg" "svg") "]]")))

(with-eval-after-load 'thingatpt
  (defvar +url-regexp
    (concat "\\<"
            (regexp-opt '("http://" "https://" "doi:") t)
            thing-at-point-url-path-regexp)
    "Basically a simplified version of `goto-address-url-regxp'"))
#+end_src

*** Org table row insertion

An idea I stole from [[https://github.com/Somelauw/evil-org-mode/blob/b1f309726b1326e1a103742524ec331789f2bf94/evil-org.el#L86-L91][evil-org]] that goes something like this: instead of regular newline insertion above/below the current line, insert a new table row if the point is inside a table. Since in regular text this enters insert state, I do the same in tables.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-table-insert-row (&optional below?)
  "Create a new table row and enter insert state in it in the same column."
  (when (region-active-p)
    (meow-cancel-selection))
  (let ((col (org-table-current-column)))
    (org-table-insert-row below?)
    (org-table-goto-column col)
    (meow-insert)))

(defun +org-open-below ()
  (interactive)
  (if (org-at-table-p)
      (+org-table-insert-row 'below)
    (meow-open-below)))

(defun +org-open-above ()
  (interactive)
  (if (org-at-table-p)
      (+org-table-insert-row)
    (meow-open-above)))
#+end_src

** Org-refile

This bit of code works. I should test it more.
Right now it does not move the pointer after refiling.
Do I want to move to the new position? Depends.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-refile-to-this-file ()
  (interactive)
  (let* ((loc-pair (save-excursion
                     (consult-org-heading)
                     (cons (org-get-heading) (point))))
         (heading (car loc-pair))
         (location (cdr loc-pair)))
    (org-refile nil
                (current-buffer)
                (list heading (buffer-file-name) nil location))))
#+end_src

** Toc-org

#+begin_src emacs-lisp
(use-package toc-org
  :after org
  :hook (org-mode . toc-org-mode))
#+end_src

* Bibliography and citations

** Ebib

TODOs:
- disabled notes for now, figure out later

#+begin_src emacs-lisp :noweb yes
(use-package ebib
  :commands (ebib ebib-insert-citation)
  :bind
  <<ebib-keybindings>>
  :config
  <<ebib-functions>>
  <<ebib-settings>>)
#+end_src

*** Settings

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-settings
(setq ebib-preload-bib-files (list my/default-bibliography))
;; (setq ebib-notes-directory my/ebib-notes)
(setq ebib-file-search-dirs (list my/ebib-file-search-dir))
(setq ebib-import-directory my/ebib-import-directory)
(setq ebib-file-associations '(("pdf" . "zathura") ("ps" . "gv")))
(setq ebib-bibtex-dialect 'biblatex)
(setq ebib-citation-insert-multiple t)
(setq ebib-index-columns '(("Author/Editor" 20 t)
                           ("Year" 6 t)
                           ("Title" 40 t)))
(map-put! ebib-reference-templates
          "Article"
          "{Author}. {Date|Year}. {\"Title\".} {Journaltitle|Journal} {Volume}{(Issue)}{:Pages}.{ Doi.}")
(map-put! ebib-reference-templates
          "Book"
          "{Author|Editor}. {Date|Year}. {\"Title\".} {Address: }{Publisher.}")
(setq ebib-notes-name-transform-function #'identity)
(setq ebib-name-transform-function #'+ebib-generate-filename)

;; Set auto-generated citation key options
(setq bibtex-autokey-year-length 4
      bibtex-autokey-titleword-length 0
      bibtex-autokey-name-separator "-"
      bibtex-autokey-year-title-separator ""
      bibtex-autokey-edit-before-use t)
(setq ebib-uniquify-keys t)

(map-put! ebib-citation-commands
          'org-mode
          '((("text" "[cite/t: %(@%K%< %A%>%; )]")
             ("paren" "[cite: %(@%K%< %A%>%; )]")
             ("bare" "@%K")
             ("no-name" "[cite/na: %(@%K%< %A%>%; )]"))))
(map-put! ebib-citation-commands
          'markdown-mode
          '((("text" "@%K%< [%A]%>")
             ("paren" "[%(@%K%<, %A%>%; )]")
             ("year" "[-@%K%< %A%>]"))))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-settings
(add-hook 'ebib-index-mode-hook #'turn-on-truncate-lines)
(add-hook 'ebib-index-mode-hook #'turn-off-visual-line-mode)
#+end_src

*** Functions

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-functions
(defun +ebib-get-author-names (key)
  (let ((names
         (->>
          (ebib-get-field-value "author" key ebib--cur-db "default" 'unbraced)
          (s-split " and ")
          (--map (car (s-split "," it))))))
    (if (< 2 (length names))
        (concat (car names) " et al")
      (s-join " and " names))))

(defun +ebib-get-year (key)
  (let ((date
         (or
          (ebib-get-field-value "date" key ebib--cur-db 'noerror 'unbraced)
          (ebib-get-field-value "year" key ebib--cur-db 'noerror 'unbraced))))
    (->> date
         (s-split "-")
         (-first-item))))

(defun +ebib-get-title (key)
  (let ((title
         (->> (ebib-get-field-value "title" key ebib--cur-db "default" 'unbraced)
              (s-split ":")
              (car)
              (replace-regexp-in-string "[{}]" "")
              (s-trim))))
    (s-truncate 100 title "")))

(defun +ebib-generate-filename (key)
  (let ((names (+ebib-get-author-names key))
        (year (+ebib-get-year key))
        (title (+ebib-get-title key)))
    (->> (list names year title)
         (-non-nil)
         (s-join " ")
         (replace-regexp-in-string "/" "")
         (replace-regexp-in-string "," "")
         (replace-regexp-in-string " " "_"))))

(defun +ebib-edit-as-string ()
  "Edit the current field as a string.
This is a function for `ebib-entry-mode'. Since `ebib-edit-field'
has to take a numeric prefix /= 1 in order to begin string
editing, it seems easier to abstract this into a function and
give it its own name and keybinding."
  (interactive)
  (ebib-edit-field 2))

(defun +ebib-import-file-from-index ()
  "Import a file and add to the entry at point.
Used from the ebib index."
  (interactive)
  (ebib-edit-entry)
  (ebib-import-file nil)
  (ebib-quit-entry-buffer))
#+end_src

*** Keybindings

Meow-agnostic keybindings for ebib. I should unbind or rebind "h" and "n" though, since lateral movement doesn't figure in ebib.

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-keybindings
(:map ebib-index-mode-map
      ("q" . ebib-quit)
      ("s" . ebib-save-current-database)
      ("S" . ebib-save-all-databases)
      ;; Unset N while I'm figuring out what to do with notes.
      ("N" . nil)
      ("/" . ebib-jump-to-entry)
      ("<tab>" . ebib-edit-entry)
      ;; ("of" . +ebib-import-file-from-index)
 :map ebib-entry-mode-map
      ("q" . ebib-quit)
      ("z" . ebib-leave-ebib-windows)
      ("E" . +ebib-edit-as-string)
      ("s" . ebib-save-current-database)
      ("S" . ebib-save-all-databases)
      ("D" . ebib-delete-current-field-contents)
      ("<tab>" . ebib-quit-entry-buffer)
      ;; ("of" . ebib-import-file)
      )
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-keybindings-evil
(evil-define-key 'normal ebib-index-mode-map
  "q" #'ebib-quit
  "s" #'ebib-save-current-database
  "S" #'ebib-save-all-databases
  "/" #'ebib-jump-to-entry
  (kbd "<tab>") #'ebib-edit-entry
  (kbd "<localleader>f") #'+ebib-import-file-from-index)

;; Unset N while I'm figuring out what to do with notes.
(keymap-unset ebib-index-mode-map "N")

(evil-define-key 'normal ebib-entry-mode-map
  "q" #'ebib-quit
  "z" #'ebib-leave-ebib-windows
  "E" #'+ebib-edit-as-string
  "s" #'ebib-save-current-database
  "S" #'ebib-save-all-databases
  "D" #'ebib-delete-current-field-contents
  (kbd "<tab>") #'ebib-quit-entry-buffer
  (kbd "<localleader>f") #'ebib-import-file)
#+end_src

* Programming languages

** Lisps
Smartparens is THE package for lisp code editing.
#+begin_src emacs-lisp :noweb yes
(use-package smartparens
  :hook (prog-mode) ;; should probably narrow it down to lisps
  :config
  ;; load default config
  (require 'smartparens-config)
  ;; <<smartparens-keybindings>>
  )
#+end_src

#+begin_src emacs-lisp
(use-package eros
  :hook emacs-lisp-mode)
#+end_src

Examples can be found in the [[https://github.com/Fuco1/smartparens/wiki][wiki]] and in [[https://ebzzry.com/en/emacs-pairs/][this article]].

** Emacs Lisp

#+begin_src emacs-lisp
(use-package elisp-mode
  :ensure nil
  :bind (:map emacs-lisp-mode-map
              ("C-c o e" . +elisp-eval-transient)
              ("C-c o w" . sp-wrap-round)
              ("C-c o (" . sp-backward-slurp-sexp)
              ("C-c o )" . sp-forward-slurp-sexp)
              ("C-c o <" . sp-backward-barf-sexp)
              ("C-c o >" . sp-forward-barf-sexp)))
#+end_src

#+begin_src emacs-lisp
(use-package eldoc
  :config
  (setq eldoc-idle-delay 0))
#+end_src

#+begin_src emacs-lisp
(use-package elisp-demos
  :after helpful
  :config
  (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

#+begin_src emacs-lisp
(transient-define-prefix +elisp-eval-transient ()
  ["Eval..."
   ("e" "last sexp" eval-last-sexp)
   ("r" "and replace" crux-eval-and-replace)
   ("b" "buffer" eval-buffer)])
#+end_src

** Clojure

See also the following:
- [[https://github.com/clojure-emacs/clojure-mode/][clojure-mode]]
- [[https://github.com/clojure-emacs/cider][cider]]
- [[https://github.com/clojure-emacs/clj-refactor.el][clj-refactor]]
- [[https://docs.doomemacs.org/latest/modules/lang/clojure/][clojure doom module]]

#+begin_src emacs-lisp
(use-package clojure-mode
  :defer t
  :config
  (evil-define-key 'normal clojure-mode-map
    (kbd "<localleader>'") #'cider-jack-in))
#+end_src

#+begin_src emacs-lisp
(use-package cider
  :commands (cider-jack-in cider-jack-in-clj cider-jack-in-cljs
             cider-connect-clj cider-connect-cljs)
  :config
  (setq cider-allow-jack-in-without-project t
        cider-jack-in-default 'babashka
        cider-repl-pop-to-buffer-on-connect nil)

  (evil-define-key 'normal clojure-mode-map
    (kbd "<localleader>ee") #'cider-eval-last-sexp
    (kbd "<localleader>pp") #'cider-pprint-eval-last-sexp-to-comment
    (kbd "<localleader>(") #'sp-backward-slurp-sexp
    (kbd "<localleader>)") #'sp-forward-slurp-sexp
    (kbd "<localleader>rq") #'cider-quit))
#+end_src

* Utils
** Magit

Consider also [[https://github.com/alphapapa/magit-todos][magit-todos]].

#+begin_src emacs-lisp
(use-package magit
  :commands (magit)
  :bind (:map magit-mode-map
         ("p" . magit-push)
         ("f" . magit-pull)
         :map magit-diff-section-map
         ("C" . magit-commit))
  :config
  (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
  (setq git-commit-summary-max-length 50)
  (add-hook 'git-commit-setup-hook #'meow-insert 90)
  (with-eval-after-load 'magit
    (define-key git-commit-mode-map [remap save-buffers-kill-terminal] 'with-editor-finish)
    (define-key git-commit-mode-map [remap kill-emacs]                 'with-editor-cancel)))
#+end_src

*** Git diff highlighting

Changed the settings using [[https://www.reddit.com/r/emacs/comments/582yms/question_changing_the_colour_of_diffhl_indicators/][this discussion]] as a reference.
#+begin_src emacs-lisp :noweb yes
(use-package diff-hl
  :defer 2
  :config
  <<diff-hl-colors>>
  (diff-hl-flydiff-mode)
  (global-diff-hl-mode)
  ;; <<diff-hl-keybindings>>
  )
#+end_src

I stole the insert and delete shades from Doom, because they look really good.

#+begin_src emacs-lisp :tangle no :noweb-ref diff-hl-colors
(custom-set-faces
 '(diff-hl-change ((t (:background "orange2" :foreground "orange2")))) ; #cb4b16
 '(diff-hl-insert ((t (:background "#859900" :foreground "#859900"))))
 '(diff-hl-delete ((t (:background "#dc322f" :foreground "#dc322f")))))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref diff-hl-keybindings
(evil-define-key 'normal 'global
  (kbd "]h") #'diff-hl-next-hunk
  (kbd "[h") #'diff-hl-previous-hunk)
#+end_src

** Tempel snippets
:PROPERTIES:
:ID:       0118536f-8f2f-4e6d-ab30-66bd3101401d
:END:
Trying https://github.com/minad/tempel.

Once I'm inside a snippet, chances are I no longer need to expand more snippets. Instead, I want to be able to use TAB to jump to next placeholder, or move the point after the snippet.

#+begin_src elisp :noweb yes
(use-package tempel
  :commands (tempel-expand)
  :bind (:map tempel-map
          ("TAB" . tempel-next)
          ("<escape>" . tempel-done)))
#+end_src

** Modeline

 Currently using [[https://gitlab.com/jessieh/mood-line][mood-line]] (see [[https://www.reddit.com/r/emacs/comments/c5mel4/what_mode_line_do_you_use_and_why/][here]] for more great packages.)

#+begin_src emacs-lisp
(use-package mood-line
  :config
  ;; can't use unicode glyphs with my current font
  (setq mood-line-glyph-alist mood-line-glyphs-fira-code)
  (mood-line-mode)

  (setq mood-line-format
        (mood-line-defformat
         :left
         (((mood-line-segment-modal) . " ")
          ((or (mood-line-segment-buffer-status) " ") . " ")
          ((mood-line-segment-buffer-name) . " ")
          ((mood-line-segment-anzu) . " ")
          ((mood-line-segment-cursor-position) . " ")
          ((mood-line-segment-scroll) . " "))
         :right
         (((mood-line-segment-vc) . "  ")
          ((mood-line-segment-major-mode) . "  ")
          ((mood-line-segment-misc-info) . "  ")
          ((mood-line-segment-checker) . "  ")
          ((mood-line-segment-process) . "  ")))))
#+end_src

** Crux

#+begin_src emacs-lisp
(use-package crux
  :commands (crux-delete-file-and-buffer
             crux-rename-file-and-buffer
             crux-sudo-edit
             crux-move-beginning-of-line
             crux-eval-and-replace))
#+end_src

** Avy

#+begin_src emacs-lisp
(use-package avy
  :config
  ;; use Dvorak home row hints
  (setq avy-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n ?s)))
#+end_src

** Link hinting
:PROPERTIES:
:ID:       067dfe76-a65f-44b6-ab9d-a72b875071d2
:END:

#+begin_src elisp :noweb yes
(use-package link-hint
  :commands (link-hint-open-link link-hint-open-link-at-point)
  :config
  <<link-hint-org-cite>>)
#+end_src

Here I add a new link type for org citations.
(Some of the relevant code, e.g. =+org-follow-cite=, is defined elsewhere in the config.)
The =:next= and =:at-point-p= keywords are required by link-hint,
and =:open= is the functionality that I want.
This lets me call link-hint the way I normally do,
and through it open citations with my custom function.

#+begin_src emacs-lisp :tangle no :noweb-ref link-hint-org-cite
(link-hint-define-type 'org-cite
  :next #'link-hint--next-org-cite
  :at-point-p #'+org-at-cite-p
  :open #'+org-follow-cite)

(push 'link-hint-org-cite link-hint-types)

(defun +org-at-cite-p ()
  "If the point is on an org citation, return its bounds.
The bounds are returned as a list, to be passed to `+org-follow-cite'."
  (flatten-tree (org-in-regexp +org-cite-regexp)))

(defun link-hint--find-org-cite (start-bound end-bound)
  "Find the first file link.
Only search the range between just after START-BOUND and END-BOUND."
  (save-excursion
    (let (org-cite-pos)
      (goto-char start-bound)
      (link-hint--find-regexp +org-cite-regexp
                              (point) end-bound))))

(defun link-hint--next-org-cite (bound)
  "Find the next org citation.
Only search the range between just after the point and BOUND."
  (link-hint--find-org-cite (point) bound))
#+end_src

** Anzu

[[https://github.com/emacsorphanage/anzu][Anzu]] is a small but pretty important package
that shows the number of search matches in the modeline.
It stays completely out of the way
until you search for occurrences of something,
and then it's indispensable.

#+begin_src emacs-lisp
(use-package anzu
  :init (global-anzu-mode 1))
#+end_src

** hl-todo

#+begin_src emacs-lisp
(use-package hl-todo
  :defer 2
  :config (global-hl-todo-mode 1)
  (transient-define-prefix +hl-todo-transient ()
    ["Change margins..."
     ("n" "next" hl-todo-next :transient t)
     ("p" "previous" hl-todo-previous :transient t)
     ("q" "quit" transient-quit-all)]))
#+end_src

** Olivetti

#+begin_src emacs-lisp
(use-package olivetti
  :commands (olivetti-mode)
  :hook (Info-mode . olivetti-mode)
  :config
  (setq-default olivetti-body-width 60)
  (defun turn-off-olivetti-mode ()
    (interactive)
    (olivetti-mode -1)))
#+end_src

** ws-butler
One more package I learned of from Doom's config.

#+begin_src emacs-lisp
(use-package ws-butler
  :init (ws-butler-global-mode 1))
#+end_src

** Help

https://github.com/Wilfred/helpful

#+begin_src emacs-lisp
(use-package helpful
  :commands (+helpful-transient))
#+end_src

** TODO Undo
See also Hints and undo-fu-session [[https://codeberg.org/ideasman42/emacs-undo-fu][here]].
Can also try [[https://github.com/casouri/vundo][vundo]], although my undo needs aren't that sophisticated.

#+begin_src emacs-lisp
(use-package undo-fu)
#+end_src

** Evil-numbers

Another small package, this time to manipulate numbers.
I occasionally find myself needing to add/subtract a sum
from numbers on a bunch of lines, so this is handy for those situations.

#+begin_src emacs-lisp
(use-package evil-numbers
  :commands (evil-numbers/inc-at-pt
             evil-numbers/dec-at-pt
             evil-numbers/inc-at-pt-incremental
             evil-numbers/dec-at-pt-incremental))
#+end_src

* Finalize

Trick from [[https://blog.d46.us/advanced-emacs-startup/][here]]:
I increase the garbage collection threshold
during startup to speed up Emacs' load time,
but then decrease it once my config loads
so that GC pauses aren't so noticeable
when I'm actually using Emacs.

#+begin_src emacs-lisp
(setq gc-cons-threshold (* 2 1000 1000))
#+end_src

* More packages :noexport:

Here are some packages I should consider trying out:
- Startup screen
  - https://github.com/emacs-dashboard/emacs-dashboard
  - https://github.com/ichernyshovvv/enlight
  - I could also go straight into org-agenda on startup
- https://github.com/alphapapa/org-super-agenda
- https://github.com/jacktasia/dumb-jump for jumping to definition
- https://github.com/jamescherti/inhibit-mouse.el <- completely disable the mouse
- What's the Doom package that shows usage examples in the help menu? I think it's [[https://github.com/xuchunyang/elisp-demos][elisp-demos]]
- https://github.com/emacsorphanage/macrostep
- https://github.com/snosov1/toc-org
- https://github.com/wwwjfy/emacs-fish
- https://github.com/yoshiki/yaml-mode
- https://github.com/emacsorphanage/quickrun
- https://github.com/radian-software/apheleia/
- https://github.com/jorgenschaefer/emacs-buttercup
- https://github.com/hlissner/emacs-solaire-mode (necessary? I don't use splits that much)
- https://github.com/kuanyui/tldr.el
- https://github.com/manateelazycat/lsp-bridge <- eglot alternative, advertised as blazingly fast
- https://github.com/flycheck/flycheck
- https://github.com/minad/jinx for spelling
- Think about giving Dired another go
  - Check the [[https://github.com/Fuco1/dired-hacks][dired hacks]] repo for more dired related packages.
- Should also look into terminal emulation in Emacs perhaps. Then again, perhaps not.
- Org-mode:
  - https://github.com/rougier/agenda <- python script, but might be useful?
- https://github.com/Wilfred/deadgrep
- https://github.com/vedang/pdf-tools
- Mail? Consider.
- https://github.com/progfolio/elpaca consider

A few useful packages are mentioned [[https://blog.d46.us/advanced-emacs-startup/][here]] as well.

For more packages see here:
https://github.com/emacs-tw/awesome-emacs
