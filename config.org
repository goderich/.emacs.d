* Table of Contents :TOC:
- [[#introduction][Introduction]]
  - [[#history][History]]
  - [[#resources][Resources]]
- [[#basic-settings][Basic settings]]
  - [[#early-loading][Early loading]]
  - [[#package-management][Package management]]
  - [[#in-built-packages][In-built packages]]
  - [[#vars][Vars]]
  - [[#theming][Theming]]
  - [[#fonts][Fonts]]
  - [[#dashboard][Dashboard]]
  - [[#utility-functions][Utility functions]]
- [[#meow-disabled][Meow (DISABLED)]]
  - [[#leader-map-bindings][Leader map bindings]]
  - [[#normal-state-bindings][Normal state bindings]]
  - [[#motion-state-bindings][Motion state bindings]]
  - [[#insert-state-bindings][Insert state bindings]]
  - [[#global-bindings][Global bindings]]
  - [[#meow-functions][Meow functions]]
  - [[#meow-settings][Meow settings]]
  - [[#meow-packages-and-resources][Meow packages and resources]]
- [[#boon][Boon]]
- [[#minibuffer-keybindings][Minibuffer keybindings]]
- [[#transient-commands][Transient commands]]
  - [[#window-resizing-transient][Window resizing transient]]
  - [[#file-transient][File transient]]
  - [[#buffer-transient][Buffer transient]]
  - [[#helpful-transient][Helpful transient]]
  - [[#olivetti-transient][Olivetti transient]]
- [[#narrowing-and-completion][Narrowing and completion]]
  - [[#narrowing][Narrowing]]
  - [[#completion-corfu][Completion (Corfu)]]
- [[#org-mode][Org-mode]]
  - [[#org-settings][Org settings]]
  - [[#org-src][Org-src]]
  - [[#snippet-expansion-in-org][Snippet expansion in org]]
  - [[#org-agenda][Org agenda]]
  - [[#org-bling][Org bling]]
  - [[#transient-navigation][Transient navigation]]
  - [[#pandoc-integration][Pandoc integration]]
  - [[#links][Links]]
  - [[#cross-referencing][Cross-referencing]]
  - [[#org-cite][Org cite]]
  - [[#org-functions][Org functions]]
  - [[#toc-org][Toc-org]]
- [[#bibliography-and-citations][Bibliography and citations]]
  - [[#ebib][Ebib]]
- [[#programming-languages][Programming languages]]
  - [[#lisps][Lisps]]
  - [[#emacs-lisp][Emacs Lisp]]
  - [[#clojure][Clojure]]
- [[#utils][Utils]]
  - [[#magit][Magit]]
  - [[#tempel-snippets][Tempel snippets]]
  - [[#modeline][Modeline]]
  - [[#crux][Crux]]
  - [[#avy][Avy]]
  - [[#link-hinting][Link hinting]]
  - [[#anzu][Anzu]]
  - [[#hl-todo][hl-todo]]
  - [[#olivetti][Olivetti]]
  - [[#ws-butler][ws-butler]]
  - [[#help][Help]]
  - [[#tldr][Tldr]]
  - [[#undo][Undo]]
  - [[#evil-numbers][Evil-numbers]]
- [[#finalize][Finalize]]

* Introduction

Welcome to my literate Emacs configuration file! I suggest you read this section first before you go on. Note that a few of the links in this file are org-mode links. If you are reading this file online and stumble across a seemingly dead link, it might simply be an org link.

My config is:
- [[https://harryrschwartz.com/2016/02/15/switching-to-a-literate-emacs-configuration][literate]],
- centered on [[https://github.com/jwiegley/use-package][use-package]] with defers,
- based around modal editing, currently +meow+ [[https://github.com/jyp/boon][boon]],
- [[https://github.com/magit/transient][transient]]- and leader-key heavy,
- full of my personal functions and quirks,
- still very much in flux.

Let's break some of the above down a little.

=use-package= is favoured by many Emacs gurus as a configuration technique /par excellence/ (along with literal configs of course). It helps keep related code in one place, instead of all around your config. And since it's included in newer versions of Emacs, using it is a no-brainer.

Crucially, =use-package= also supports lazy loading (i.e. delayed evaluation), which speeds up Emacs start-up time tremendously. The term used in =use-package= for this is 'defer'. Deferring packages is not particularly difficult, but it does require some thinking ahead and maybe tinkering. Of course, optimization is a never-ending game, but I try to keep it reasonable. As of this writing, Emacs starts in 2.6 seconds on my Surface Go 2 tablet (and a lot faster on my laptop and desktop), so I'm happy with where it is right now.

One more thing I'm doing with my literate config is splitting the source blocks with [[https://orgmode.org/manual/Noweb-Reference-Syntax.html][noweb]]. It goes like this: all the configuration and customization associated with a single package goes into one =use-package= block. That's simple and it makes sense. However, sometimes there is too much configuration, and the blocks get too long. I could add comments directly inside the source code (and I do that in a few places), but that seems to run counter to the core tenets of literate programming. Noweb allows me to separate blocks in the literate file to structure my text around them as I please, but still string them together when [[https://orgmode.org/manual/Extracting-Source-Code.html][tangling]] the resulting Elisp source file.

I am currently using the =meow= package for modal editing. However, my keybindings are somewhat idiosyncratic if not outright esoteric. This is partly to do with me using the [[https://en.wikipedia.org/wiki/Dvorak_layout][Dvorak]] layout on all my keyboards, and partly with the kind of configs I used before (see the [[History][history section]] below for details). Not only that, but I also use [[https://precondition.github.io/home-row-mods][home row modifiers]] on my mechanical keyboards, and on my laptop I [[https://gist.github.com/tanyuan/55bca522bf50363ae4573d4bdcf06e2e][bind the CapsLock key to both Escape and Ctrl]] (Escape if pressed and released, Ctrl if held down). I try to keep my bindings ergonomic and mnemonic: the most common commands should be easy to type, and the less common ones easy to remember. What's ergonomic for me may not be ergonomic for you; adjust to your own setup.

For reasons of both ergonomics and mnemonics, I tend to eschew commands that require modifiers (Ctrl and Alt, or =C= and =M= in Emacs parlance), and instead opt for key combinations. That's the whole premise of a modal editing system like the one I'm using, of course. But I take this further by using (and sometimes abusing) leader keys, including transient commands, to build my own mini-menus for all kinds of tasks from window management to export via pandoc.

I use quite a lot of my own functions in this config. As seems to be a convention with many users, I add a =+= to the beginning of my own functions to serve as a kind of namespace.

This config is still very much a work in progress, but it has reached a state where I can publish it for others to see.

** History

This section merely explains my history with Emacs, and may give a glimpse into my reasoning with some of the choices I have made. Feel free to skip it.

Before using Emacs, I cut my teeth on [[https://en.wikipedia.org/wiki/Vim_(text_editor)][vim]]. I kept hearing about Emacs of course, with its amazing features like [[https://orgmode.org/][org-mode]] and [[https://www.gnu.org/software/auctex/][auctex]] and [[https://magit.vc/][magit]], and that it wasn't just an editor, etc etc. But it was all so intimidating! I had no idea where to start. I tried a couple of times but got nowhere, and it seemed way too complicated and arcane.

My gateway to Emacs began with various [[https://github.com/emacs-evil/evil][evil]]-based "distributions" (really just ready-made configurations with a bunch of stuff already configured, mostly for programming). The first I found was [[https://github.com/syl20bnr/spacemacs][Spacemacs]], probably around the year 2015 or thereabouts, which I actually didn't even realize was just Emacs from its [[https://www.spacemacs.org/][website]]. (It says Emacs front and center now, but I seem to recall that wasn't the case ten years ago). Spacemacs was amazing! Suddenly I could use my vim knowledge for editing, and everything made sense! It had "layers" that you could enable and activate all the functionality you needed! You didn't even need to write much Elisp, just comment/uncomment stuff based on the layers you required. And it was slick, too. That futuristic pimp-purple theme made Emacs sexy again.

[[./img/vim2spacemacs.jpg]]

But Spacemacs was slow. It was huge, and its layers were a detriment to the editing experience. They even had a Spacemacs lite version, with a minimal amount of layers activated, so it wouldn't feel so sluggish. Another of Spacemacs' woes was its opacity, which in a way was its /raison d'être/: the Spacemacs config was (and still is) almost fully detached from Emacs internals. In a way, that's the whole point: separating the users from the 40-year history of Emacs idiosyncracies, and just letting them get on with their work. However, when things broke, and break they did, fixing them by yourself was nigh impossible. At about this time, talk of a newer, sexier Emacs distribution reached my ears---Doom Emacs.

As far as I have been able to determine, [[https://github.com/doomemacs/doomemacs/][Doom Emacs]] began as hlissner's personal config based on the good parts of Spacemacs, and also centered on [[https://github.com/emacs-evil/evil][evil]], but as a thinner layer on top of Emacs itself. Doom was for *advanced* users. It unabashedly required you to read and write Elisp, follow the Doom discord channel, and keep up to date with Doom's development. It occasionally broke in unexpected ways, and required you to change things in your config, or sometimes just reinstall Doom completely. It was. So. Fukken. Rad.

[[./img/spacemacs2doom.jpg]]

Doom had "modules", kind of like Spacemacs layers, but with an added layer of customizability. You could add extra flags to your module to activate certain features (LSP or org-roam, for example), but that required you to actually try and figure out what those flags were doing, and exposed you to the underlying packages. Which is really all those modules did: they added an extra package and some keybindings to go with it.

Doom also had lots of churn in its early days. Packages were constantly added to and discarded from the distribution, which had the (perhaps unintended) effect of exposing the users to a whole lot of Emacs packages. Unlike Spacemacs, which hid the complexity from the user, with Doom you were forced to choose: helm, ivy, or vertico? company or corfu? lsp-mode or eglot?

All in all, I learned a whole lot about Emacs through Doom. In fact, I learned so much that I started to strain against the limits it imposed on me. The Doom layer, thinner than Spacemacs though it may have been, was still a barrier between me and the soft underbelly of Emacs. Customizing certain settings or keybindings looked very different from how others were doing it. Doom grew in popularity, and became more stable. At the same time, I grew restless, and started chafing at the bit a little, daydreaming about having a literal config of my own one day, but not daring to take that first step.

And then one fateful day, with only my Surface Go tablet at my disposal, I failed to update Doom. I tried reinstalling, and failed again, multiple times. The Doom install process fetches a whole lot of packages from source repositories, which led [[https://codeberg.org/][Codeberg]] to block my IP in case I was trawling their repos to train a new LLM.

And that was it. With no other option for using Emacs during a whole long weekend, I bit the bullet, I took the plunge. I knew precisely the packages I needed first and foremost. I had my Doom configuration right at my disposal, so I could copy and paste from it to my heart's content. What I did not have was that thin layer of protection between me and the pure unadulterated essense of Emacs. I had no access to Doom's convenience macros, so I had to learn to configure =use-package= and =evil= the way they were meant to be configured. I had to look for packages that provided the functionality I had taken for granted with Doom. I found alternative packages that I hadn't heard of before. I learned about functionality that Doom provided by itself and not through packages, some of it quite impressive. Bit by bit, I got to a config that was reasonably close to what I had had within Doom.

But that was not the end. Having finally weaned myself off Emacs distributions, I found myself staring in the face of yet another barrier, one that I had never thought I could forsake: [[https://github.com/emacs-evil/evil][evil]] itself. I had not dared to imagine using something else, but all that configuration [[./img/inception.jpg][planted the seeds of an idea]] in me. What if vim was not editing perfection? What if, instead of donning the scuba-suit of evil to venture out into the oceans of Elisp, I could take off the respirator and swim freely? What if I could shave off a whole 0.5s of Emacs init time?

Evil is a behemoth. It is a complete editor inside an editor. Just like how Emacs distributions hide the complexity of Emacs behind a sleek (yet necessarily limited) API, evil hides the editing functionality of Emacs by replacing *everything* with vim-like alternatives. I was using =:s= and =:norm=, vim macros, [[https://github.com/emacs-evil/evil-surround][evil-surround]], [[https://github.com/hlissner/evil-snipe][evil-snipe]], [[https://github.com/bling/evil-visualstar][evil-visualstar]], and [[https://github.com/edkolev/evil-lion][evil-lion]]. I was a vim maestro, flying through both code and prose at the speed of thought. How could I give up ten years of muscle memory for [[http://xahlee.info/emacs/emacs/emacs_hand_pain_celebrity.html][RSI]]?

I couldn't, of course. Not to move to the default keybindings. Why would I ever do that? There is more choice than just evil and the default keybindings, and I could pick and choose my settings as I wanted. I was annoyed by the assumption in many online discussions that using the default keybindings is the only proper way to Emacs. The whole point of Emacs, as I see it, is infinite customizability. Why should I ever let anyone tell me how I should be using *my Emacs*?

It was not hard to find other modal editing schemes for Emacs. In fact, Emacs has plenty of those. The difference is, people arriving to Emacs from vim tend to miss the comfort of that editing model, and evil exists to fill that niche. Other modal editing packages mostly exist for people coming from the default Emacs keybindings, when they decide they want to keep the use of their hands a little longer. Evil stands apart from the pack in that it is, essentially, vim. It implements pretty much all of vim's functionality in Emacs; anything different is considered a bug. Other packages, by choice and by necessity, play nice with Emacs internals. This makes them a lot more lightweight, at the cost of having to know more about the default Emacs editing experience.

In for a penny, in for a pound, I decided. I had had my eyes on =meow= for some time. It's a lightweight package that respects Emacs conventions, yet at the same time provides a full-fledged modal editing experience. Its editing mentality is not that of vim, but rather of [[https://kakoune.org/][kakoune]]: the normal and visual modes are combined, so that you select the text first before performing an action on it. To my surprise, it didn't take me particularly long to acclimatize. I took a few liberties with the suggested [[https://github.com/meow-edit/meow/blob/master/KEYBINDING_DVORAK.org][bindings for Dvorak]], based on my vim/evil experiences, and also my personal ideas. And that's okay! Unlike vim land, where almost any rebinding is frowned upon, and online discussions frequently devolve into games of one-upmanship about whose config is the shortest, meow doesn't even have a default layout, and encourages its users to create their own bindings.

This is where I am right now. Ten years of vim/evil, most of them spent using Doom. Suddenly, I'm in territory that's at once familiar and not. I've learned a lot about Emacs using Doom, and I've learned a lot more about Emacs after leaving Doom for my own config. I'm really grateful for Spacemacs, Doom, and evil, because without these projects I likely would not have started using Emacs. Now though, I'm ready for something new.

** Resources

Here are some of the resources I have consulted while writing my own config:
- [[https://github.com/bbatsov/emacs.d/blob/master/init.el][bbatsov's minimalist config]]
- [[https://github.com/hrs/dotfiles/blob/main/emacs/.config/emacs/configuration.org][Great evil-based config]] with a bunch of functional lang settings.
- [[https://github.com/zzamboni/dot-emacs/blob/master/init.org][Zzamboni's evil-based config]] prior to his migration to Doom. Lots of org gems there.
- [[https://zzamboni.org/post/my-doom-emacs-configuration-with-commentary/][Zzamboni's Doom config]]
- [[https://github.com/rougier/dotemacs/blob/master/dotemacs.org][Nicholas Rougier's literate config]]
- See [[https://github.com/jschaf/dotfiles/blob/master/emacs/core/abn-core-emacs-settings.el][this config]] (including other files) for some obscure settings and startup hacks.
- [[https://sophiebos.io/posts/prettifying-emacs-org-mode/][org prettifying]]
- See [[https://www.reddit.com/r/emacs/comments/9zad13/managing_personal_packages_with_usepackage/][here]] for instructions on how to load local files with =use-package= (so that they can be deferred, of course).
- [[https://github.com/positron-solutions/transient-showcase][transient showcase]]
- Some interesting stuff here: https://github.com/daviwil/emacs-from-scratch

* Basic settings
** Early loading

Some of these settings were taken from the [[https://github.com/hrs/sensible-defaults.el][sensible-defaults]] package.

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
(use-package emacs
  :custom
  ;; reduce the frequency of garbage collection by making it happen on
  ;; each 50MB of allocated data (the default is on every 0.76MB)
  (gc-cons-threshold (* 50 1000 1000))
  ;; warn when opening files bigger than 50MB
  (large-file-warning-threshold (* 50 1000 1000))
  ;; do not create backups
  (make-backup-files nil)
  ;; use regular spacing with sentences.
  ;; this is important because it directly impacts sentence motions.
  (sentence-end-double-space nil)
  ;; do not pollute this file with custom variables
  (custom-file "~/.emacs.d/custom.el")
  :config
  (load custom-file)
  (setq warning-minimum-level :emergency)
  ;; don't beep or flash, display a message instead
  (setq ring-bell-function (lambda () (message "Oops!")))
  ;; do not use tabs for indentation
  (setq-default indent-tabs-mode nil)
  ;; scrolling settings
  (setq scroll-conservatively 0
        scroll-preserve-screen-position 1))
#+end_src

** Package management
Instead of putting =:ensure t= everywhere, I can just set it here once.
(This is not recommended by some.)

#+begin_src elisp
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+end_src

I also turn on the profiler, so that I can see which packages
take the longest amount of time to load
(with the =use-package-report= command)
and see if their loading can be deferred.

#+begin_src emacs-lisp
(setq use-package-compute-statistics t)
#+end_src

See also =use-package-defaults= for other settings.

#+begin_src elisp
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+end_src

** In-built packages

Packages that form part of Emacs live here.

Some in-built packages are very useful, but not needed at startup. They may also lack handy trigger functions to bind them to. I defer the loading of these packages with idle timers as suggested [[https://blog.d46.us/advanced-emacs-startup/][here]].

*** Save place mode

Save place mode, as may be guessed from its name, saves the cursor position in files you visit. It's nice to open a file in Emacs and immediately see where you left off last time.

I prefer not to defer save-place-mode. Waiting a couple of seconds after startup to ensure it loads seems counterproductive to me, if it adds a few centiseconds to startup time at best. When trying it with defers, I found that I was often too quick to open a file, and save-place-mode hadn't started yet.

#+begin_src emacs-lisp
(use-package saveplace
  :init
  (setq save-place-forget-unreadable-files nil
        save-place-file (file-name-concat user-emacs-directory "tmp/places"))
  (save-place-mode 1))
#+end_src

*** Savehist mode

Savehist mode might be confused with save-place mode, but they do very different things. Savehist mode keeps track of *minibuffer* history, so that (for example) recently used =M-x= commands are shown on top.

#+begin_src emacs-lisp
(use-package savehist
  :init
  (setq savehist-file (file-name-concat user-emacs-directory "tmp/history"))
  (savehist-mode 1))
#+end_src

*** Tramp

#+begin_src emacs-lisp
(use-package tramp
  :defer 2
  :config
  (setq tramp-persistency-file-name
        (file-name-concat user-emacs-directory "tmp/tramp")))
#+end_src

*** Recentf

The 'f' in recentf stands for 'file'. I tend to open lots of different files from lots of different directories, and most of them are org-mode files rather than programming projects. Most of the time whenever I need to open a file, the first thing I do is try =recentf= (with [[id:53556f3d-c05c-4d6f-a9ae-3a59785b03e3][incremental narrowing and completion]]). Usually I only need to type a few disconnected syllables to filter out the file I need.

#+begin_src emacs-lisp
(use-package recentf
  :init
  (setq recentf-max-saved-items 1000
        recentf-max-menu-items 1000
        recentf-save-file (file-name-concat user-emacs-directory "tmp/recentf"))
  (recentf-mode 1))
#+end_src

*** Bookmarks

#+begin_src emacs-lisp
(use-package bookmark
  :config
  (setq bookmark-default-file (file-name-concat user-emacs-directory "tmp/bookmarks")))
#+end_src

** Vars

I use the same Emacs config on three machines at the moment. Most things do not need to change, but a few file locations differ from system to system. I set these here.

#+begin_src emacs-lisp
(pcase (system-name)
  ;; Laptop
  ("iwaka-thinkpad"
   (setq +org-directory "~/org"
         +default-bibliography "~/files/academic/bib/bibliography.bib"
         +ebib-file-search-dir "~/files/syncthing/papers/ebib"
         +ebib-import-directory "~/files/syncthing/papers/papers/articles"
         +fontsize 200))

  ;; Office PC
  ("goderich-ncue"
   (setq +org-directory "~/org"
         +default-bibliography "~/files/academic/bib/bibliography.bib"
         +ebib-file-search-dir "~/files/papers/ebib"
         +ebib-import-directory "~/files/papers/papers/articles"
         +fontsize 180))

  ;; Tablet
  ("goderich-surface"
   (setq +org-directory "~/org"
         +default-bibliography "~/academic/bib/bibliography.bib"
         +ebib-file-search-dir "~/papers/ebib"
         +ebib-import-directory "~/papers/papers/articles"
         +fontsize 180)))
#+end_src

** Theming

As has been a longstanding tradition of Emacs tutorials since time immemorial, the first thing users are recommended to put into their config is the code to turn off all menus. Since I came to Emacs from vim, that has never been an issue with me. I never would have used them anyway.

Unlike vimmers (and a lot of Emacs users who had been clamoring for the functionality), I prefer *not* to display line numbers in the fringe. I can still go to specific lines by number, and I still see the current line number in my mode line in case I ever need it (which is never). When editing existing text, I use semantic operations like paragraphs, sentences, or parenthetic blocks. I haven't regretted turning line numbers off, and I don't miss them at all.

#+begin_src elisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(display-line-numbers-mode -1)
(tooltip-mode -1)

;; Soft wrap long lines
(global-visual-line-mode 1)

;; Maintain a small margin when scrolling
(setq scroll-margin 2)
#+end_src

Dark themes are all the rage with Linux hackers, but I usually work during the day, when a light theme makes text more readable. With Doom, I used =doom-solarized-light= most of the time, and its palette is gorgeous. I considered using the [[https://github.com/doomemacs/themes][doom themes]] package, but it's a little too large for my taste. Bozhidar Batsov's [[https://github.com/bbatsov/solarized-emacs][solarized themes]] package, while no bantamweight itself, provides a reasonable alternative.

Having said that, I found myself missing a few of the colours in Doom's version of solarized light, so I set them here. For some other settings I prefer bbatsov's way, or even my own tweaks.

#+begin_src emacs-lisp
(use-package solarized-theme
  :init
  (setq solarized-scale-org-headlines nil)
  (load-theme 'solarized-light t)

  :config
  ;; should be using #'set-face-attribute instead
  (face-spec-set 'default
                 '((t :background "#fdf6e3")))
  ;; org headlines
  (face-spec-set 'org-done
                 '((t :foreground "gray"
                      :weight bold)))
  (face-spec-set 'org-headline-done
                 '((t :foreground "gray")))
  (face-spec-set 'org-todo
                 '((t :foreground "#859900")))
  (face-spec-set 'font-lock-builtin-face
                 '((t :foreground "#d33682"
                      :weight normal)))
  (face-spec-set 'org-level-1 '((t :foreground "#268bd2")))
  (face-spec-set 'org-level-2 '((t :foreground "#d33682")))
  (face-spec-set 'org-level-3 '((t :foreground "#6c71c4")))
  (face-spec-set 'org-level-4 '((t :foreground "#5ca8dd")))
  (face-spec-set 'org-level-5 '((t :foreground "#de68a1")))
  (face-spec-set 'org-level-6 '((t :foreground "#92c4e8")))
  (face-spec-set 'org-level-7 '((t :foreground "#e99ac0")))
  (face-spec-set 'org-level-8 '((t :foreground "#d3e7f6")))
  (face-spec-set 'org-table   '((t :foreground "#6c71c4")))
  (face-spec-set 'org-cite    '((t :foreground "#b58900")))
  ;; org src blocks
  (face-spec-set 'org-block
                 '((t :background "#faf1d9"
                      :extend t)))
  (face-spec-set 'org-meta-line
                 '((t :background "#faf1d9"
                      :slant normal
                      :extend t)))
  ;; org cite
  (face-spec-set 'org-cite
                 '((t :foreground nil
                      :inherit link)))
  ;; org checkbox
  (face-spec-set 'org-checkbox
                 '((t :box unspecified)))
  ;; org agenda
  (face-spec-set 'org-agenda-date
                 '((t :foreground nil
                      :weight bold)))
  (face-spec-set 'org-scheduled-previously
                 '((t :foreground nil)))
  (face-spec-set 'org-agenda-done
                 '((t :slant normal)))
  (face-spec-set 'link
                 '((t :foreground "#268bd2"
                      :weight bold
                      :underline t)))
  (face-spec-set 'org-agenda-date-weekend
                 '((t :foreground nil
                      :underline nil)))
  ;; info
  (face-spec-set 'Info-quoted
                 '((t :inherit font-lock-keyword-face))))
#+end_src

** Fonts

Font configuration in Emacs is a little complicated, and tied to theming as well. I try to keep it relatively simple, but I also like my Emacs to look nice.

Since I spend so much time in org-mode, and a lot of it writing prose, it makes sense for me to configure variable width fonts in addition to monospace ones for programming. I use [[https://gitlab.com/jabranham/mixed-pitch][mixed-pitch]] mode to have both types of fonts in a single buffer. Some of the ideas for font configuration came from [[https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/#h:c7528f3d-9fc8-49e5-9468-6868fb5c07b5][Prot's tutorial]], although I looked at various other configs as well. That =mixed-pitch-set-height= setting is super important: without it, you can't adjust the relative height of monospace and variable width fonts in mixed-pitch buffers.

#+begin_src emacs-lisp
(use-package mixed-pitch
  :hook ((text-mode . mixed-pitch-mode)
         (Info-mode . mixed-pitch-mode))
  :config
  (setq mixed-pitch-set-height t))
#+end_src

Next are the fonts themselves. [[https://github.com/be5invis/Iosevka][Iosevka]] gets mentioned a lot as a popular monospace font, but I don't like it much (too thin). The monospace fonts I do like are (see also [[https://coding-fonts.pages.dev/fonts/input/?language=js][here]]):
- Cascadia Code (round and funky, a bit on the thick side)
- Fantasque Sans Mono (like Cascadia, but thinner and a more handwritten style)
- Input (a bit like Cascadia, but thinner and more square)
- Source Code Pro (nice and round, if a little boring)
- Fira Code (similar to Source Code Pro, could try when I want something more mainstream)
- [[https://pcaro.es/hermit/][Hermit]] (a little of an old-school 8-bit quality to it, but modernized)
- [[https://www.dafont.com/lotion.font][Lotion]] (funky and slightly cartoonish)

With variable width fonts, it's not always just a matter of liking a typeface, but also it being compatible with the things I type. E.g. I like the [[https://edwardtufte.github.io/et-book/][ET Book]] quite a lot, but unfortunately it has minimal support for non-ASCII characters, which is less than ideal, because I type those a lot. A few other variable width fonts I like are (also see [[https://wiki.archlinux.org/title/Fonts][here]]):
- Crimson Pro
- Gentium family (has all of the IPA, but the line spacing is too big)
- Libertinus

#+begin_src emacs-lisp
(let ((monospace-font "Cascadia Code")
      (variable-font "Crimson Pro"))
  (set-face-attribute 'default nil
                      :family monospace-font
                      :height +fontsize)
  (set-face-attribute 'fixed-pitch nil
                      :family monospace-font
                      :height 1.0)
  (set-face-attribute 'variable-pitch nil
                      :family variable-font
                      :height 1.3))
(set-fontset-font t nil (font-spec :height 1.2 :name "Gentium Plus"))
#+end_src

For CJK fonts specifically, check [[https://www.shimmy1996.com/en/posts/2018-06-24-fun-with-fonts-in-emacs/][this]], or [[https://www.reddit.com/r/emacs/comments/8tz1r0/how_to_set_font_according_to_languages_that_i/e1bjce6/][this snippet]].
[[https://github.com/be5invis/Sarasa-Gothic][Sarasa]] is a CJK font affiliated with Iosevka.
Also [[https://coldnew.github.io/d5011be2/][this article]] deals with CJK alignment in org tables. However, I already have valign-mode, so that might be moot.

** Dashboard

The default Emacs startup screen isn't particularly useful. It's rendered even less so by the fact that Boon does not turn on there, since it isn't an editing mode. Of course, there's an Emacs package for just that.

#+begin_src emacs-lisp
(use-package dashboard
  :bind
  (:map dashboard-mode-map
        ("u" . 'dashboard-previous-line)
        ("e" . 'dashboard-next-line))
  :config
  (dashboard-setup-startup-hook)
  (setq dashboard-startup-banner (file-name-concat user-emacs-directory "img/emacs-e.svg"))
  (setq dashboard-center-content t)
  (setq dashboard-items '((recents . 5))))
#+end_src

** TODO Utility functions

Some functions I use in my config. They are placed here temporarily, and I should move them under more appropriate headings.

#+begin_src emacs-lisp
(defun +open-config ()
  (interactive)
  (find-file "~/.emacs.d/config.org"))

(defun +open-org-dir ()
  (interactive)
  (ido-find-file-in-dir "~/org/"))

(defun turn-off-visual-line-mode ()
  (visual-line-mode -1))

(defun turn-on-truncate-lines ()
  (toggle-truncate-lines 1))
#+end_src

* Meow (DISABLED)

[[https://github.com/meow-edit/meow/blob/master/EXPLANATION.org][Meow]] is a modal editing package. It's both like and unlike evil. If you come to it expecting it to be "just like evil, but better", you will inevitably be disappointed. If you keep an open mind and invest some time in it, it will work just as well as evil, but with much better coupling with Emacs.

#+begin_src emacs-lisp :noweb yes :tangle no
(use-package meow
  :init
  (require 'meow) ; <- must be present
  <<meow-keybindings>>
  <<meow-functions>>
  <<meow-settings>>
  (meow-global-mode 1))
#+end_src

** Leader map bindings

Similar to both Spacemacs and Doom, meow utilizes the Space key as its leader key. This way instead of getting RSI on your pinkies, you can get it on your [[./img/thumbs-up.jpg][thumbs]]!

The biggest difference is that meow embraces Emacs defaults. Space followed by any of =x, c, h, g, m= enters [[https://github.com/meow-edit/meow/blob/master/TUTORIAL.org#keypad][Keypad state]], which is used to enter Emacs commands without using modifiers. So these five keys are off-limits, but that still leaves us with enough room to fill with our own bindings.

Notably, keypad state bindings are also made available as regular Emacs keybindings, with =C-c= as the leader key.

In the spirit of Spacemacs and Doom, I use the Space key as a "global leader", and save it for commands that I want to be available everywhere. I have figured out a way to have local leader commands as well, with bindings based on modes: see the [[id:1e5a8fcf-39f6-41ce-a9a0-88583045fcde][meow functions]] section for that.

Quite a few of my leader map functions are in fact [[id:1d67b9e6-b143-425a-8dec-d124f95eedc4][transients]]. These are easy to spot because I always name them as such.

#+begin_src emacs-lisp :tangle no :noweb-ref meow-keybindings
(meow-leader-define-key
 '("SPC" . execute-extended-command)
 '("a" . org-agenda-list)
 '("b" . +buffer-transient)
 ;; "c" reserved by meow
 '("e" . ebib)
 '("f" . +file-transient)
 ;; "g" reserved by meow
 ;; "h" reserved by meow, I rebind it elsewhere
 ;; "m" reserved by meow
 '("o" . +olivetti-transient)
 '("u" . link-hint-open-link)
 '("v" . magit) ; v for +vendetta+ version control
 '("w" . +window-transient)
 ;; "x" reserved by meow
 '("," . switch-to-buffer)
 '("." . find-file)
 '("/" . consult-line)
 '("?" . meow-cheatsheet))
#+end_src

** Normal state bindings

The normal state is the bread and butter of editing with meow, just like in vim/evil. Unlike vim/evil, meow's normal state operates on selections. Vimmers love talking about the 'grammar' of vim (verb → adjective → noun), which is flipped in meow's model (really kakoune's editing model).

I took the [[https://github.com/meow-edit/meow/blob/master/KEYBINDING_DVORAK.org][suggested Dvorak bindings]] and distorted them almost to the point of irrecognizability. I swapped things around somewhat to have a little "WASD" pyramid of movement on the right hand side (IJKL on qwerty keyboards). I replaced certain commands with packages like consult and avy. There are a few places where I have the same command bound to multiple keys. This is not an accident, instead I'm trying out various configurations and see which ones I prefer.

One package I bind to a key is [[https://github.com/abo-abo/avy][avy]], which is great for moving around the screen in Emacs, and it replaces [[https://github.com/hlissner/evil-snipe][evil-snipe]] and evil's own motions for me. I also use it to [[id:067dfe76-a65f-44b6-ab9d-a72b875071d2][open links]] (with the link-hint package).

However, a few evil habits are reflected in this layout, not least of which being =ZZ= and =ZQ= to exit Emacs with and without saving, respectively.

So this keymap will likely change in future, but right now it looks something like this:

[[./img/meow-cheatsheet.png]]

#+begin_src emacs-lisp :tangle no :noweb-ref meow-keybindings
(meow-normal-define-key
 '("0" . meow-expand-0)
 '("9" . meow-expand-9)
 '("8" . meow-expand-8)
 '("7" . meow-expand-7)
 '("6" . meow-expand-6)
 '("5" . meow-expand-5)
 '("4" . meow-expand-4)
 '("3" . meow-expand-3)
 '("2" . meow-expand-2)
 '("1" . meow-expand-1)
 '("-" . negative-argument)
 '("/" . consult-line) ; superfluous?
 '(";" . ignore)
 '("," . meow-inner-of-thing)
 '("." . meow-bounds-of-thing)
 '("<" . meow-beginning-of-thing)
 '(">" . meow-end-of-thing)
 '("a" . meow-append)
 '("A" . meow-open-below)
 '("b" . meow-back-word)
 '("B" . meow-back-symbol)
 '("c" . +meow-prev-visual)
 '("C" . meow-prev-expand)
 '("d" . meow-change)
 '("e" . meow-line)
 '("E" . meow-goto-line)
 '("f" . meow-find)
 '("g" . meow-cancel-selection) ; superfluous?
 '("G" . meow-grab) ; not using this
 '("h" . meow-left)
 '("H" . meow-left-expand)
 '("i" . meow-insert)
 '("I" . meow-open-above)
 '("j" . meow-join)
 '("k" . meow-kill)
 '("l" . meow-till)
 '("m" . meow-mark-word)
 '("M" . meow-mark-symbol)
 '("n" . meow-right)
 '("N" . meow-right-expand)
 '("o" . +meow-localleader)
 '("p" . meow-yank)
 '("q" . meow-quit)
 '("r" . meow-replace) ; not using this
 '("R" . meow-swap-grab) ; not using this
 '("s" . avy-goto-char-timer)
 '("S" . meow-visit) ; superfluous?
 '("t" . +meow-next-visual)
 '("T" . meow-next-expand)
 '("u" . undo-fu-only-undo)
 '("U" . undo-fu-only-redo)
 '("v" . meow-reverse)
 '("w" . meow-next-word)
 '("W" . meow-next-symbol)
 '("x" . meow-keypad-start)
 '("y" . meow-save)
 '("z" . meow-pop-selection)
 '("ZZ" . save-buffers-kill-terminal)
 '("ZQ" . kill-emacs)
 '("<prior>" . +meow-scroll-down)
 '("<next>" . +meow-scroll-up)
 '("<escape>" . meow-cancel-selection))
#+end_src

** Motion state bindings

Meow's motion state in itself is not a new idea. Evil has a motion state too, used in exactly the same situations. It's triggered by default in non-text modes, such as magit, dired, org-agenda, etc. What makes meow's motion state special is two things:
1. it has no bindings by default,
2. it has a peculiar [[https://github.com/meow-edit/meow/blob/master/TUTORIAL.org#motion][binding overwrite]] mechanism.

No bindings means this state is completely transparent and lets you use the bindings set by the mode itself, which is great if you are already familiar with those. It's also what Emacs expects, so there's a lot less friction in these modes than with evil, where you need a project like [[https://github.com/emacs-evil/evil-collection][evil-collection]] to maintain some semblance of coherence. With meow, something like =q= for quitting a mode /just works/. It's great.

The binding overwrite is a really clever idea. Instead of letting you bind keys in motion mode and thus lose keybindings in all modes where it's activated, meow automatically rebinds those keys with a Hyper modifier. Naturally, most of us don't have a Hyper key---even on my mechanical keyboards I have never felt the need to include one---but the point is you can then rebind other keys to those Hyper key bindings, letting you preserve at least some of the more common commands. I do this in the code below.

#+begin_src emacs-lisp :tangle no :noweb-ref meow-keybindings
(meow-motion-overwrite-define-key
 '("<escape>" . ignore)
 '("\\" . execute-extended-command)
 '("h" . meow-left)
 '("t" . meow-next)
 '("c" . meow-prev)
 '("n" . meow-right)
 '("<" . beginning-of-buffer)
 '(">" . end-of-buffer)
 '("H" . "H-h")
 '("T" . "H-t")
 '("C" . "H-c")
 '("N" . "H-n"))
#+end_src

** Insert state bindings

The insert state is what you use for actual typing. For most users, there's probably no need to modify it (hence meow doesn't even supply a helper function for insert state, unlike normal and motion states). I do a couple of things with it.

I like having =C-w= delete the previous word. I'm not sure where I picked up this keybinding, but it's all over Linux, including shell and vim. I kept hitting it, trying to delete the previous word and instead executing the =kill-region= command, which is the Emacs binding. In the end I just gave up and rebound it in insert mode.

With my [[https://precondition.github.io/home-row-mods][home row modifiers]] and sausage fingers, I sometimes end up hitting a modifier + a key instead of typing a sequence like "ea", "pa", or "ga". On Dvorak, this tends to happen with a-final sequences. I disable these commands in insert mode by setting them to =ignore=.

#+begin_src emacs-lisp :tangle no :noweb-ref meow-keybindings
(meow-define-keys 'insert
  '("C-w" . meow-backward-kill-symbol)
  '("C-a" . ignore)
  '("M-a" . ignore))
#+end_src

** Global bindings

Since =h= is one of the keys that get captured in keypad state, pressing =SPC h= gets translated into =C-h= directly. Here, I bind =C-h= to my transient, because it does essentially the same thing as the default =describe-*= functions, but better.

#+begin_src emacs-lisp :tangle no :noweb-ref meow-keybindings
(keymap-global-set "C-h" #'+helpful-transient)
#+end_src

On my mechanical keyboards with home row mods, I can do all sorts of shenanigans without moving my hands too much. The most reachable modifiers in my layout are Ctrl and Shift, bound under the middle and index fingers, respectively (on both sides, so each hand can use them). Even though I move Escape to the Home row, it's still on the Caps key, so I have to move my left hand quite a bit to reach it. =C-t= is a motion made by the two middle fingers, so it's even easier, even though it may not seem so. I bind =C-t= to Escape globally in Emacs, so I can use it everywhere (I should probably think about binding it directly in my keyboards' firmware).

#+begin_src emacs-lisp :tangle no :noweb-ref meow-keybindings
;; home row mod esc
(keymap-global-set "C-t" "<escape>")
#+end_src

With =x= switching to keypad state, bindings beginning with =C-x C-= can be entered with two keypresses. E.g., =switch-to-buffer= for me is now =x b=, whereas =list-buffers= becomes =x SPC b=. It makes more sense to bind the more common commands this way.

#+begin_src emacs-lisp :tangle no :noweb-ref meow-keybindings
(keymap-global-set "C-x C-b" #'switch-to-buffer)
(keymap-global-set "C-x b" #'list-buffers)
#+end_src

** Meow functions
:PROPERTIES:
:ID:       1e5a8fcf-39f6-41ce-a9a0-88583045fcde
:END:

I loved using local leader keys in Doom. One of my favourite things about evil was being able to configure keybindings in all modes to be precisely what I wanted (although it was a bit of a pain with evil + Doom, especially at first). In fact, my biggest fear before switching to meow was not the unfamiliar editing model, but losing the ability to bind keys via my local leader.

A solution I found was binding keys to a longer prefix. Here I choose =C-c o= (partly because I bound it to the =o= key in normal mode). I can then have global keybindings use the keypad state and =C-c= + letter, and bind keys local to particular modes to begin with =C-c o=. In practice, if you see a binding like =C-c o o= for org-mode, I'm actually pressing =o o=.

The beauty of this approach is that I can have more that one local leader if I want to, but at the same time I get to fully keep the default Emacs keybindings AND the keymap state with =C-c= (keymap using SPC is a given in meow).

#+begin_src emacs-lisp :tangle no :noweb-ref meow-functions
(defun +meow-localleader ()
  (interactive)
  (meow-keypad-start-with "C-c o"))
#+end_src

Meow does not support movement by visual lines out of the box. Shame, because I now prefer to write paragraphs without line breaks in org. I took meow's line functions and rewrote them to move visually instead.

#+begin_src emacs-lisp :tangle no :noweb-ref meow-functions
(defun +meow-next-visual (arg)
  (interactive "P")
  (unless (equal (meow--selection-type) '(expand . char))
    (meow--cancel-selection))
  (cond
   ((meow--with-universal-argument-p arg)
    (goto-char (point-max)))
   (t (line-move-visual 1))))

(defun +meow-prev-visual (arg)
  (interactive "P")
  (unless (equal (meow--selection-type) '(expand . char))
    (meow--cancel-selection))
  (cond
   ((meow--with-universal-argument-p arg)
    (goto-char (point-min)))
   (t (line-move-visual -1))))
#+end_src

Scrolling with PageUp and PageDown does not automatically cancel selection in meow, which I find annoying. I wrote two wrapper functions to take care of this for me.

#+begin_src emacs-lisp :tangle no :noweb-ref meow-functions
(defun +meow-scroll-up ()
  "PageDown command that cancels meow selection."
  (interactive)
  (when (and (meow-normal-mode-p) (region-active-p))
    (meow--cancel-selection))
  (scroll-up-command))

(defun +meow-scroll-down ()
  "PageUp command that cancels meow selection."
  (interactive)
  (when (and (meow-normal-mode-p) (region-active-p))
    (meow--cancel-selection))
  (scroll-down-command))
#+end_src

** Meow settings

I was pleasantly surprised by the amout of customization available in meow. The developers have foreseen quite a large number of possible needs and provided comfortable solutions.

I still refer to the cheatsheet from time to time, so I prefer to see it with the proper layout.
#+begin_src emacs-lisp :tangle no :noweb-ref meow-settings
(setq meow-cheatsheet-layout meow-cheatsheet-layout-dvorak)
#+end_src

The default normal cursor and region selection faces are too similar in my layout, so I change them slightly. I like to be able to see where my cursor is when selecting, because by default it turns into a bar, making it difficult to see with an active region. I also deactivate cursor blinking, because it annoys me.
#+begin_src emacs-lisp :tangle no :noweb-ref meow-settings
(custom-set-faces
 '(meow-normal-cursor ((t (:background "#aab2ac")))))
(setq meow-cursor-type-region-cursor '(box . 2))
(setq meow-cursor-type-motion 'hollow)
(blink-cursor-mode -1)
#+end_src

The =meow-selection-command-fallback= setting is fantastic. It works like this: most operations in meow require a selection (= region). What should we do when there is no selection? There are defaults, but you can easily change them.

I use =k= for the =meow-kill= command, which is 'cut' in CUA. By default, it kills to the end of the line with no selection, but that's already bound to =C-k= in Emacs, so not that far off to begin with, plus it's not a particularly common action. I instead have it delete a single character when there's no selection, which frees me from having to bind =meow-delete= to a key.
#+begin_src emacs-lisp :tangle no :noweb-ref meow-settings
;; When k is used without a selection, delete char
(map-put! meow-selection-command-fallback #'meow-kill #'meow-delete)
#+end_src

Meow has a binding for goto-line, but it accepts functions other than the default. The reason to use avy here is pretty obvious, as it is strictly better than the in-built goto-line. The reason to wrap it in meow instead of just binding it directly, is that meow also selects the line which is jumped to.
#+begin_src emacs-lisp :tangle no :noweb-ref meow-settings
(setq meow-goto-line-function #'avy-goto-line)
#+end_src

Both vim and Emacs have their own ways of dealing with copying and pasting text. Vim has registers, and Emacs has the kill ring. I'm not interested. I use a system-wide clipboard manager, and I want all my copied text to be in one place, regardless of the program I'm using.
#+begin_src emacs-lisp :tangle no :noweb-ref meow-settings
(setq meow-use-clipboard t)
#+end_src

Selection directions mean whether the cursor appears at the beginning or the end of the selection. Makes sense to me to keep both inner and outer bound directions the same.
#+begin_src emacs-lisp :tangle no :noweb-ref meow-settings
(map-put! meow-thing-selection-directions 'bounds 'forward)
#+end_src

** Meow packages and resources

While I'm still getting used to meow, here are reminders for things that I used with evil but no longer have access to, and what I should replace them with.
- [[https://github.com/juliapath/evil-numbers][evil-numbers]] for incrementing/decrementing (does not require evil)
- Look into [[https://www.emacswiki.org/emacs/KeyboardMacros][Emacs macros]] and [[https://github.com/meow-edit/meow/blob/master/TUTORIAL.org#beacon][beacon state]] to replace vim =q=
- Look into [[info:emacs#Replace][replacement commands]] instead of vim =:=
- [[info:emacs#Mark Ring][Marks]] (pop/unpop) and [[info:emacs#Position Registers][registers]] for movements similar to =gi=
- Smartparens instead of evil-surround

* Boon

- NB. See boon's "special state"

#+begin_src emacs-lisp
(use-package boon
  :init
  (require 'boon-colemak)
  (boon-mode)
  :bind
  (:map boon-command-map
        ("e" . 'next-line)
        ("E" . 'forward-paragraph)
        ("h" . 'avy-goto-word-1)
        ("H" . 'avy-goto-char-timer)
        ("j" . 'crux-top-join-line)
        ("J" . 'join-line)
        ("L" . 'beginning-of-visual-line)
        ("m" . 'boon-smarter-backward)
        ("M" . 'backward-sentence)
        ("n" . 'backward-char)
        ("N" . 'boon-smarter-upward)
        ("O" . 'forward-sentence)
        ("y" . 'end-of-line)
        ("Y" . 'end-of-visual-line)
        ("ZZ" . 'save-buffers-kill-terminal)
        ("/" . 'consult-line)
        ("-" . 'undo-fu-only-undo)
        ("_" . 'undo-fu-only-redo)
        ("<return>" . nil)
   :map boon-insert-map
        ("<escape>" . '+boon-command-state-maybe)
   :map goto-map
        ("g" . 'avy-goto-line)
        ("h" . '+consult-org-heading)
   :map boon-x-map
        ("e" . eval-last-sexp)
        ("f" . '+file-transient)
        ("h" . '+helpful-transient)
        ("m" . 'magit)
        ("p" . 'pandoc-transient)
        ("s" . 'save-buffer)
        (";" . 'comment-line)
        ("." . 'find-file)
        ("," . 'switch-to-buffer))
  :config
  (remove-hook 'minibuffer-setup-hook #'boon-minibuf-hook)
  (setq boon-default-cursor-type 'box)
  (blink-cursor-mode -1)

  (dolist (mode '(ebib-index-mode ebib-entry-mode))
    (add-to-list 'boon-special-mode-list mode))

  (defun +boon-command-state-maybe ()
  (interactive)
  (cond
   ((and corfu-mode completion-in-region-mode) (corfu-quit))
   ((ignore-errors tempel--active) (tempel-done))
   (t (boon-set-command-state)))))
#+end_src

I do not have Tab bindings collected in any single specific place, but this bears stating somewhere. Here is as good a place as any. I have the following functionality on my Tab key:
- expand a snippet if one is available, but *only* in insert state,
- act as org-cycle in org mode, in both normal and insert states,
- act as indent key in programming modes in both normal and insert states.

When I'm in insert mode and a [[id:2ca8bb84-790f-4e68-8d3d-4893ef154e43][completion]] overlay is active, I want ESC to quit completion or templating *while keeping me in insert mode*. In my evil config, I used a wrapper function, which I replicated with boon.

* Minibuffer keybindings

Keybindings in the minibuffer have to be set differently.
I am not using evil in the minibuffer, and the bindings
have to be set up using a hook each time.

I went through this trouble to replicate Doom's behaviour
when pressing backspace in the minibuffer.
It works as normal when typing the name of a file,
but if you keep deleting, the parent directories will be deleted
with a single press of backspace.
This is pretty convenient when jumping upwards many levels.

Right now my implementation is still relatively naive,
and I'm still in the process of refining it.

#+begin_src emacs-lisp
(defun +delete-char-or-directory ()
  (interactive)
  (cond
   ((string= (minibuffer-contents) "/")
    (delete-backward-char 1))
   ((string= (minibuffer-contents) "~/")
    (delete-minibuffer-contents)
    (insert (expand-file-name "~/")))
   ((eq (char-before) ?/)
    (let ((pt (point))
          (slash-pos (search-backward "/" nil t 2)))
      (if slash-pos
          (progn
            (delete-region (1+ slash-pos) pt)
            (move-end-of-line nil))
        (delete-backward-char 1))))
   (t (delete-backward-char 1))))

(defun +minibuffer-setup ()
  (keymap-set minibuffer-local-map "<backspace>" #'+delete-char-or-directory)
  (keymap-set minibuffer-local-map "C-w" #'backward-kill-word)
  (keymap-set minibuffer-local-map "C-<return>" #'vertico-exit-input)
  (keymap-set minibuffer-local-map "<escape>" #'keyboard-escape-quit)
  (setq-local cursor-type 'box))

(add-hook 'minibuffer-setup-hook #'+minibuffer-setup)
#+end_src

* Transient commands
:PROPERTIES:
:ID:       1d67b9e6-b143-425a-8dec-d124f95eedc4
:END:

Transients are an amazing feature of Emacs, and really handy for people who like to over-personalize their configs. They don't run a command, but instead pop up a menu where you can choose further actions, or enter a transitory state so that you can mash one key to, e.g. increase the font size or text width. I prefer using transients to mapping every function individually, because transients are a lot easier to remap, and their functionality is strictly more powerful. Since Emacs 28, the transient package has been included in Emacs itself.

Right now, all my transient menus live here. Since many of my packages are deferred, it's simpler to define the transients outside their =use-package= calls. The packages then get loaded when I call their respective transients.

** Window resizing transient

#+begin_src emacs-lisp
(transient-define-prefix +window-transient ()
  ["Resizing windows"
   ["Transient"
    ("b" "bigger" enlarge-window :transient t)
    ("s" "smaller" shrink-window :transient t)
    ("=" "balance" balance-windows :transient t)]
   ["Non-transient"
    ("d" "delete" delete-window)
    ("w" "other" other-window)
    ("m" "maximize" delete-other-windows)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** File transient

#+begin_src emacs-lisp
(transient-define-prefix +file-transient ()
  ["File commands"
   ["With this file..."
    ("s" "save" save-buffer)
    ("D" "delete" crux-delete-file-and-buffer)
    ("R" "rename" crux-rename-file-and-buffer)
    ("u" "sudo edit" crux-sudo-edit)]
   ["Open..."
    ("r" "recent file" recentf)
    ("o" "org directory" +open-org-dir)
    ("c" "config.org" +open-config)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Buffer transient

#+begin_src emacs-lisp
(transient-define-prefix +buffer-transient ()
  ["Buffer commands"
   [("b" "open" consult-buffer)
    ("s" "save" save-buffer)
    ("u" "sudo edit" crux-sudo-edit)]
   [("d" "quit" kill-this-buffer)
    ("q" "quit" kill-this-buffer)]
   [("<escape>" "quit" transient-quit-all)]])
#+end_src


** Helpful transient

#+begin_src emacs-lisp
(transient-define-prefix +helpful-transient ()
  ["Emacs help"
   ["Helpful mode"
    ("f" "functions and macros" helpful-callable)
    ("v" "variables" helpful-variable)
    ("k" "key" helpful-key)
    ("c" "interactive functions" helpful-command)
    ("p" "thing at point" helpful-at-point)]
   ["In-built help"
    ("m" "describe mode" describe-mode)
    ("F" "describe face" describe-face)
    ("i" "info" info)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Olivetti transient

I use olivetti with org a lot, and when I do, I prefer to keep my text relatively narrow. That does not play well with =org-indent-mode=, so I keep the two separate with this transient that takes care of disabling and enabling =org-indent-mode= when called.

#+begin_src emacs-lisp
(defun +turn-off-olivetti-mode ()
  (interactive)
  (olivetti-mode -1)
  (when (derived-mode-p 'org-mode)
    (org-indent-mode +1)))

(transient-define-prefix +olivetti-transient ()
  ["Change text column width..."
   [("w" "wider" olivetti-expand :transient t)
    ("n" "narrower" olivetti-shrink :transient t)]
   [("f" "turn off olivetti" +turn-off-olivetti-mode)
    ("q" "quit" transient-quit-all)]]
  (interactive)
  (olivetti-mode +1)
  (when (derived-mode-p 'org-mode)
    (org-indent-mode -1))
  (transient-setup '+olivetti-transient))
#+end_src

* Narrowing and completion
** Narrowing
:PROPERTIES:
:ID:       53556f3d-c05c-4d6f-a9ae-3a59785b03e3
:END:

TODO: There is a lot of functionality here, I should explore it.
https://github.com/minad/consult
#+begin_src emacs-lisp
(use-package consult)

(use-package vertico
  ;; :custom
  ;; (vertico-scroll-margin 0) ;; Different scroll margin
  ;; (vertico-count 20) ;; Show more candidates
  ;; (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
  ;; (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
  :init (vertico-mode))

(use-package orderless
  :custom
  (completion-styles '(orderless basic))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles partial-completion)))))

;; Documentation in M-x and minibuffers
(use-package marginalia
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  ;; :bind (:map minibuffer-local-map
  ;;        ("M-A" . marginalia-cycle))

  :init (marginalia-mode))

;; Do not delay which-key (delay has to be above zero)
(use-package which-key
  :init (which-key-mode)
  :config
  (setq which-key-idle-delay 1)
  (setq which-key-idle-secondary-delay 0.05))
#+end_src

There is also https://github.com/oantolin/embark/,
but I haven't learned how to use it properly.

** Completion (Corfu)
:PROPERTIES:
:ID:       2ca8bb84-790f-4e68-8d3d-4893ef154e43
:END:

Using [[https://github.com/minad/corfu][Corfu]].

I do NOT normally want completion on in org, because that's distracting. I do want completion when programming, and I want it to open up automatically.

I'm using SPC as separator: pressing space does not exit completion, but instead begins a second chunk. This makes corfu work a lot like consult et al, where a search string can be entered using space-separated pieces.

#+begin_src emacs-lisp
(use-package corfu
  :hook ((prog-mode . corfu-mode))
  :custom
  (corfu-auto t)
  (corfu-quit-no-match t)
  :bind (:map corfu-map
         ("TAB" . corfu-expand)
         ("SPC" . corfu-insert-separator)))
#+end_src

* Org-mode

- Sacha Chua also has an [[https://sachachua.com/blog/2024/01/using-consult-and-org-ql-to-search-my-org-mode-agenda-files-and-sort-the-results-to-prioritize-heading-matches/][interesting use]] of org-ql.
- See [[https://stackoverflow.com/questions/5500035/set-custom-keybinding-for-specific-emacs-mode][this]] and maybe [[https://stackoverflow.com/questions/13102494/buffer-locally-overriding-minor-mode-key-bindings-in-emacs/13102821#13102821][this]] for binding minor mode keys in specific major modes.

Note that since I am using a literate config
and loading it with org-babel from my =init.el=,
I cannot defer loading org-mode at startup.
It's not a huge penalty though,
and I feel the convenience outweighs it.

#+begin_src emacs-lisp :noweb yes
(use-package org
  :ensure nil
  :init <<org-init>>
  :hook <<org-hooks>>
  :bind (:map org-mode-map
         ("<return>" . +org-return)
         ("C-<return>" . +org-insert-item)
         ("C-c c" . ebib-insert-citation)
         ("C-c l" . +org-link-dwim)
         ("C-c r" . +ref-transient)
         ;; local leader bindings
         ("C-c o c" . ebib-insert-citation)
         ("C-c o h" . +consult-goto-org-heading)
         ("C-c o l" . +link-transient)
         ("C-c o p" . pandoc-transient)
         ("C-c C-Q" . +org-remove-tags)
         ;; ("C-c o s" . org-edit-src-code)
         ;; ("C-c o S" . org-sparse-tree)
         ;; org movement
         ("M-n" . org-metaleft)
         ("M-e" . org-metadown)
         ("M-u" . org-metaup)
         ("M-i" . org-metaright)
         ("M-N" . org-shiftmetaleft)
         ("M-E" . org-shiftmetadown)
         ("M-U" . org-shiftmetaup)
         ("M-I" . org-shiftmetaright))
  :config
  <<org-settings>>
  <<org-src-settings>>
  <<org-functions>>
  <<org-agenda>>
  <<org-navigation-transient>>
  <<org-modules>>)
#+end_src

** Org settings

I like having indentation in my org files (but not when using olivetti). Right now I turn it on during startup.
#+begin_src emacs-lisp :tangle no :noweb-ref org-init
(setq org-startup-indented t)
#+end_src

By default, org right-adjusts tags to column 80. I'm used to them following the title, just in a less conspicuous face.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-tags-column 0)
#+end_src

One of the many things I liked about Doom was the TODO settings. Fast TODO selection was on by default, which I think is a great idea if you are using more keywords than just TODO and DONE.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-use-fast-todo-selection t)
#+end_src

A little breathing space between org headings is alright. One problem with keeping them too tight is that it can sometimes confuse Emacs faces (i.e. if there is a =*= on a line directly preceding a heading, everything after the asterisk with be boldfaced).
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-blank-before-new-entry
      '((heading . t)
        (plain-list-item . nil)))
#+end_src

However, when my headings are collapsed into a list, I don't want to see gaps.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-cycle-separator-lines 0)
#+end_src

By default, I want org to show me the ancestry of a node when I'm dropping to it from somewhere else.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(map-put! org-fold-show-context-detail 'default 'tree)
#+end_src

Here I set the org file associations, i.e. how org opens file links. I don't like reading PDFs inside Emacs. Dedicated readers are a lot faster and have better commands (although I do use Emacs to comment PDFs). With zathura, and probably other PDF readers too, it's possible to open a file on a particular page. Emacs will do this when the file link ends in, e.g. ".pdf::123", as defined in the regex below.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-file-apps
      `((auto-mode . emacs)
        (,(rx ".pdf::" (group (one-or-more digit)) string-end) . "zathura %s -P %1")
        (,(rx ".pdf" string-end) . "zathura %s")
        (directory . emacs)))
#+end_src

The URL opener has to be set separately (although it works everywhere, not just in org). There are a few in-built options, such as Firefox, but if you're using something less popular, like I am, you can still set it here.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "qutebrowser")
#+end_src

Show tooltips. I am using this for displaying org link paths when the pointer is on a link. This may not be the best use of this functionality, and I do have an alternative implementation.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq help-at-pt-display-when-idle t
      help-at-pt-timer-delay 0.1)
(help-at-pt-set-timer)
#+end_src

I use several additional TODO keywords of my own choosing. I got the idea from Doom, but changed the keywords themselves.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-todo-keywords
      '((sequence "TODO(t)" "|" "DONE(d)")
        (sequence "NEXT(n)" "WAITING(w)" "LATER(l)" "LOOP(p)" "|" "CANCELLED(c)")))
#+end_src

I saw the LOOP keyword somewhere in a blog post, I think, and though it was a great name for a constantly repeating task, which is how I'm using it here.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-todo-repeat-to-state "LOOP")
#+end_src

Another idea inspired by Doom's config (and my Doom config): new faces for custom TODO keywords. I don't need every face to have its own colour though, just something that tells me at a glance if I should be paying attention. (The =org-done= face is changed in my Theming settings to a grey colour.)
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(defface +org-todo-important
  '((t :inherit org-todo
       :foreground "#dc322f"))
  "For very important todo items.")

;; Colour taken from hl-todo.
(defface +org-todo-unimportant
  '((t :inherit org-todo
       :foreground "#d0bf8f"))
  "For less urgent todo items.")

(setq org-todo-keyword-faces
      '(("LATER"     +org-todo-unimportant)
        ("NEXT"      +org-todo-important)
        ("WAITING"   +org-todo-unimportant)
        ("LOOP"      +org-todo-unimportant)
        ("CANCELLED" org-done)))
#+end_src

I use the org archiving functionality often when I think there is the slightest possibility I will need the information later (if not, I just delete it). However, I don't need separate archives for each file, as is the default. I set it to a file with a relative path, but that's okay, because I only ever archive entries from my org-dir.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-archive-location ".archive.org::")
#+end_src

I rarely have to enter dates or times that have already passed, since my primary use of the date functionality is scheduling. This setting lets me input future dates and times with fewer keystrokes.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-read-date-prefer-future 'time)
#+end_src

This bit of witchcraft, [[https://github.com/doomemacs/doomemacs/blob/ba1dca322f9a07bc2b7bec6a98f2c3c55c0bbd77/modules/lang/org/config.el#L503-L517][extracted from Doom]] and simplified, colours a file link with a different colour (from the current theme's warning face) if Emacs can't find the file it refers to. Very simple idea, but brilliant in its simplicity, and wonderfully executed.
#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(org-link-set-parameters
 "file" :face (lambda (path)
                (if (file-exists-p path)
                    'org-link
                  '(warning org-link))))
#+end_src

** Org-src

I don't want to see any extra indentation in my source blocks, nor be asked questions about the safety of my own code.

#+begin_src emacs-lisp :tangle no :noweb-ref org-src-settings
(setq org-edit-src-content-indentation 0)
(setq org-confirm-babel-evaluate nil)
#+end_src

I mostly use org-src when editing this config, but since I've been doing that a lot lately, I decided to make it a little more comfortable for myself. I use my =ZZ= and =ZQ= bindings to exit org-src buffers with and without saving my changes, respectively.

#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(with-eval-after-load 'org-src
  (keymap-set org-src-mode-map "<remap> <save-buffers-kill-terminal>" 'org-edit-src-exit)
  (keymap-set org-src-mode-map "<remap> <save-buffers-kill-terminal>" 'org-edit-src-exit)
  (keymap-set org-src-mode-map "<remap> <kill-emacs>" #'org-edit-src-abort))
#+end_src

** Snippet expansion in org

Binding to =org-cycle= (usually TAB) or =org-ctrl-c-ctrl-c= does not follow the usual procedure. Because these keys are context-dependent to begin with, it's generally not a good idea to rebind them completely, since you might screw up additional contexts you didn't even realize were there before rebinding. Instead, additional functionality is added via hooks which are run before the main body of the function. If any of the functions returns a non-nil value, then the main body isn't run. It's the next best thing to a =cond= in the function itself.

Trying to bind tempel's expansion to TAB was a tad involved. The expansion function returns a non-nil value even when it fails, so I ended up writing a small wrapper function that returns =nil= on failure. This way the hook can successfully fall through.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +tempel-expand-maybe ()
  "Try to expand a snippet with tempel.
If expansion fails, return nil.
This function is specifically for use with org-cycle."
  (ignore-errors ; <- returns nil instead of error
    (when boon-insert-state
      (tempel-expand t))))
#+end_src

I then add the function to the hook run before =org-cycle=.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-cycle-tab-first . +tempel-expand-maybe)
#+end_src

** Org agenda

#+begin_src emacs-lisp
(use-package org-agenda
  :ensure nil
  :after org
  :bind
  (:map org-agenda-mode-map
   ("b" . org-agenda-earlier)
   ("f" . org-agenda-later)
   ("(" . org-agenda-earlier)
   (")" . org-agenda-later)
   ("u" . link-hint-open-link)
   ("v" . nil)
   ("vw" . org-agenda-week-view)
   ("vm" . org-agenda-month-view)
   ;; bit different behaviour from link-hint
   ("<return>" . org-agenda-goto)))
#+end_src

*** Org agenda settings

I prefer the agenda to always open in fullscreen mode.
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda
(setq org-agenda-window-setup 'only-window)
#+end_src

I like to see the agenda for the current calendar week, but with the point on today's date (it also has a different face in my theme).

Weeks start on Mondays. Fite me.
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda
(setq org-agenda-span 'week
      org-agenda-start-on-weekday 1
      org-agenda-start-day ".")
#+end_src

When I jump to an org headline from agenda, I want to see its full ancestry and the entry text itself.
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda
(map-put! org-fold-show-context-detail 'agenda 'tree)
#+end_src

I use my whole org directory as my agenda list. If something gets an active timestamp, I want to see it in my agenda (and there is always =org-time-stamp-inactive=).
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda
(setq org-agenda-files (list org-directory))
#+end_src

** Org bling

Org-mode is amazing, but doesn't look it out of the box. Some light eye candy makes it an even bigger pleasure to use.

*** Org-modern

When using Doom, I bounced off one of its org beautification settings, which slowed down my Emacs quite noticeably. Right now I am using [[https://github.com/minad/org-modern][org-modern]] on a Surface Go 2, and it isn't slow at all.

I don't use all of the defaults though. I prefer my own faces for todos, and I'm not yet sure what to do with the tables.

With org-lists, I use "-" everywhere, because it's easily reachable on Dvorak. The default replacement for "-" is a longer dash, but I like nice fat dots instead.

#+begin_src emacs-lisp
(use-package org-modern
  :hook org-mode
  :config
  (setq org-modern-todo nil
        org-modern-table nil)
  (map-put! org-modern-list ?- "•"))
#+end_src

*** Table alignment with valign

Valign works much better with tables containing CJK and symbols than other similar packages. However, I've had it be a little slow, so I'm not turning it on by default, at least not yet.

#+begin_src emacs-lisp
(use-package valign
  :commands (valign-mode))
#+end_src

*** Font lock for text in org checked items

Yet another fantastic idea from Doom: a special face for list items with a checked checkbox, as in this example:

- [ ] unchecked
- [X] checked

Which in my Emacs looks like this:

[[./img/checkbox.png]]

Headings with DONE have a special face that's in-built and can be customized, but the same does not exist for checked list items. Doom had its own workaround, which I was unable to find after a couple days' searching, but I did find [[https://fuco1.github.io/2017-05-25-Fontify-done-checkbox-items-in-org-mode.html][this blog post]], which referenced hlissner's config from 2017 (aka proto-Doom). Based on the code therein and on the [[info:elisp#Search-based Fontification][info node]], I wrote my own version. I use a simpler regex than what I've seen online, because I don't use =[X/Y]= in checkboxes.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-add-checked-font-lock ()
  (font-lock-add-keywords
   nil
   ;; (rx (seq line-start (* space) "- [X] " (+ not-newline)))
   `(("^[[:space:]]*- \\[X] .+" 0 'org-headline-done prepend))
   'append))
#+end_src

Using a hook appears to be more reliable than just a bare =font-lock-add-keywords= setting, though. I'm not sure why, since other people's configs use it without a hook. Some part of my config must be interfering with it.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-mode . +org-add-checked-font-lock)
#+end_src

*** Org-appear

Hiding emphasis markers in org-mode makes it look quite nice, however it also makes editing more difficult. The [[https://github.com/awth13/org-appear][org-appear]] package shows hidden emphasis markers when the cursor is on an emphasized word, solving that problem.

#+begin_src emacs-lisp
(use-package org-appear
  :commands (org-appear-mode))
#+end_src

I hook the package to open together with org.

#+begin_src emacs-lisp :tangle no :noweb-ref org-hooks
(org-mode . org-appear-mode)
#+end_src

Now the emphasis markers may safely be hidden.

#+begin_src emacs-lisp :tangle no :noweb-ref org-settings
(setq org-hide-emphasis-markers t)
#+end_src

** Transient navigation

Instead of pressing key combinations or chords repeatedly to navigate, we can define a transient state and use simple keys while in it. I got the idea from [[https://github.com/Somelauw/evil-org-mode/blob/master/doc/example_config.el][this evil-org example]] that uses hydra, but I'm using transient because I'm more used to it, and because it's now built into Emacs (as of 28).

#+begin_src emacs-lisp :tangle no :noweb-ref org-navigation-transient
(defun +scroll-line-to-top ()
  ;; Taken from `evil-scroll-line-to-top'
  (interactive)
  (recenter (1- (max 1 scroll-margin))))

(defmacro with-org-show (&rest body)
  `(progn
     ,@body
     (+scroll-line-to-top)
     (org-fold-show-entry)
     (org-fold-show-children)))

;; This is not in the transient, move out
(defun +org-up-heading ()
  "Go up to the nearest heading, or to a higher level heading.
If not on a heading, finds the next heading backwards.
If already on a heading, goes higher up in the tree. This
makes sense to me to combine into a single keybinding."
  (interactive)
  (if (org-at-heading-p)
      (with-org-show
       (org-previous-visible-heading 1))
    (org-back-to-heading)))

(defun +org-up-level-and-show ()
  (interactive)
  (cond
   ((not (org-at-heading-p)) (org-back-to-heading))
   ((= 1 (org-current-level)) (ignore))
   (t (org-up-element))))

(defun +org-down-and-show ()
  (interactive)
  (when (org-at-heading-p)
    (with-org-show
     (org-next-visible-heading 1))))

(defun +org-up-same-level ()
  (interactive)
  (with-org-show
   (org-fold-hide-subtree)
   (org-backward-heading-same-level 1 t)))

(defun +org-down-same-level ()
  (interactive)
  (with-org-show
   (org-fold-hide-subtree)
   (org-forward-heading-same-level 1 t)))

;; add link-hint on u?
(transient-define-prefix +org-movement-transient ()
  ["Moving around in org"
   [("h" "up level" +org-up-level-and-show :transient t)
    ("c" "up (same level)" +org-up-heading :transient t)
    ("t" "down (same level)" +org-down-same-level :transient t)
    ("n" "down level" +org-down-and-show :transient t)]
   [("<tab>" "cycle" org-cycle :transient t)
    ("<backtab>" "cycle all" org-shifttab :transient t)
    ("<SPC>" "scroll down" scroll-up :transient t)]
   [("q" "quit" transient-quit-all)]])
#+end_src

** Pandoc integration

My personal interface to pandoc from Emacs is written in a [[./pandoc.el][separate file]] as a module. There is a single entry point: a transient function (aptly named =pandoc-transient=), which allows the user to interactively construct a pandoc call, and then executes it.

I might make it into its own package later, but there is currently no shortage of pandoc APIs for Emacs, and my version is very much tailored to my personal needs and those alone.

Here we load the file.
#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "pandoc.el"))
#+end_src

The only keybinding required is for the transient entry point, which I set together with my other org bindings.

** Links

This is another personal package of mine, whose purpose is to insert all kinds of links in org:
- to org headings in the current file,
- to files on the system,
- links from the system clipboard.

#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "links.el"))
#+end_src

As with other commands, I like having it all in one big transient menu.

#+begin_src emacs-lisp
(transient-define-prefix +link-transient ()
  ["Org links"
   ["insert link..."
    ("l" "do-what-i-mean" +org-link-dwim)
    ("c" "from clipboard" +org-insert-link-from-clipboard)
    ("f" "to file" +org-insert-file-path)]
   ["link to org heading..."
    ("h" "with heading text" +org-insert-link)
    ("u" "with a unique ID" +org-insert-link-with-id)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Cross-referencing

This is a package to simplify inserting cross-references in org for later compilation with pandoc, and is in a way a sister package to my =pandoc.el=.

#+begin_src emacs-lisp :tangle no :noweb-ref org-modules
(load-file (concat user-emacs-directory "refs.el"))
#+end_src

Again, a transient. Since I'm using transients instead of regular evil keybindings, I could make capitalization an infix instead of having separate bindings. Although it's not like I'm running out of keys. Something to ponder.

#+begin_src emacs-lisp
(transient-define-prefix +ref-transient ()
  ["Pandoc cross-references in Org"
   ["insert reference..."
    ("h" "to heading" +ref-insert-ref-heading)
    ("t" "to table" +ref-insert-ref-table)
    ("f" "to figure" +ref-insert-ref-figure)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

** Org cite

It's pretty awesome that org-mode now has in-built citation capabilities. I write my papers in org-mode, and having a stable citation API gives me confidence that my config won't need constant package and workflow changes (even though I started writing academic papers in org-mode even before org-cite).

#+begin_src emacs-lisp
(use-package org-cite
  :ensure nil
  :after org)
#+end_src

However, the org-cite API itself is quite opaque. It appears to rely heavily on objects from Emacs' EIEIO library, which I'm not familiar with. I did manage to write a citation processor to open my citations in ebib on the corresponding paper, but the process was unnecessarily complicated and not very well documented. In the end I opted for my own handwritten code (see the [[id:60496f16-000c-4e9f-8522-848f300523a9][org-return]] and [[id:067dfe76-a65f-44b6-ab9d-a72b875071d2][link hinting]] sections) because that's easier to understand, maintain, and improve.

As such, the code below is *disabled*, but preserved for posterity.

#+begin_src emacs-lisp :tangle no
(defun +ebib-open-on-citation (citation _)
  (let ((key (map-elt (cadr citation) :key)))
    (ebib)
    (ebib-db-set-current-entry-key key ebib--cur-db)
    (ebib--update-buffers 'no-refresh)))

(org-cite-register-processor '+org-cite-follow-processor
  ;; Note that the citation is passed as an object, not a string.
  ;; The follow function must take two arguments.
  ;; See `org-cite-register-processor' documentation for details.
  :follow #'+ebib-open-on-citation)

(setq org-cite-global-bibliography (list +default-bibliography))
(setq org-cite-follow-processor '+org-cite-follow-processor)
#+end_src

** Org functions

Searching by heading is my primary means of navigating org files. Consult does this admirably. Problem is, when I'm jumping to an org heading, chances are I want to see what's inside it. I don't want to mash Tab repeatedly every time I jump to a a heading.

Unfortunately, =consult-org-heading= doesn't have a hook. Maybe I should ask the dev nicely?
#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +consult-goto-org-heading ()
    "Find an org heading in the current buffer, and open it.
`consult-org-heading' doesn't do this automatically for some reason."
    (interactive)
    (consult-org-heading)
    (org-fold-show-context)
    (org-fold-show-entry)
    (org-fold-show-children))
#+end_src

Adding tags is very easy is org, but removing them is not. I don't normally have a bunch of tags on every heading in org---usually just one. I like being able to remove all tags with a quick keystroke. For finer edits, I can always resort to more manual methods.
#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-remove-tags ()
  "Remove all tags from current heading."
  (interactive)
  (org-set-tags nil))
#+end_src

*** My version of org-return
:PROPERTIES:
:ID:       60496f16-000c-4e9f-8522-848f300523a9
:END:

I believe org-mode first started the fashion of contextually dependent actions in Emacs (aka "dwim"). Then Doom took it and expanded it further. The idea is great, and here I put my own spin on it. This function is bound to =<return>=, of course.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-return ()
  "Perform an action dependent on context.
If on a...
- list item with checkbox: toggle checkbox.
- table: move to next row, possibly creating one (jump out of table with =C-RET=).
- image or image link: toggle displaying the image.
- citation: open in ebib.
- URL: open it.
- org link: follow it.
- source block: edit it.
"
  (interactive)
  (cond
   ;; table, including in insert state
   ((org-at-table-p) (org-table-next-row))
   ;; insert state everywhere else
   (boon-insert-state (newline-and-indent))
   ;; list with checkbox
   ((org-at-item-checkbox-p) (org-toggle-checkbox))
   ;; image
   ((when-cond ((bounds (org-in-regexp +org-image-regexp)))
      (+org-toggle-image (car bounds) (cdr bounds))))
   ;; citation
   ((when-cond ((bounds (org-in-regexp +org-cite-regexp)))
      (+org-follow-cite (car bounds) (cdr bounds))))
   ;; a regular URL string with no description
   ((when-cond ((bounds (org-in-regexp +url-regexp))
                (url (buffer-substring-no-properties (car bounds) (cdr bounds))))
      (browse-url url)))
   ;; an org link of any kind, including URLs with descriptions
   ((org-in-regexp org-link-bracket-re) (link-hint-open-link-at-point))
   ;; org-src block
   ((org-in-src-block-p) (org-edit-src-code))))

(defmacro when-cond (spec &rest body)
  "Like `when-let', but returns true on successful binding.
For use inside `cond'."
  (declare (indent 1) (debug if-let))
  `(if-let ,spec ,(macroexp-progn (append body (list t)))))

(defun +org-follow-cite (beg end)
  (let* ((keys (->> (buffer-substring-no-properties beg end)
                    (s-match-strings-all +org-cite-key-regexp)
                    (-map #'-second-item))))
    (pcase (length keys)
      (0 (user-error "No keys found!"))
      (1 (+ebib-open-on-key (car keys)))
      (_ (let ((key (completing-read "Choose key to open: " keys)))
           (+ebib-open-on-key key))))))

(defvar +org-cite-regexp
  (rx (seq "[cite"
           (opt ?/ (one-or-more (any alnum ?/ ?_ ?-)))
           ":" (zero-or-more (not (any ?\[ ?\]))) "]")))

(defvar +org-cite-key-regexp
  (rx (seq "@" (group (one-or-more (or alnum ?- ?_))))))

(defun +ebib-open-on-key (key)
  (ebib)
  (ebib-db-set-current-entry-key key ebib--cur-db)
  (ebib--update-buffers 'no-refresh))

(defun +org-toggle-image (beg end)
  (org-toggle-inline-images nil beg end))

(defvar +org-image-regexp
  (rx (seq "[[./" (+? anything) "." (or "png" "jpg" "jpeg" "svg") "]]")))

(with-eval-after-load 'thingatpt
  (defvar +url-regexp
    (concat "\\<"
            (regexp-opt '("http://" "https://" "doi:") t)
            thing-at-point-url-path-regexp)
    "Basically a simplified version of `goto-address-url-regxp'"))
#+end_src

*** Org item insertion

'Item' can mean a bullet point in a list, or a heading. This is a contextually determined function that I prefer to bind to =C-<return>=.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-list-insert-and-indent (&optional checkbox?)
  "Insert a new row in a list.
Respects current indentation and checkbox.
Helper function for `+org-insert-item'."
  (let ((indentation (current-indentation)))
    (when (region-active-p)
      (meow-cancel-selection))
    (end-of-line)
    (org-insert-item checkbox?)
    (indent-line-to indentation)
    (end-of-line)
    (meow-insert)))

(defun +org-insert-item ()
  "Insert an item determined from context.
When point is on a...
- list item with a checkbox: insert a new list item with a checkbox,
- list item without a checkbox: insert a new list item without a checkbox,
- table: break the table after that row,
- elsewhere: insert a heading.

I use it to break tables because I have other functions that
take care of inserting new rows (both on Return and on my
line insertion functions), so instead I need some way of
jumping out or splitting a table.
"
  (interactive)
  (cond
   ;; list item with checkbox
   ((org-at-item-checkbox-p) (+org-list-insert-and-indent 'checkbox))
   ;; list item without checkbox
   ((org-at-item-p) (+org-list-insert-and-indent))
   ;; table
   ((org-at-table-p)
    (end-of-line)
    (newline))
   ;; elsewhere
   (t (org-insert-heading-respect-content))))
#+end_src

*** Org table row insertion

An idea I stole from [[https://github.com/Somelauw/evil-org-mode/blob/b1f309726b1326e1a103742524ec331789f2bf94/evil-org.el#L86-L91][evil-org]] that goes something like this: instead of regular newline insertion above/below the current line, insert a new table row if the point is inside a table. Since in regular text this enters insert state, I do the same in tables.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-table-insert-row (&optional below?)
  "Create a new table row and enter insert state in it in the same column."
  (when (region-active-p)
    (meow-cancel-selection))
  (let ((col (org-table-current-column)))
    (org-table-insert-row below?)
    (org-table-goto-column col)
    (meow-insert)))

(defun +org-open-below ()
  (interactive)
  (if (org-at-table-p)
      (+org-table-insert-row 'below)
    (meow-open-below)))

(defun +org-open-above ()
  (interactive)
  (if (org-at-table-p)
      (+org-table-insert-row)
    (meow-open-above)))
#+end_src

*** Org-refile

When refiling subtrees, I rarely move them outside the current file. Having incremental completion for the target makes refiling functions much more useful, and it's easy to achive with a simple function wrapping consult.

#+begin_src emacs-lisp :tangle no :noweb-ref org-functions
(defun +org-refile-to-this-file ()
  (interactive)
  (let* ((loc-pair (save-excursion
                     (consult-org-heading)
                     (cons (org-get-heading) (point))))
         (heading (car loc-pair))
         (location (cdr loc-pair)))
    (org-refile nil
                (current-buffer)
                (list heading (buffer-file-name) nil location))))
#+end_src

*** Link path tooltip

Usually, we hide link URLs and display just the description. Doom Emacs shows a link URL tooltip in the echo area, similar to how eldoc shows the documentation for the function at point. That's pretty neat functionality, but it was surprisingly difficult to search for online. I found no discussions or questions about this sort of feature.

This is a relatively simple implementation. The function itself checks if the point is in a link regex, and if it is, displays the first group (the URL) as a message. I then hook it up to =post-command-hook= *locally*, so that it only works in org-mode.

I currently have it *turned off* because I'm using =help-at-pt-set-timer= (NB: check source of the fn, see also [[info:elisp#Idle Timers][info node]]). However, my approach is more flexible, and I might want to come back to it.

#+begin_src emacs-lisp :tangle no
(defun +org-link-tooltip ()
  "Display the URL of the link at point in the echo area."
  (interactive) ; for testing purposes only
  (when (org-in-regexp org-link-bracket-re)
    (message "Link: %s" (match-string 1))))

(add-hook 'org-mode-hook
          (lambda ()
            (add-hook 'post-command-hook #'+org-link-tooltip 0 'local)))
#+end_src

** Toc-org

The sole purpose of this package is to make it easier to read this config online by generating a browser-friendly table of contents. You're welcome.

#+begin_src emacs-lisp
(use-package toc-org
  :after org
  :hook (org-mode . toc-org-mode))
#+end_src

* Bibliography and citations

** Ebib

[[https://github.com/joostkremers/ebib][Ebib]] is a bibliography/reference manager written in Elisp, so that it runs inside Emacs. For normal people that in itself is a losing proposition, but since we use Emacs, it's worth looking into. I'm not of the opinion that anything and everything should be run inside Emacs, but Ebib is great! It provides all the functionality I need while staying out of my way. It integrates excellently with Emacs, provides referencing capability, and gives me full control of all of its aspects.

Sure, it doesn't have the bells and whistles of [[https://www.zotero.org/][other bibliography managers]], but I don't need those. I need to be able to cite papers while writing, and to quickly open PDFs whenever I feel like it. Ebib does that, and more.

#+begin_src emacs-lisp :noweb yes
(use-package ebib
  :commands (ebib ebib-insert-citation)
  :bind
  <<ebib-keybindings>>
  :config
  <<ebib-functions>>
  <<ebib-settings>>)
#+end_src

*** Settings

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-settings
(setq ebib-preload-bib-files (list +default-bibliography))
;; (setq ebib-notes-directory +ebib-notes)
(setq ebib-file-search-dirs (list +ebib-file-search-dir))
(setq ebib-import-directory +ebib-import-directory)
(setq ebib-file-associations '(("pdf" . "zathura") ("ps" . "gv")))
(setq ebib-bibtex-dialect 'biblatex)
(setq ebib-citation-insert-multiple t)
(setq ebib-index-columns '(("Author/Editor" 20 t)
                           ("Year" 6 t)
                           ("Title" 40 t)))
(map-put! ebib-reference-templates
          "Article"
          "{Author}. {Date|Year}. {\"Title\".} {Journaltitle|Journal} {Volume}{(Issue)}{:Pages}.{ Doi.}")
(map-put! ebib-reference-templates
          "Book"
          "{Author|Editor}. {Date|Year}. {\"Title\".} {Address: }{Publisher.}")
(setq ebib-notes-name-transform-function #'identity)
(setq ebib-name-transform-function #'+ebib-generate-filename)

;; Set auto-generated citation key options
(setq bibtex-autokey-year-length 4
      bibtex-autokey-titleword-length 0
      bibtex-autokey-name-separator "-"
      bibtex-autokey-year-title-separator ""
      bibtex-autokey-edit-before-use t)
(setq ebib-uniquify-keys t)

(map-put! ebib-citation-commands
          'org-mode
          '((("text" "[cite/t: %(@%K%< %A%>%; )]")
             ("paren" "[cite: %(@%K%< %A%>%; )]")
             ("bare" "@%K")
             ("no-name" "[cite/na: %(@%K%< %A%>%; )]"))))
(map-put! ebib-citation-commands
          'markdown-mode
          '((("text" "@%K%< [%A]%>")
             ("paren" "[%(@%K%<, %A%>%; )]")
             ("year" "[-@%K%< %A%>]"))))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-settings
(add-hook 'ebib-index-mode-hook #'turn-on-truncate-lines)
(add-hook 'ebib-index-mode-hook #'turn-off-visual-line-mode)
#+end_src

*** Functions

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-functions
(defun +ebib-get-author-names (key)
  (let ((names
         (->>
          (ebib-get-field-value "author" key ebib--cur-db "default" 'unbraced)
          (s-split " and ")
          (--map (car (s-split "," it))))))
    (if (< 2 (length names))
        (concat (car names) " et al")
      (s-join " and " names))))

(defun +ebib-get-year (key)
  (let ((date
         (or
          (ebib-get-field-value "date" key ebib--cur-db 'noerror 'unbraced)
          (ebib-get-field-value "year" key ebib--cur-db 'noerror 'unbraced))))
    (->> date
         (s-split "-")
         (-first-item))))

(defun +ebib-get-title (key)
  (let ((title
         (->> (ebib-get-field-value "title" key ebib--cur-db "default" 'unbraced)
              (s-split ":")
              (car)
              (replace-regexp-in-string "[{}]" "")
              (s-trim))))
    (s-truncate 100 title "")))

(defun +ebib-generate-filename (key)
  (let ((names (+ebib-get-author-names key))
        (year (+ebib-get-year key))
        (title (+ebib-get-title key)))
    (->> (list names year title)
         (-non-nil)
         (s-join " ")
         (replace-regexp-in-string "/" "")
         (replace-regexp-in-string "," "")
         (replace-regexp-in-string " " "_"))))

(defun +ebib-edit-as-string ()
  "Edit the current field as a string.
This is a function for `ebib-entry-mode'. Since `ebib-edit-field'
has to take a numeric prefix /= 1 in order to begin string
editing, it seems easier to abstract this into a function and
give it its own name and keybinding."
  (interactive)
  (ebib-edit-field 2))

(defun +ebib-import-file-from-index ()
  "Import a file and add to the entry at point.
Used from the ebib index."
  (interactive)
  (ebib-edit-entry)
  (ebib-import-file nil)
  (ebib-quit-entry-buffer))
#+end_src

*** Keybindings

Meow-agnostic keybindings for ebib. I should unbind or rebind "h" and "n" though, since lateral movement doesn't figure in ebib.

#+begin_src emacs-lisp :tangle no :noweb-ref ebib-keybindings
(:map ebib-index-mode-map
      ("q" . ebib-quit)
      ("u" . 'ebib-prev-entry)
      ("e" . 'ebib-next-entry)
      ("s" . ebib-save-current-database)
      ("S" . ebib-save-all-databases)
      ;; Unset N while I'm figuring out what to do with notes.
      ("N" . nil)
      ("/" . ebib-jump-to-entry)
      ("<tab>" . ebib-edit-entry)
      ("f" . 'ebib-view-file)
      ("O" . ebib-open-bibtex-file)
      ("o" . nil)
      ("of" . +ebib-import-file-from-index)
 :map ebib-entry-mode-map
      ("q" . ebib-quit)
      ("u" . 'ebib-prev-field)
      ("e" . 'ebib-next-field)
      ("z" . ebib-leave-ebib-windows)
      ("E" . +ebib-edit-as-string)
      ("s" . ebib-save-current-database)
      ("S" . ebib-save-all-databases)
      ("D" . ebib-delete-current-field-contents)
      ("<tab>" . ebib-quit-entry-buffer)
      ("O" . ebib-open-bibtex-file)
      ("o" . nil)
      ("of" . ebib-import-file))
#+end_src

* Programming languages

** Lisps
Smartparens is THE package for lisp code editing.
#+begin_src emacs-lisp :noweb yes
(use-package smartparens
  :hook (prog-mode) ;; should probably narrow it down to lisps
  :config
  ;; load default config
  (require 'smartparens-config)
  ;; <<smartparens-keybindings>>
  )
#+end_src

#+begin_src emacs-lisp
(use-package eros
  :hook emacs-lisp-mode)
#+end_src

Examples can be found in the [[https://github.com/Fuco1/smartparens/wiki][wiki]] and in [[https://ebzzry.com/en/emacs-pairs/][this article]].

** Emacs Lisp

#+begin_src emacs-lisp
(use-package elisp-mode
  :ensure nil
  :bind (:map emacs-lisp-mode-map
              ("C-c o e" . +elisp-eval-transient)
              ("C-c o w" . sp-wrap-round)
              ("C-c o (" . sp-backward-slurp-sexp)
              ("C-c o )" . sp-forward-slurp-sexp)
              ("C-c o <" . sp-backward-barf-sexp)
              ("C-c o >" . sp-forward-barf-sexp)))
#+end_src

#+begin_src emacs-lisp
(use-package eldoc
  :config
  (setq eldoc-idle-delay 0))
#+end_src

#+begin_src emacs-lisp
(use-package elisp-demos
  :after helpful
  :config
  (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

#+begin_src emacs-lisp
(transient-define-prefix +elisp-eval-transient ()
  ["Eval..."
   ("e" "last sexp" eval-last-sexp)
   ("r" "and replace" crux-eval-and-replace)
   ("b" "buffer" eval-buffer)])
#+end_src

** Clojure

See also the following:
- [[https://github.com/clojure-emacs/clojure-mode/][clojure-mode]]
- [[https://github.com/clojure-emacs/cider][cider]]
- [[https://github.com/clojure-emacs/clj-refactor.el][clj-refactor]]
- [[https://docs.doomemacs.org/latest/modules/lang/clojure/][clojure doom module]]

#+begin_src emacs-lisp
(use-package clojure-mode
  :defer t
  :config
  (evil-define-key 'normal clojure-mode-map
    (kbd "<localleader>'") #'cider-jack-in))
#+end_src

#+begin_src emacs-lisp
(use-package cider
  :commands (cider-jack-in cider-jack-in-clj cider-jack-in-cljs
             cider-connect-clj cider-connect-cljs)
  :config
  (setq cider-allow-jack-in-without-project t
        cider-jack-in-default 'babashka
        cider-repl-pop-to-buffer-on-connect nil)

  (evil-define-key 'normal clojure-mode-map
    (kbd "<localleader>ee") #'cider-eval-last-sexp
    (kbd "<localleader>pp") #'cider-pprint-eval-last-sexp-to-comment
    (kbd "<localleader>(") #'sp-backward-slurp-sexp
    (kbd "<localleader>)") #'sp-forward-slurp-sexp
    (kbd "<localleader>rq") #'cider-quit))
#+end_src

* Utils
** Magit

Consider also [[https://github.com/alphapapa/magit-todos][magit-todos]].

#+begin_src emacs-lisp
(use-package magit
  :commands (magit)
  :bind (:map magit-mode-map
         ("p" . magit-push)
         ("f" . magit-pull)
         :map magit-diff-section-map
         ("C" . magit-commit))
  :config
  (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
  (setq git-commit-summary-max-length 50)
  (add-hook 'git-commit-setup-hook #'meow-insert 90)
  (with-eval-after-load 'magit
    (define-key git-commit-mode-map [remap save-buffers-kill-terminal] 'with-editor-finish)
    (define-key git-commit-mode-map [remap kill-emacs]                 'with-editor-cancel)))
#+end_src

*** Git diff highlighting

Changed the settings using [[https://www.reddit.com/r/emacs/comments/582yms/question_changing_the_colour_of_diffhl_indicators/][this discussion]] as a reference.
#+begin_src emacs-lisp :noweb yes
(use-package diff-hl
  :defer 2
  :config
  <<diff-hl-colors>>
  (diff-hl-flydiff-mode)
  (global-diff-hl-mode)
  ;; <<diff-hl-keybindings>>
  )
#+end_src

I stole the insert and delete shades from Doom, because they look really good.

#+begin_src emacs-lisp :tangle no :noweb-ref diff-hl-colors
(custom-set-faces
 '(diff-hl-change ((t (:background "orange2" :foreground "orange2")))) ; #cb4b16
 '(diff-hl-insert ((t (:background "#859900" :foreground "#859900"))))
 '(diff-hl-delete ((t (:background "#dc322f" :foreground "#dc322f")))))
#+end_src

** Tempel snippets
:PROPERTIES:
:ID:       0118536f-8f2f-4e6d-ab30-66bd3101401d
:END:
Trying https://github.com/minad/tempel.

Once I'm inside a snippet, chances are I no longer need to expand more snippets. Instead, I want to be able to use TAB to jump to next placeholder, or move the point after the snippet.

#+begin_src elisp :noweb yes
(use-package tempel
  :commands (tempel-expand)
  :bind (:map tempel-map
          ("TAB" . tempel-next)
          ("<escape>" . tempel-done)))
#+end_src

** Modeline

 Currently using [[https://gitlab.com/jessieh/mood-line][mood-line]] (see [[https://www.reddit.com/r/emacs/comments/c5mel4/what_mode_line_do_you_use_and_why/][here]] for more great packages.)

#+begin_src emacs-lisp
(use-package mood-line
  :config
  ;; can't use unicode glyphs with my current font
  (setq mood-line-glyph-alist mood-line-glyphs-fira-code)
  (mood-line-mode)

  (setq mood-line-format
        (mood-line-defformat
         :left
         (((mood-line-segment-modal) . " ")
          ((or (mood-line-segment-buffer-status) " ") . " ")
          ((mood-line-segment-buffer-name) . " ")
          ((mood-line-segment-anzu) . " ")
          ((mood-line-segment-cursor-position) . " ")
          ((+count-selected-lines) . " ")
          ((mood-line-segment-scroll) . " "))
         :right
         (((mood-line-segment-vc) . "  ")
          ((mood-line-segment-major-mode) . "  ")
          ((mood-line-segment-misc-info) . "  ")
          ((mood-line-segment-checker) . "  ")
          ((mood-line-segment-process) . "  "))))

  (defun +count-selected-lines ()
    (when (region-active-p)
      (let ((numlines
             (1+
              (- (line-number-at-pos (region-end))
                 (line-number-at-pos (region-beginning))))))
        (format #("-%d-" 0 4 (face mood-line-status-error))
                numlines)))))
#+end_src

** Crux

#+begin_src emacs-lisp
(use-package crux
  :commands (crux-delete-file-and-buffer
             crux-rename-file-and-buffer
             crux-sudo-edit
             crux-move-beginning-of-line
             crux-top-join-line
             crux-eval-and-replace))
#+end_src

** Avy

Avy is an amazing package for all kinds of on-screen navigation. I use it to jump around and to open links and citations with link-hint. The one thing I modify in my avy config is the =avy-keys= variable: I map it to the Colemak home row keys. However, it is not advisable to enumerate the home row left to right, since avy takes the keys in order. I go by finger ordering: index, middle, ring, index curved downwards; alternating right and left hands.

#+begin_src emacs-lisp
(use-package avy
  :config
  ;; use Colemak (DH matrix) home row hints
  (setq avy-keys '(?n ?t ?e ?s ?i ?r ?h ?d)))
#+end_src

** Link hinting
:PROPERTIES:
:ID:       067dfe76-a65f-44b6-ab9d-a72b875071d2
:END:

#+begin_src elisp :noweb yes
(use-package link-hint
  :commands (link-hint-open-link link-hint-open-link-at-point)
  :config
  <<link-hint-org-cite>>)
#+end_src

Here I add a new link type for org citations. (Some of the relevant code, e.g. =+org-follow-cite=, is defined elsewhere in the config.) The =:next= and =:at-point-p= keywords are required by link-hint, and =:open= is the functionality that I want. This lets me call link-hint the way I normally do, and through it open citations with my custom function.

#+begin_src emacs-lisp :tangle no :noweb-ref link-hint-org-cite
(link-hint-define-type 'org-cite
  :next #'link-hint--next-org-cite
  :at-point-p #'+org-at-cite-p
  :open #'+org-follow-cite)

(push 'link-hint-org-cite link-hint-types)

(defun +org-at-cite-p ()
  "If the point is on an org citation, return its bounds.
The bounds are returned as a list, to be passed to `+org-follow-cite'."
  (flatten-tree (org-in-regexp +org-cite-regexp)))

(defun link-hint--find-org-cite (start-bound end-bound)
  "Find the first file link.
Only search the range between just after START-BOUND and END-BOUND."
  (save-excursion
    (let (org-cite-pos)
      (goto-char start-bound)
      (link-hint--find-regexp +org-cite-regexp
                              (point) end-bound))))

(defun link-hint--next-org-cite (bound)
  "Find the next org citation.
Only search the range between just after the point and BOUND."
  (link-hint--find-org-cite (point) bound))
#+end_src

** Anzu

[[https://github.com/emacsorphanage/anzu][Anzu]] is a small but pretty important package
that shows the number of search matches in the modeline.
It stays completely out of the way
until you search for occurrences of something,
and then it's indispensable.

#+begin_src emacs-lisp
(use-package anzu
  :init (global-anzu-mode 1))
#+end_src

** hl-todo

#+begin_src emacs-lisp
(use-package hl-todo
  :defer 2
  :config (global-hl-todo-mode 1)
  (transient-define-prefix +hl-todo-transient ()
    ["Change margins..."
     ("n" "next" hl-todo-next :transient t)
     ("p" "previous" hl-todo-previous :transient t)
     ("q" "quit" transient-quit-all)]))
#+end_src

** Olivetti

Olivetti is a great mode for prose writing and reading. All it does is increase the width of the margins to make the text width more comfortable. Another great mode with similar functionality is [[https://github.com/joostkremers/writeroom-mode][writeroom-mode]], but the latter also modifies the modeline.

#+begin_src emacs-lisp
(use-package olivetti
  :commands (olivetti-mode)
  :hook (Info-mode . olivetti-mode)
  :config
  (setq-default olivetti-body-width 40))
#+end_src

** ws-butler
One more package I learned of from Doom's config.

#+begin_src emacs-lisp
(use-package ws-butler
  :init (ws-butler-global-mode 1))
#+end_src

** Help

https://github.com/Wilfred/helpful

#+begin_src emacs-lisp
(use-package helpful
  :commands (+helpful-transient))
#+end_src

** Tldr

[[https://tldr.sh/][Tldr pages]] are a fantastic resource, and Emacs is a great environment to read them. The only problem is that tldr.el's default colour scheme is a war crime, so I disabled all colouring.

#+begin_src emacs-lisp
(use-package tldr
  :custom-face
  (tldr-title
   ((t :foreground nil)))
  (tldr-introduction
   ((t :foreground nil
       :italic nil)))
  (tldr-description
   ((t :foreground nil)))
  (tldr-command-itself
   ((t :foreground nil
       :background nil)))
  (tldr-command-argument
   ((t :foreground nil
       :background nil)))
  (tldr-code-block
   ((t :foreground nil
       :background nil))))
#+end_src

** TODO Undo
See also Hints and undo-fu-session [[https://codeberg.org/ideasman42/emacs-undo-fu][here]].
Can also try [[https://github.com/casouri/vundo][vundo]], although my undo needs aren't that sophisticated.

#+begin_src emacs-lisp
(use-package undo-fu)
#+end_src

** Evil-numbers

Another small package, this time to manipulate numbers.
I occasionally find myself needing to add/subtract a sum
from numbers on a bunch of lines, so this is handy for those situations.

#+begin_src emacs-lisp
(use-package evil-numbers
  :commands (evil-numbers/inc-at-pt
             evil-numbers/dec-at-pt
             evil-numbers/inc-at-pt-incremental
             evil-numbers/dec-at-pt-incremental))
#+end_src

* Finalize

Trick from [[https://blog.d46.us/advanced-emacs-startup/][here]]:
I increase the garbage collection threshold
during startup to speed up Emacs' load time,
but then decrease it once my config loads
so that GC pauses aren't so noticeable
when I'm actually using Emacs.

#+begin_src emacs-lisp
(setq gc-cons-threshold (* 2 1000 1000))
#+end_src

* More packages :noexport:

Here are some packages I should consider trying out:
- Startup screen
  - https://github.com/emacs-dashboard/emacs-dashboard
  - https://github.com/ichernyshovvv/enlight
  - I could also go straight into org-agenda on startup
- https://github.com/alphapapa/org-super-agenda
- https://github.com/jacktasia/dumb-jump for jumping to definition
- https://github.com/jamescherti/inhibit-mouse.el <- completely disable the mouse
- https://github.com/emacsorphanage/macrostep
- https://github.com/wwwjfy/emacs-fish
- https://github.com/yoshiki/yaml-mode
- https://github.com/emacsorphanage/quickrun
- https://github.com/radian-software/apheleia/
- https://github.com/jorgenschaefer/emacs-buttercup
- https://github.com/hlissner/emacs-solaire-mode (necessary? I don't use splits that much)
- https://github.com/kuanyui/tldr.el
- https://github.com/manateelazycat/lsp-bridge <- eglot alternative, advertised as blazingly fast
- https://github.com/flycheck/flycheck
- https://github.com/minad/jinx for spelling
- Think about giving Dired another go
  - Check the [[https://github.com/Fuco1/dired-hacks][dired hacks]] repo for more dired related packages.
- Should also look into terminal emulation in Emacs perhaps. Then again, perhaps not.
- Org-mode:
  - https://github.com/rougier/agenda <- python script, but might be useful?
- https://github.com/Wilfred/deadgrep
- https://github.com/vedang/pdf-tools
- Mail? Consider.
- https://github.com/progfolio/elpaca consider
- Packages for writing prose in [[https://github.com/jacmoe/.doom.d][this config]]

For more packages see here:
https://github.com/emacs-tw/awesome-emacs
