* TODO Immediate priority

If I want to make this more than an experiment, I need the following:
- Proper org config
  - Contextual behaviour (dwim in a few places)
- Fonts (variable width for org)
- Lisp editing (smartparens or the like)

I can then start migrating my Doom config.
** Packages
These are some of the packages I should consider:
- https://github.com/emacs-dashboard/emacs-dashboard
- https://github.com/tarsius/hl-todo
- Modelines:
  - https://github.com/seagle0128/doom-modeline
  - https://github.com/Malabarba/smart-mode-line
- https://github.com/hlissner/emacs-solaire-mode
- https://github.com/lewang/ws-butler
- https://github.com/emacs-evil/evil-surround
- https://github.com/edkolev/evil-lion <- not necessary all the time, but nice when needed
- https://codeberg.org/ideasman42/emacs-undo-fu <- in-built undo is terrible
  - https://codeberg.org/ideasman42/emacs-undo-fu-session
- Maybe https://github.com/redguardtoo/evil-nerd-commenter if what I'm using now is insufficient
- https://github.com/minad/corfu
- https://github.com/jacktasia/dumb-jump for jumping to definition
- https://github.com/kuanyui/tldr.el
- https://github.com/manateelazycat/lsp-bridge <- eglot alternative, advertised as blazingly fast
- https://github.com/flycheck/flycheck
- Think about giving Dired another go
- Org-mode:
  - https://github.com/minad/org-modern <- will it slow?
  - https://github.com/sabof/org-bullets <- if above is slow, can use this instead
  - https://github.com/rougier/agenda <- python script, but might be useful?
- Theming:
  - https://github.com/rougier/nano-emacs and related packages
  - https://github.com/doomemacs/themes
  - https://github.com/bbatsov/zenburn-emacs
  - https://github.com/oneKelvinSmith/monokai-emacs
  - https://github.com/kunalb/poet
  - https://github.com/rougier/nano-theme
- https://github.com/emacsorphanage/git-gutter
- https://github.com/Wilfred/deadgrep
- https://github.com/vedang/pdf-tools
- Mail? Consider.
- https://github.com/progfolio/elpaca consider

* Resources

I can read other people's configs, not limited to literate ones.
- [[https://github.com/bbatsov/emacs.d/blob/master/init.el][bbatsov's minimalist config]]
- [[https://github.com/hrs/dotfiles/blob/main/emacs/.config/emacs/configuration.org][Great evil-based config]]
- [[https://github.com/zzamboni/dot-emacs/blob/master/init.org][Zzamboni's evil-based config]] prior to his migration to Doom. Lots of org gems there.
- [[https://github.com/rougier/dotemacs/blob/master/dotemacs.org][Nicholas Rougier's literate config]]

Might be some interesting stuff here:
https://github.com/daviwil/emacs-from-scratch

For packages see here:
https://github.com/emacs-tw/awesome-emacs

* Basic settings
** Early loading
Maybe some of this should be in =early-init.el=?

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
;; reduce the frequency of garbage collection by making it happen on
;; each 50MB of allocated data (the default is on every 0.76MB)
(setq gc-cons-threshold 50000000)

;; warn when opening files bigger than 100MB
(setq large-file-warning-threshold 100000000)

;; do not create backups
(setq make-backup-files nil)

;; do not pollute this file with custom variables
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+end_src

See also https://github.com/hrs/sensible-defaults.el

** Package management
Instead of putting =:ensure t= everywhere,
I can just set it here once.

#+begin_src elisp
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+end_src

See also =use-package-defaults= for other settings.

#+begin_src elisp
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+end_src

** Theming

#+begin_src elisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(display-line-numbers-mode -1)

;; Soft wrap long lines
(global-visual-line-mode 1)

;; Maintain a small margin when scrolling
(setq scroll-margin 2)

(use-package solarized-theme
  :config
  (load-theme 'solarized-light t))

(set-frame-font "Source Code Pro-18")
#+end_src

* TODO Utility functions

#+begin_src emacs-lisp
(defun +consult-goto-org-heading ()
    "Find an org heading in the current buffer, and open it.
`consult-org-heading' doesn't do this automatically for some reason."
    (interactive)
    (consult-org-heading)
    (org-fold-show-context)
    (org-fold-show-entry)
    (org-fold-show-children))
#+end_src

* Evil

Check out this great macro for evil keybindings with use-package:
https://www.mattduck.com/2023-08-28-extending-use-package-bind

#+begin_src elisp :noweb yes
(use-package evil
  :init 
  (evil-mode 1)
  (setq evil-esc-delay 0)
  ;; Sane undo
  (evil-set-undo-system 'undo-redo)

  <<evil-escape>>

  :config
  ;; (global-evil-surround-mode 1)
  ;; Configure cursor
  <<evil-cursor>>

  ;; Semicolon for M-x
  (evil-define-key '(normal visual) 'global
   ";" #'execute-extended-command)

  ;; Substitute with :s globally by default
  (setq evil-ex-substitute-global t)

  ;; Make evil commands operate on logical, not visual lines
  (setq evil-respect-visual-line-mode nil)

  ;; ESC as C-g
  (evil-global-set-key 'normal (kbd "ESC") #'keyboard-quit)

  (defun +open-config ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  ;; KEYBINDINGS
  ;; space as global leader
  (evil-set-leader 'normal (kbd "SPC"))
  ;; comma as local leader
  (evil-set-leader 'normal (kbd ",") 'localleader)
  ;; Global keybindings
  (evil-define-key '(normal visual) 'global
    "k"  #'evil-previous-visual-line
    "j"  #'evil-next-visual-line
    "gj" #'evil-next-line
    "gk" #'evil-previous-line)
  (evil-define-key 'normal 'global
    ;; Files
    (kbd "<leader>.") #'find-file
    (kbd "<leader>fr") #'recentf
    (kbd "<leader>fs") #'save-buffer
    (kbd "<leader>fc") #'+open-config
    ;; Buffers
    (kbd "<leader>,") #'consult-buffer
    (kbd "<leader>bq") #'kill-this-buffer
    ;; Windows
    (kbd "<leader>w") #'+window-transient
    ;; Line comments
    (kbd "gc") #'comment-line)

  ;; Documentation on leader keys
  (which-key-add-key-based-replacements "<leader>w" "windows")

  ;; Elisp mode
  (evil-define-key 'normal emacs-lisp-mode-map
    (kbd "<localleader>ee") #'eval-last-sexp))
#+end_src

Maybe use https://github.com/emacs-evil/evil-collection ?
There is a minibuffer mode, and modules can be loaded incrementally.

For org-mode specifically, https://github.com/Somelauw/evil-org-mode
has some great ideas, which I could take wholesale as a package,
or steal selectively. See the "[[https://github.com/Somelauw/evil-org-mode/blob/master/doc/example_config.el][elaborate setup]]" example.

Make ESC quit everything.
I tried setting this up in the minibuffer to no avail,
and with other keybinding methods and functions,
but it turned out that a simple line with a =use-package= keyword
was all that was needed.
#+name: evil-escape
#+begin_src emacs-lisp :tangle no
:bind (("<escape>" . keyboard-escape-quit))
#+end_src

Better S motions:
https://github.com/hlissner/evil-snipe

#+name: evil-cursor
#+begin_src emacs-lisp :tangle no
(setq evil-emacs-state-cursor  '("red" box))
(setq evil-normal-state-cursor '("gray" box))
(setq evil-visual-state-cursor '("gray" box))
(setq evil-insert-state-cursor '("gray" bar))
(setq evil-motion-state-cursor '("gray" box))
(blink-cursor-mode -1)
#+end_src

#+begin_src emacs-lisp
(use-package evil-surround
  :ensure t
  :config (global-evil-surround-mode 1))
#+end_src

** Window resizing transient

#+begin_src emacs-lisp
(transient-define-prefix +window-transient ()
  ["Resizing windows"
   ["Transient"
    ("b" "bigger" enlarge-window :transient t)
    ("s" "smaller" shrink-window :transient t)
    ("=" "balance" balance-windows :transient t)]
   ["Non-transient"
    ("d" "delete" delete-window)
    ("w" "other" other-window)
    ("m" "maximize" delete-other-windows)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

* Help

https://github.com/Wilfred/helpful

#+begin_src emacs-lisp
(use-package helpful
  :config
  (evil-global-set-key 'normal (kbd "<leader>h") #'+helpful-transient)
  (evil-define-key 'normal helpful-mode-map "q" #'kill-buffer-and-window))
#+end_src

#+begin_src emacs-lisp
(transient-define-prefix +helpful-transient ()
  ["Emacs help"
   ["Helpful mode"
    ("f" "functions and macros" helpful-callable)
    ("v" "variables" helpful-variable)
    ("k" "key" helpful-key)
    ("c" "interactive functions" helpful-command)
    ("p" "thing at point" helpful-at-point)]
   ["In-built help"
    ("m" "describe mode" describe-mode)]
   [("q" "quit" transient-quit-all)
    ("<escape>" "quit" transient-quit-all)]])
#+end_src

* Narrowing and completion
** Narrowing

TODO: There is a lot of functionality here, I should explore it.
https://github.com/minad/consult
#+begin_src emacs-lisp
(use-package consult)

(use-package vertico
  ;; :custom
  ;; (vertico-scroll-margin 0) ;; Different scroll margin
  ;; (vertico-count 20) ;; Show more candidates
  ;; (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
  ;; (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
  :init (vertico-mode))

(defun up-directory (arg)
  "Move up a directory (delete backwards to /)."
  (interactive "p")
  (if (string-match-p "/." (minibuffer-contents))
      (zap-up-to-char (- arg) ?/)
    (delete-minibuffer-contents)))

(evil-define-key nil minibuffer-local-filename-completion-map [backspace] #'up-directory)

;; Persist history over Emacs restarts.
(use-package savehist
  :init (savehist-mode))

(use-package orderless
  :custom
  (completion-styles '(orderless basic))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles partial-completion)))))

;; Documentation in M-x and minibuffers
(use-package marginalia
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  ;; :bind (:map minibuffer-local-map
  ;;        ("M-A" . marginalia-cycle))

  :init (marginalia-mode))

;; Do not delay which-key (delay has to be above zero)
(use-package which-key
  :init (which-key-mode)
  :config
  (setq which-key-idle-delay 1)
  (setq which-key-idle-secondary-delay 0.05))
#+end_src

There is also https://github.com/oantolin/embark/,
but I haven't learned how to use it properly.

*** TODO File path Backspace behaviour

One thing I have not yet been able to do is
replicate Doom's behaviour with file paths in the minibuffer:
when on =~/aaa/bbb/ccc/=, I want to be able to
delete the whole level (i.e. 'ccc', then 'bbb')
when pressing Backspace.

So far I have only found this, but I haven't succeeded in making it work:
https://www.reddit.com/r/emacs/comments/re31i6/how_to_go_up_one_directory_when_using_findfile_cx/

** TODO Completion

TODO: might also want to take a look at [[https://github.com/minad/corfu][Corfu]], which is supposed to be a smaller package.

Company manual: https://company-mode.github.io/

I do NOT normally want company mode on in org, because that's distracting.
However, its completion of file paths is nice.
If I can turn on only that, I'll use it.
Of course, I could just as easily write my own function to insert a file path.

#+begin_src emacs-lisp
(use-package company
  :init (global-company-mode))
#+end_src

* Org-mode

TODOs:
- Org-refile
- C-RET behaviour on lists

Check out https://github.com/minad/org-modern

#+begin_src emacs-lisp :noweb yes
(use-package org
  :after evil
  :config
  <<org-settings>>
  ;; Set org file associations
  (setq org-file-apps
	`((auto-mode . emacs)
	  (,(rx ".pdf::" (group (one-or-more digit)) string-end) . "zathura %s -P %1")
	  (,(rx ".pdf" string-end) . "zathura %s")
	  (directory . emacs)))

  ;; browser needs to be set with a separate function
  (setq browse-url-browser-function 'browse-url-generic
	browse-url-generic-program "qutebrowser")

  ;; Don't use blank lines between text and the following heading
  (setq org-blank-before-new-entry
	'((heading . t) (plain-list-item . nil)))

  ;; Don't show empty lines between collapsed headings
  (setq org-cycle-separator-lines 0)

  ;; Org todo keywords and colours
  (setq org-todo-keywords
	'((sequence "TODO(t)" "|" "DONE(d)")
	  (sequence "NEXT(n)" "WAITING(w)" "LATER(l)" "LOOP(p)" "|" "CANCELLED(c)")))

  ;; Use LOOP keyword for repeating tasks
  ;; (after marking them as done)
  (setq org-todo-repeat-to-state "LOOP")

  ;; Archive everything from org files in one directory
  ;; into a single hidden file.
  (setq org-archive-location ".archive.org::")

  ;; My custom faces for todo items. I'm reusing most from:
  ;; ~/.emacs.d/modules/lang/org/config.el
  (with-no-warnings
    (custom-declare-face '+org-todo-important '((t (:inherit (bold default)))) ""))

  <<org-src-settings>>
  <<org-keybindings>>)
#+end_src

#+name: org-settings
#+begin_src emacs-lisp :tangle no
(setq org-tags-column 0)
#+end_src

One of the many things I liked about Doom was the TODO settings.
Fast TODO selection was on by default, which I think is a great idea
if you are using more keywords than just TODO and DONE.
#+name: org-settings
#+begin_src emacs-lisp :tangle no
(setq org-use-fast-todo-selection t)
#+end_src

#+name: org-settings
#+begin_src emacs-lisp :tangle no
;; (setq org-tag-faces (:foreground "blue" :weight normal))
#+end_src

#+name: org-src-settings
#+begin_src emacs-lisp :tangle no
(setq org-edit-src-content-indentation 0)
#+end_src

#+name: org-keybindings
#+begin_src emacs-lisp :tangle no
(evil-define-key '(normal visual) org-mode-map
  (kbd "<tab>") #'org-cycle
  (kbd "<localleader>,") #'org-ctrl-c-ctrl-c
  (kbd "<localleader>s") #'org-edit-src-code
  (kbd "<localleader>t") #'org-todo
  (kbd "<localleader>q") #'org-set-tags-command
  (kbd "<localleader>.") #'+consult-goto-org-heading
  (kbd "gh") #'outline-previous-visible-heading)
#+end_src

From evil-org, use evil bindings in source and table editing modes:
#+begin_src emacs-lisp
(with-eval-after-load 'org-src
  (define-key org-src-mode-map [remap evil-save-and-close]          'org-edit-src-exit)
  (define-key org-src-mode-map [remap evil-save-modified-and-close] 'org-edit-src-exit)
  (define-key org-src-mode-map [remap evil-quit]                    'org-edit-src-abort))
#+end_src

** TODO Org-refile

** Transient navigation
Instead of pressing key combinations or chords repeatedly to navigate,
we can define a transient state and use simple keys while in it.
I got the idea from [[https://github.com/Somelauw/evil-org-mode/blob/master/doc/example_config.el][this evil-org example]] that used hydra,
but I'm using transient because I'm more used to it,
and because it's now built into Emacs (as of 28).

#+begin_src emacs-lisp
(transient-define-prefix +org-movement-transient ()
  ["Moving around in org"
   [("k" "up" outline-previous-visible-heading :transient t)
    ("j" "down" outline-next-visible-heading :transient t)]
   [("q" "quit" transient-quit-all)]])
#+end_src

* Link hinting

#+begin_src elisp
(use-package link-hint
  :defer t
  :config
  (evil-define-key 'normal 'global
    (kbd "<leader>u") #'link-hint-open-link))
#+end_src

* Magit

#+begin_src emacs-lisp
(use-package magit
  :config
  (evil-define-key '(normal visual) 'global
   (kbd "<leader>gg") #'magit))
#+end_src

* Snippets
Trying https://github.com/minad/tempel.
It advertises itself as a tiny and more lispy package.
Could be a nice alternative to yasnippet.

Currently I can't get TAB to work as =tempel-next= while expanding.

#+begin_src elisp :noweb yes
(use-package tempel
  :init <<tempel-trigger>>
  :config <<tempel-keybindings>>)
#+end_src

I am using TAB as the key to trigger snippet expansion:
(so far just in org-mode, but later probably globally)
#+name: tempel-trigger
#+begin_src emacs-lisp :tangle no
(evil-define-key 'insert org-mode-map (kbd "<tab>") #'tempel-expand)
#+end_src

However, once I'm inside a snippet, chances are I no longer need to expand more snippets.
Instead, I want to be able to use TAB to jump to next placeholder,
or move the point after the snippet.

For some reason, the following did not work:
#+begin_src emacs-lisp :tangle no
(define-key tempel-map (kbd "TAB") #'tempel-next)
#+end_src
Emacs still read the TAB key as =tempel-expand=.

So I ended up remapping the =tempel-expand= function specifically:
#+name: tempel-keybindings
#+begin_src emacs-lisp :tangle no
(define-key tempel-map [remap tempel-expand] #'tempel-next)
#+end_src
Note that for this to work, =tempel-expand= has to be bound first.
This is why I put =<<tempel-trigger>>= in =:init=,
and =<<tempel-keybindings>>= in =:config=.
